
/* Copyright (c) 2010, Peter Barrett
**
** Permission to use, copy, modify, and/or distribute this software for
** any purpose with or without fee is hereby granted, provided that the
** above copyright notice and this permission notice appear in all copies.
**
** THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
** WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
** WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR
** BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES
** OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
** WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
** ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
** SOFTWARE.
*/

const unsigned short _waveSampleRates[] = {
0x0000,	// no note 0

//   Octave 4
0x0444, // 261.63
0x0485, // 277.18
0x04C9, // 293.66
0x0512, // 311.13
0x055F, // 329.63
0x05B1, // 349.23
0x0608, // 369.99
0x0664, // 392
0x06C5, // 415.3
0x072C, // 440
0x0799, // 466.16
0x080D, // 493.88


//   Octave 5
0x0888, // 523.26
0x090A, // 554.36
0x0993, // 587.32
0x0A25, // 622.26
0x0ABF, // 659.26
0x0B63, // 698.46
0x0C10, // 739.98
0x0CC8, // 784
0x0D8B, // 830.6
0x0E59, // 880
0x0F33, // 932.32
0x101B, // 987.76


//   Octave 6
0x1110, // 1046.52
0x1214, // 1108.72
0x1327, // 1174.64
0x144A, // 1244.52
0x157F, // 1318.52
0x16C7, // 1396.92
0x1821, // 1479.96
0x1991, // 1568
0x1B16, // 1661.2
0x1CB2, // 1760
0x1E67, // 1864.64
0x2036, // 1975.52


//   Octave 7
0x2220, // 2093.04
0x2428, // 2217.44
0x264E, // 2349.28
0x2895, // 2489.04
0x2AFF, // 2637.04
0x2D8E, // 2793.84
0x3043, // 2959.92
0x3322, // 3136
0x362C, // 3322.4
0x3965, // 3520
0x3CCF, // 3729.28
0x406C, // 3951.04


//   Octave 8
0x4441, // 4186.08
0x4850, // 4434.88
0x4C9D, // 4698.56
0x512B, // 4978.08
0x55FF, // 5274.08
0x5B1C, // 5587.68
0x6086, // 5919.84
0x6645, // 6272
0x6C59, // 6644.8
0x72CA, // 7040
0x799E, // 7458.56
0x80D9, // 7902.08
};



//	Yet another sin table
const u8 _wave[] =
{
	0x80,0x83,0x86,0x89,0x8C,0x8F,0x92,0x95,0x98,0x9C,0x9F,0xA2,0xA5,0xA8,0xAB,0xAE,
	0xB0,0xB3,0xB6,0xB9,0xBC,0xBF,0xC1,0xC4,0xC7,0xC9,0xCC,0xCE,0xD1,0xD3,0xD5,0xD8,
	0xDA,0xDC,0xDE,0xE0,0xE2,0xE4,0xE6,0xE8,0xEA,0xEC,0xED,0xEF,0xF0,0xF2,0xF3,0xF5,
	0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFC,0xFD,0xFE,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,
	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xFE,0xFD,0xFC,0xFC,0xFB,0xFA,0xF9,0xF8,0xF7,
	0xF6,0xF5,0xF3,0xF2,0xF0,0xEF,0xED,0xEC,0xEA,0xE8,0xE6,0xE4,0xE2,0xE0,0xDE,0xDC,
	0xDA,0xD8,0xD5,0xD3,0xD1,0xCE,0xCC,0xC9,0xC7,0xC4,0xC1,0xBF,0xBC,0xB9,0xB6,0xB3,
	0xB0,0xAE,0xAB,0xA8,0xA5,0xA2,0x9F,0x9C,0x98,0x95,0x92,0x8F,0x8C,0x89,0x86,0x83,
	0x80,0x7C,0x79,0x76,0x73,0x70,0x6D,0x6A,0x67,0x63,0x60,0x5D,0x5A,0x57,0x54,0x51,
	0x4F,0x4C,0x49,0x46,0x43,0x40,0x3E,0x3B,0x38,0x36,0x33,0x31,0x2E,0x2C,0x2A,0x27,
	0x25,0x23,0x21,0x1F,0x1D,0x1B,0x19,0x17,0x15,0x13,0x12,0x10,0x0F,0x0D,0x0C,0x0A,
	0x09,0x08,0x07,0x06,0x05,0x04,0x03,0x03,0x02,0x01,0x01,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x02,0x03,0x03,0x04,0x05,0x06,0x07,0x08,
	0x09,0x0A,0x0C,0x0D,0x0F,0x10,0x12,0x13,0x15,0x17,0x19,0x1B,0x1D,0x1F,0x21,0x23,
	0x25,0x27,0x2A,0x2C,0x2E,0x31,0x33,0x36,0x38,0x3B,0x3E,0x40,0x43,0x46,0x49,0x4C,
	0x4F,0x51,0x54,0x57,0x5A,0x5D,0x60,0x63,0x67,0x6A,0x6D,0x70,0x73,0x76,0x79,0x7C
};

const u8 _clocks[] = {
	140,
	0x5C,0x57,0x54,0x5C,0x57,0x54,0x5C,0x57,0x5A,0x57,0x52,0x5A,0x57,0x52,0x5A,0x57,
	0x5A,0x57,0x52,0x5A,0x57,0x52,0x5A,0x57,0x59,0x55,0x52,0x59,0x55,0x52,0x59,0x55,
	0x5C,0x57,0x54,0x5C,0x57,0x54,0x5C,0x57,0x5A,0x57,0x52,0x5A,0x57,0x52,0x5A,0x57,
	0x5A,0x57,0x52,0x5A,0x57,0x52,0x5A,0x57,0x59,0x55,0x52,0x59,0x55,0x52,0x59,0x55,
	0,0,0	// pad to 4
};


void MusicPlay(MusicState* s,const u8* track)
{
	s->Duration16th = (15700*15)/track[0];	// hsyncs per 16th
	s->TrackMark = s->Track = track+1;
	s->Duration = 1;
}

u8 MusicSample(MusicState* s)
{
	if (!s->Duration)
		return 0;			// not playing

	//	new note
	if (s->Duration == 1)
	{
		if (!s->TrackMark[0])
			s->TrackMark = s->Track;
		u8 n = *s->TrackMark++;
		s->WaveMark = 0;
		s->WaveStep = _waveSampleRates[n & 0x3F];
		n >>= 6;
		s->Duration = s->Duration16th << n;
	}

	s->Duration--;
	s->WaveMark += s->WaveStep;
	return _wave[(s->WaveMark >> 8) & 0xFF];
}
