
RBox.axf:     file format elf32-littlearm


Disassembly of section .text:

00000000 <g_pfnVectors>:
			);
	*lum = 0x0;
}

int blit_proc_len()
{
       0:	00 20 00 10 a1 2a 00 00 15 2b 00 00 1d 2b 00 00     . ...*...+...+..
	...
	{
		*SYNC = SYNC1;	// End of sync, send colorburst
		volatile uint32_t* spi = &LPC_SSP0->DR;
		*spi = 0x0000;	// breezeway
		*spi = 0x0000;
		*spi = 0xF0F0;	// colorburst 10 cycles into fifo
      2c:	25 2b 00 00 00 00 00 00 00 00 00 00 2d 2b 00 00     %+..........-+..
}

void ComeBackIn(int count)
{
	LPC_TMR16B0->TC = 0;
	LPC_TMR16B0->MR0 = count>>1;
      3c:	09 03 00 00 35 2b 00 00 35 2b 00 00 35 2b 00 00     ....5+..5+..5+..
      4c:	35 2b 00 00 35 2b 00 00 35 2b 00 00 35 2b 00 00     5+..5+..5+..5+..
	*SYNC = 0;							// Start sync
	s->Line += 1;
	int line = s->Line;
	if (line == 262)
	{
		line = s->Line = 0;
      5c:	35 2b 00 00 35 2b 00 00 35 2b 00 00 35 2b 00 00     5+..5+..5+..5+..
};

byte Lerp(byte* rgb, short f)
{
    short c = (rgb[0]*(127-f) + rgb[3]*f) >> 7;
    if (c < 0) return 0;
      6c:	35 2b 00 00 35 2b 00 00 35 2b 00 00 35 2b 00 00     5+..5+..5+..5+..
    0xFF,0xFF,0xFF 
};

byte Lerp(byte* rgb, short f)
{
    short c = (rgb[0]*(127-f) + rgb[3]*f) >> 7;
      7c:	35 2b 00 00 3d 06 00 00 35 2b 00 00 35 2b 00 00     5+..=...5+..5+..
    if (c < 0) return 0;
      8c:	35 2b 00 00 35 2b 00 00 35 2b 00 00 35 2b 00 00     5+..5+..5+..5+..
    0xFF,0xFF,0xFF 
};

byte Lerp(byte* rgb, short f)
{
    short c = (rgb[0]*(127-f) + rgb[3]*f) >> 7;
      9c:	35 2b 00 00 35 2b 00 00 35 2b 00 00 35 2b 00 00     5+..5+..5+..5+..
    if (c < 0) return 0;
      ac:	35 2b 00 00 35 2b 00 00 35 2b 00 00 35 2b 00 00     5+..5+..5+..5+..
    if (c > 255) return 0xFF;
      bc:	35 2b 00 00                                         5+..

000000c0 <__data_section_table>:
      c0:	000032a8 	.word	0x000032a8
    byte* c = _gradientColors + i*3;
    byte r = Lerp(c,f);
    byte g = Lerp(c+1,f);
    byte b = Lerp(c+2,f);
    return ((b & 0xF8) << 8) | ((g & 0xFC) << 3) | (r >> 3);
}
      c4:	10000000 	.word	0x10000000
      c8:	00000470 	.word	0x00000470

000000cc <__bss_section_table>:
      cc:	10000470 	.word	0x10000470

byte Lerp(byte* rgb, short f)
{
    short c = (rgb[0]*(127-f) + rgb[3]*f) >> 7;
    if (c < 0) return 0;
    if (c > 255) return 0xFF;
      d0:	00001430 	.word	0x00001430

000000d4 <blit_proc>:
      d4:	b570      	push	{r4, r5, r6, lr}
      d6:	465e      	mov	r6, fp
      d8:	4655      	mov	r5, sl
      da:	464c      	mov	r4, r9
      dc:	b470      	push	{r4, r5, r6}
      de:	4646      	mov	r6, r8
};

byte Lerp(byte* rgb, short f)
{
    short c = (rgb[0]*(127-f) + rgb[3]*f) >> 7;
    if (c < 0) return 0;
      e0:	b440      	push	{r6}
      e2:	4691      	mov	r9, r2
      e4:	9a08      	ldr	r2, [sp, #32]
      e6:	4683      	mov	fp, r0
      e8:	468a      	mov	sl, r1
      ea:	4698      	mov	r8, r3
//  Lerp
short GetBGColor(short y)
{
    short* p = _gradientPoints;
    int i = 0;
    while (p[i+1] <= y)
      ec:	4694      	mov	ip, r2
      ee:	4658      	mov	r0, fp
      f0:	4651      	mov	r1, sl
      f2:	4642      	mov	r2, r8
      f4:	24aa      	movs	r4, #170
      f6:	600c      	str	r4, [r1, #0]
      f8:	464e      	mov	r6, r9
      fa:	463d      	mov	r5, r7
      fc:	4643      	mov	r3, r8
      fe:	464c      	mov	r4, r9
     100:	b438      	push	{r3, r4, r5}
     102:	4637      	mov	r7, r6
     104:	4666      	mov	r6, ip
     106:	08f6      	lsrs	r6, r6, #3
     108:	00f6      	lsls	r6, r6, #3
     10a:	19f6      	adds	r6, r6, r7
     10c:	46b0      	mov	r8, r6
     10e:	783b      	ldrb	r3, [r7, #0]
     110:	5cd5      	ldrb	r5, [r2, r3]
     112:	78bc      	ldrb	r4, [r7, #2]
//	3648 cpu clocks per scanline
//	Change anything in this region and you will need to fix chroma alignment

void blit_proc(volatile uint32_t* lum,volatile uint32_t* spi, volatile uint8_t* pixels, volatile uint8_t* pal, int count)
{
	asm volatile (
     114:	5cd6      	ldrb	r6, [r2, r3]
     116:	022d      	lsls	r5, r5, #8
     118:	1976      	adds	r6, r6, r5
     11a:	e00a      	b.n	132 <blit_proc+0x5e>
     11c:	7003      	strb	r3, [r0, #0]
     11e:	7a3b      	ldrb	r3, [r7, #8]
     120:	5cd6      	ldrb	r6, [r2, r3]
     122:	0236      	lsls	r6, r6, #8
     124:	3708      	adds	r7, #8
     126:	7004      	strb	r4, [r0, #0]
     128:	78bc      	ldrb	r4, [r7, #2]
     12a:	46b1      	mov	r9, r6
     12c:	5d16      	ldrb	r6, [r2, r4]
     12e:	444e      	add	r6, r9
     130:	7005      	strb	r5, [r0, #0]
     132:	46c0      	nop			(mov r8, r8)
     134:	600e      	str	r6, [r1, #0]
     136:	7003      	strb	r3, [r0, #0]
     138:	793b      	ldrb	r3, [r7, #4]
     13a:	5cd5      	ldrb	r5, [r2, r3]
     13c:	787e      	ldrb	r6, [r7, #1]
     13e:	7006      	strb	r6, [r0, #0]
     140:	022d      	lsls	r5, r5, #8
     142:	46a9      	mov	r9, r5
     144:	78fd      	ldrb	r5, [r7, #3]
     146:	5cd6      	ldrb	r6, [r2, r3]
     148:	7004      	strb	r4, [r0, #0]
     14a:	444e      	add	r6, r9
     14c:	600e      	str	r6, [r1, #0]
     14e:	7005      	strb	r5, [r0, #0]
     150:	797e      	ldrb	r6, [r7, #5]
     152:	79bc      	ldrb	r4, [r7, #6]
     154:	79fd      	ldrb	r5, [r7, #7]
     156:	7003      	strb	r3, [r0, #0]
     158:	1c33      	adds	r3, r6, #0
     15a:	4646      	mov	r6, r8
     15c:	42be      	cmp	r6, r7
     15e:	d1dd      	bne.n	11c <blit_proc+0x48>
     160:	bc38      	pop	{r3, r4, r5}
     162:	462f      	mov	r7, r5
     164:	4698      	mov	r8, r3
     166:	46a1      	mov	r9, r4
				".syntax divided\n"
				:
				: [spi] "r" (spi),[pal] "r" (pal),[pixels] "r" (pixels),[lum] "r" (lum),[count] "r" (count)
				: "r0","r1","r2","r3","r4","r5","r6"
			);
	*lum = 0x0;
     168:	2300      	movs	r3, #0
     16a:	465a      	mov	r2, fp
     16c:	6013      	str	r3, [r2, #0]
}
     16e:	bc3c      	pop	{r2, r3, r4, r5}
     170:	4690      	mov	r8, r2
     172:	4699      	mov	r9, r3
     174:	46a2      	mov	sl, r4
     176:	46ab      	mov	fp, r5
     178:	bd70      	pop	{r4, r5, r6, pc}
            } else {
              SystemCoreClock = __IRC_OSC_CLK * ((LPC_SYSCON->SYSPLLCTRL & 0x01F) + 1);
            }
            break;
          case 1:                       /* System oscillator                  */
            if (LPC_SYSCON->SYSPLLCTRL & 0x180) {
     17a:	46c0      	nop			(mov r8, r8)

0000017c <VideoOutLine>:
              SystemCoreClock = __SYS_OSC_CLK;
     17c:	4b01      	ldr	r3, [pc, #4]	(184 <VideoOutLine+0x8>)
     17e:	6858      	ldr	r0, [r3, #4]
     180:	4770      	bx	lr
     182:	46c0      	nop			(mov r8, r8)
            } else {
              SystemCoreClock = __SYS_OSC_CLK * ((LPC_SYSCON->SYSPLLCTRL & 0x01F) + 1);
     184:	10001650 	.word	0x10001650

00000188 <VideoOutEnqueueLine>:
     188:	b500      	push	{lr}
     18a:	490a      	ldr	r1, [pc, #40]	(1b4 <VideoOutEnqueueLine+0x2c>)
     18c:	690b      	ldr	r3, [r1, #16]
     18e:	694a      	ldr	r2, [r1, #20]
     190:	1a9b      	subs	r3, r3, r2
     192:	2b08      	cmp	r3, #8
     194:	d105      	bne.n	1a2 <VideoOutEnqueueLine+0x1a>
     196:	bf30      	wfi
            }
            break;
          case 2:                       /* WDT Oscillator                     */
            if (LPC_SYSCON->SYSPLLCTRL & 0x180) {
     198:	690b      	ldr	r3, [r1, #16]
     19a:	694a      	ldr	r2, [r1, #20]
     19c:	1a9b      	subs	r3, r3, r2
     19e:	2b08      	cmp	r3, #8
     1a0:	d0f9      	beq.n	196 <VideoOutEnqueueLine+0xe>
     1a2:	690a      	ldr	r2, [r1, #16]
     1a4:	2307      	movs	r3, #7
              SystemCoreClock = wdt_osc;
     1a6:	4013      	ands	r3, r2
     1a8:	3306      	adds	r3, #6
     1aa:	009b      	lsls	r3, r3, #2
     1ac:	3201      	adds	r2, #1
            } else {
              SystemCoreClock = wdt_osc * ((LPC_SYSCON->SYSPLLCTRL & 0x01F) + 1);
     1ae:	50c8      	str	r0, [r1, r3]
     1b0:	610a      	str	r2, [r1, #16]
     1b2:	bd00      	pop	{pc}
     1b4:	10001650 	.word	0x10001650

000001b8 <ReadXY>:
     1b8:	b530      	push	{r4, r5, lr}
     1ba:	1c0d      	adds	r5, r1, #0
     1bc:	2280      	movs	r2, #128
     1be:	21a0      	movs	r1, #160
     1c0:	05c9      	lsls	r1, r1, #23
            }
            break;
          case 3:                       /* Reserved                           */
            SystemCoreClock = 0;
     1c2:	0212      	lsls	r2, r2, #8
     1c4:	588b      	ldr	r3, [r1, r2]
     1c6:	1c04      	adds	r4, r0, #0
            break;
      }
      break;
  }

  SystemCoreClock /= LPC_SYSCON->SYSAHBCLKDIV;  
     1c8:	2004      	movs	r0, #4
     1ca:	4303      	orrs	r3, r0
     1cc:	508b      	str	r3, [r1, r2]
     1ce:	4a2f      	ldr	r2, [pc, #188]	(28c <ReadXY+0xd4>)
     1d0:	588b      	ldr	r3, [r1, r2]
     1d2:	4303      	orrs	r3, r0
     1d4:	508b      	str	r3, [r1, r2]
     1d6:	4a2e      	ldr	r2, [pc, #184]	(290 <ReadXY+0xd8>)
     1d8:	492e      	ldr	r1, [pc, #184]	(294 <ReadXY+0xdc>)
     1da:	2302      	movs	r3, #2
     1dc:	6753      	str	r3, [r2, #116]
     1de:	6793      	str	r3, [r2, #120]

}
     1e0:	680b      	ldr	r3, [r1, #0]
     1e2:	22ff      	movs	r2, #255
     1e4:	4393      	bics	r3, r2
     1e6:	600b      	str	r3, [r1, #0]
     1e8:	680b      	ldr	r3, [r1, #0]
     1ea:	4a2b      	ldr	r2, [pc, #172]	(298 <ReadXY+0xe0>)
     1ec:	4313      	orrs	r3, r2
     1ee:	600b      	str	r3, [r1, #0]
     1f0:	4b2a      	ldr	r3, [pc, #168]	(29c <ReadXY+0xe4>)
     1f2:	6818      	ldr	r0, [r3, #0]
     1f4:	2800      	cmp	r0, #0
     1f6:	dafc      	bge.n	1f2 <ReadXY+0x3a>
     1f8:	4926      	ldr	r1, [pc, #152]	(294 <ReadXY+0xdc>)
     1fa:	4a29      	ldr	r2, [pc, #164]	(2a0 <ReadXY+0xe8>)
     1fc:	680b      	ldr	r3, [r1, #0]
     1fe:	4013      	ands	r3, r2
     200:	600b      	str	r3, [r1, #0]
     202:	0403      	lsls	r3, r0, #16
     204:	0d9b      	lsrs	r3, r3, #22
     206:	6023      	str	r3, [r4, #0]
     208:	680b      	ldr	r3, [r1, #0]
     20a:	22ff      	movs	r2, #255
     20c:	4393      	bics	r3, r2
     20e:	600b      	str	r3, [r1, #0]
     210:	680b      	ldr	r3, [r1, #0]
     212:	4a24      	ldr	r2, [pc, #144]	(2a4 <ReadXY+0xec>)
     214:	4313      	orrs	r3, r2
     216:	600b      	str	r3, [r1, #0]
     218:	4b23      	ldr	r3, [pc, #140]	(2a8 <ReadXY+0xf0>)
     21a:	6818      	ldr	r0, [r3, #0]
     21c:	2800      	cmp	r0, #0
     21e:	dafc      	bge.n	21a <ReadXY+0x62>
     220:	491c      	ldr	r1, [pc, #112]	(294 <ReadXY+0xdc>)
     222:	4a1f      	ldr	r2, [pc, #124]	(2a0 <ReadXY+0xe8>)
     224:	680b      	ldr	r3, [r1, #0]
     226:	4013      	ands	r3, r2
     228:	600b      	str	r3, [r1, #0]
     22a:	0403      	lsls	r3, r0, #16
     22c:	0d9b      	lsrs	r3, r3, #22
     22e:	602b      	str	r3, [r5, #0]
     230:	6822      	ldr	r2, [r4, #0]
     232:	4b1e      	ldr	r3, [pc, #120]	(2ac <ReadXY+0xf4>)
     234:	20a0      	movs	r0, #160
     236:	601a      	str	r2, [r3, #0]
	JOY_Y = 2;
	JOY_X = 2;
	*x = ADCRead(0);
	*y = ADCRead(1);
	_lastx = *x;
	_lasty = *y;
     238:	682a      	ldr	r2, [r5, #0]
     23a:	4b1d      	ldr	r3, [pc, #116]	(2b0 <ReadXY+0xf8>)
	LPC_GPIO0->DIR &= ~4;	//	Release Joystick
     23c:	05c0      	lsls	r0, r0, #23
	JOY_Y = 2;
	JOY_X = 2;
	*x = ADCRead(0);
	*y = ADCRead(1);
	_lastx = *x;
	_lasty = *y;
     23e:	601a      	str	r2, [r3, #0]
	LPC_GPIO0->DIR &= ~4;	//	Release Joystick
     240:	2280      	movs	r2, #128
     242:	0212      	lsls	r2, r2, #8
     244:	5883      	ldr	r3, [r0, r2]
     246:	2104      	movs	r1, #4
     248:	438b      	bics	r3, r1
     24a:	5083      	str	r3, [r0, r2]
u8 _keyState = 1;
u8 _keyDown = 0;
void Debounce(u8 kin)
{
	static u8 ct0, ct1;
	uint8_t i = _keyState ^ kin;
     24c:	4d19      	ldr	r5, [pc, #100]	(2b4 <ReadXY+0xfc>)
	*x = ADCRead(0);
	*y = ADCRead(1);
	_lastx = *x;
	_lasty = *y;
	LPC_GPIO0->DIR &= ~4;	//	Release Joystick
	Debounce(LPC_GPIO1->DATA & (1<<4));
     24e:	4b1a      	ldr	r3, [pc, #104]	(2b8 <ReadXY+0x100>)
     250:	4a0e      	ldr	r2, [pc, #56]	(28c <ReadXY+0xd4>)
u8 _keyDown = 0;
void Debounce(u8 kin)
{
	static u8 ct0, ct1;
	uint8_t i = _keyState ^ kin;
	ct0 = ~(ct0 & i);
     252:	491a      	ldr	r1, [pc, #104]	(2bc <ReadXY+0x104>)
	*x = ADCRead(0);
	*y = ADCRead(1);
	_lastx = *x;
	_lasty = *y;
	LPC_GPIO0->DIR &= ~4;	//	Release Joystick
	Debounce(LPC_GPIO1->DATA & (1<<4));
     254:	589a      	ldr	r2, [r3, r2]
u8 _keyState = 1;
u8 _keyDown = 0;
void Debounce(u8 kin)
{
	static u8 ct0, ct1;
	uint8_t i = _keyState ^ kin;
     256:	782c      	ldrb	r4, [r5, #0]
     258:	2310      	movs	r3, #16
     25a:	401a      	ands	r2, r3
     25c:	1c20      	adds	r0, r4, #0
	ct0 = ~(ct0 & i);
     25e:	790b      	ldrb	r3, [r1, #4]
u8 _keyState = 1;
u8 _keyDown = 0;
void Debounce(u8 kin)
{
	static u8 ct0, ct1;
	uint8_t i = _keyState ^ kin;
     260:	4050      	eors	r0, r2
	ct0 = ~(ct0 & i);
     262:	4003      	ands	r3, r0
	ct1 = ct0 ^ (ct1 & i);
     264:	794a      	ldrb	r2, [r1, #5]
u8 _keyDown = 0;
void Debounce(u8 kin)
{
	static u8 ct0, ct1;
	uint8_t i = _keyState ^ kin;
	ct0 = ~(ct0 & i);
     266:	43db      	mvns	r3, r3
     268:	b2db      	uxtb	r3, r3
	ct1 = ct0 ^ (ct1 & i);
     26a:	4002      	ands	r2, r0
     26c:	405a      	eors	r2, r3
u8 _keyDown = 0;
void Debounce(u8 kin)
{
	static u8 ct0, ct1;
	uint8_t i = _keyState ^ kin;
	ct0 = ~(ct0 & i);
     26e:	710b      	strb	r3, [r1, #4]
	ct1 = ct0 ^ (ct1 & i);
	i &= ct0 & ct1;
     270:	4003      	ands	r3, r0
     272:	4013      	ands	r3, r2
void Debounce(u8 kin)
{
	static u8 ct0, ct1;
	uint8_t i = _keyState ^ kin;
	ct0 = ~(ct0 & i);
	ct1 = ct0 ^ (ct1 & i);
     274:	714a      	strb	r2, [r1, #5]
	i &= ct0 & ct1;
	_keyState ^= i;
     276:	1c1a      	adds	r2, r3, #0
     278:	4062      	eors	r2, r4
	_keyDown = _keyState & i;
     27a:	1c10      	adds	r0, r2, #0
     27c:	4018      	ands	r0, r3
     27e:	7188      	strb	r0, [r1, #6]
     280:	1e43      	subs	r3, r0, #1
     282:	4198      	sbcs	r0, r3
	static u8 ct0, ct1;
	uint8_t i = _keyState ^ kin;
	ct0 = ~(ct0 & i);
	ct1 = ct0 ^ (ct1 & i);
	i &= ct0 & ct1;
	_keyState ^= i;
     284:	702a      	strb	r2, [r5, #0]
	_keyDown = _keyState & i;
     286:	4310      	orrs	r0, r2
	_lastx = *x;
	_lasty = *y;
	LPC_GPIO0->DIR &= ~4;	//	Release Joystick
	Debounce(LPC_GPIO1->DATA & (1<<4));
	return _keyState | (_keyDown ? 1 : 0);
}
     288:	bd30      	pop	{r4, r5, pc}
     28a:	46c0      	nop			(mov r8, r8)
     28c:	00003ffc 	.word	0x00003ffc
     290:	40044000 	.word	0x40044000
     294:	4001c000 	.word	0x4001c000
     298:	01000001 	.word	0x01000001
     29c:	4001c010 	.word	0x4001c010
     2a0:	f8ffffff 	.word	0xf8ffffff
     2a4:	01000002 	.word	0x01000002
     2a8:	4001c014 	.word	0x4001c014
     2ac:	1000164c 	.word	0x1000164c
     2b0:	10000488 	.word	0x10000488
     2b4:	10000000 	.word	0x10000000
     2b8:	50010000 	.word	0x50010000
     2bc:	10000470 	.word	0x10000470

000002c0 <CheckSleep>:

int _lastKey = 0;
void CheckSleep()
{
     2c0:	b500      	push	{lr}
	if (!_keyState)
     2c2:	4b0c      	ldr	r3, [pc, #48]	(2f4 <CheckSleep+0x34>)
     2c4:	781b      	ldrb	r3, [r3, #0]
     2c6:	2b00      	cmp	r3, #0
     2c8:	d010      	beq.n	2ec <CheckSleep+0x2c>
     2ca:	4a0b      	ldr	r2, [pc, #44]	(2f8 <CheckSleep+0x38>)
		_lastKey = _vbl;

	if (_vbl - _lastKey > 3*60*60)	// power off after 3 minutes
     2cc:	6813      	ldr	r3, [r2, #0]
     2ce:	6892      	ldr	r2, [r2, #8]
     2d0:	1a9b      	subs	r3, r3, r2
     2d2:	4a0a      	ldr	r2, [pc, #40]	(2fc <CheckSleep+0x3c>)
     2d4:	4293      	cmp	r3, r2
     2d6:	dd08      	ble.n	2ea <CheckSleep+0x2a>
	{
		 SCB->SCR |= 4;
     2d8:	4909      	ldr	r1, [pc, #36]	(300 <CheckSleep+0x40>)
     2da:	2204      	movs	r2, #4
     2dc:	690b      	ldr	r3, [r1, #16]
     2de:	4313      	orrs	r3, r2
     2e0:	610b      	str	r3, [r1, #16]
		 LPC_PMU->PCON = 2;
     2e2:	4b08      	ldr	r3, [pc, #32]	(304 <CheckSleep+0x44>)
     2e4:	2202      	movs	r2, #2
     2e6:	601a      	str	r2, [r3, #0]
		__asm volatile ("WFI");	// power off
     2e8:	bf30      	wfi
	}
}
     2ea:	bd00      	pop	{pc}

int _lastKey = 0;
void CheckSleep()
{
	if (!_keyState)
		_lastKey = _vbl;
     2ec:	4a02      	ldr	r2, [pc, #8]	(2f8 <CheckSleep+0x38>)
     2ee:	6813      	ldr	r3, [r2, #0]
     2f0:	6093      	str	r3, [r2, #8]
     2f2:	e7eb      	b.n	2cc <CheckSleep+0xc>
     2f4:	10000000 	.word	0x10000000
     2f8:	10000470 	.word	0x10000470
     2fc:	00002a30 	.word	0x00002a30
     300:	e000ed00 	.word	0xe000ed00
     304:	40038000 	.word	0x40038000

00000308 <SysTick_Handler>:

u8 MusicSample();	// In Music.h

//	Called at start of HSYNC
void SysTick_Handler(void)
{
     308:	b570      	push	{r4, r5, r6, lr}
//	Timing Critical region 2
//	Less critical than active video, should not alter chroma phases

void StartLine(ScreenState* s)
{
	*SYNC = 0;							// Start sync
     30a:	4b3d      	ldr	r3, [pc, #244]	(400 <SysTick_Handler+0xf8>)
	s->Line += 1;
     30c:	4d3d      	ldr	r5, [pc, #244]	(404 <SysTick_Handler+0xfc>)
//	Timing Critical region 2
//	Less critical than active video, should not alter chroma phases

void StartLine(ScreenState* s)
{
	*SYNC = 0;							// Start sync
     30e:	2200      	movs	r2, #0
     310:	601a      	str	r2, [r3, #0]
	s->Line += 1;
     312:	686b      	ldr	r3, [r5, #4]
     314:	3301      	adds	r3, #1
     316:	606b      	str	r3, [r5, #4]
	int line = s->Line;
     318:	6869      	ldr	r1, [r5, #4]
	if (line == 262)
     31a:	2383      	movs	r3, #131
     31c:	005b      	lsls	r3, r3, #1
     31e:	4299      	cmp	r1, r3
     320:	d040      	beq.n	3a4 <SysTick_Handler+0x9c>
	{
		line = s->Line = 0;
		_vbl++;
	}
	else if (line >= 9)
     322:	2908      	cmp	r1, #8
     324:	dc37      	bgt.n	396 <SysTick_Handler+0x8e>
	{
		ComeBackIn(256);	// HSYNC
		return;
	}
	//	vertical blanking
	s->Pulse = (line >= 3 && line < 6) ? 0 : 4;
     326:	1ecb      	subs	r3, r1, #3
     328:	2b02      	cmp	r3, #2
     32a:	d932      	bls.n	392 <SysTick_Handler+0x8a>
     32c:	2304      	movs	r3, #4
	LPC_TMR16B0->TC = 0;
     32e:	4836      	ldr	r0, [pc, #216]	(408 <SysTick_Handler+0x100>)
     330:	2400      	movs	r4, #0
	{
		ComeBackIn(256);	// HSYNC
		return;
	}
	//	vertical blanking
	s->Pulse = (line >= 3 && line < 6) ? 0 : 4;
     332:	60eb      	str	r3, [r5, #12]
	LPC_TMR16B0->TC = 0;
     334:	6084      	str	r4, [r0, #8]
	ComeBackIn(_pulses[s->Pulse++]);
     336:	68eb      	ldr	r3, [r5, #12]
     338:	4934      	ldr	r1, [pc, #208]	(40c <SysTick_Handler+0x104>)
     33a:	005a      	lsls	r2, r3, #1
     33c:	5e52      	ldrsh	r2, [r2, r1]
     33e:	3301      	adds	r3, #1
     340:	60eb      	str	r3, [r5, #12]
}

void ComeBackIn(int count)
{
	LPC_TMR16B0->TC = 0;
	LPC_TMR16B0->MR0 = count>>1;
     342:	1052      	asrs	r2, r2, #1
	LPC_TMR16B0->TCR = 1;
     344:	2301      	movs	r3, #1
	return b-a;
}

void ComeBackIn(int count)
{
	LPC_TMR16B0->TC = 0;
     346:	6084      	str	r4, [r0, #8]
	LPC_TMR16B0->MR0 = count>>1;
     348:	6182      	str	r2, [r0, #24]
	LPC_TMR16B0->TCR = 1;
     34a:	6043      	str	r3, [r0, #4]
	s->Duration = 1;
}

u8 MusicSample(MusicState* s)
{
	if (!s->Duration)
     34c:	2393      	movs	r3, #147
     34e:	009b      	lsls	r3, r3, #2
     350:	58ea      	ldr	r2, [r5, r3]
     352:	2a00      	cmp	r2, #0
     354:	d017      	beq.n	386 <SysTick_Handler+0x7e>
		return 0;			// not playing

	//	new note
	if (s->Duration == 1)
     356:	2a01      	cmp	r2, #1
     358:	d02e      	beq.n	3b8 <SysTick_Handler+0xb0>
		s->WaveStep = _waveSampleRates[n & 0x3F];
		n >>= 6;
		s->Duration = s->Duration16th << n;
	}

	s->Duration--;
     35a:	2393      	movs	r3, #147
     35c:	009b      	lsls	r3, r3, #2
     35e:	3a01      	subs	r2, #1
     360:	50ea      	str	r2, [r5, r3]
	s->WaveMark += s->WaveStep;
     362:	2391      	movs	r3, #145
     364:	2290      	movs	r2, #144
     366:	0092      	lsls	r2, r2, #2
     368:	009b      	lsls	r3, r3, #2
     36a:	58a9      	ldr	r1, [r5, r2]
     36c:	58eb      	ldr	r3, [r5, r3]
     36e:	185b      	adds	r3, r3, r1
     370:	50ab      	str	r3, [r5, r2]
     372:	4a27      	ldr	r2, [pc, #156]	(410 <SysTick_Handler+0x108>)
     374:	121b      	asrs	r3, r3, #8
     376:	b2db      	uxtb	r3, r3
     378:	18d2      	adds	r2, r2, r3
     37a:	7b12      	ldrb	r2, [r2, #12]
     37c:	00d3      	lsls	r3, r2, #3
     37e:	1a9b      	subs	r3, r3, r2
     380:	00db      	lsls	r3, r3, #3
     382:	189b      	adds	r3, r3, r2
     384:	10da      	asrs	r2, r3, #3
{
	//STATE |= 4;
	StartLine(&gScreen);
#if 1
	int n = MusicSample(&gScreen.Music);
	LPC_TMR16B1->MR0 = (n*57)>>3;	// 8 bit pcm
     386:	4b23      	ldr	r3, [pc, #140]	(414 <SysTick_Handler+0x10c>)
     388:	619a      	str	r2, [r3, #24]
	LPC_TMR16B1->MR1 = (n*57)>>3;
     38a:	61da      	str	r2, [r3, #28]
	LPC_TMR16B1->TC = 0;
     38c:	2200      	movs	r2, #0
     38e:	609a      	str	r2, [r3, #8]
#endif
}
     390:	bd70      	pop	{r4, r5, r6, pc}
	{
		ComeBackIn(256);	// HSYNC
		return;
	}
	//	vertical blanking
	s->Pulse = (line >= 3 && line < 6) ? 0 : 4;
     392:	2300      	movs	r3, #0
     394:	e7cb      	b.n	32e <SysTick_Handler+0x26>
	return b-a;
}

void ComeBackIn(int count)
{
	LPC_TMR16B0->TC = 0;
     396:	4b1c      	ldr	r3, [pc, #112]	(408 <SysTick_Handler+0x100>)
     398:	609a      	str	r2, [r3, #8]
	LPC_TMR16B0->MR0 = count>>1;
     39a:	2280      	movs	r2, #128
     39c:	619a      	str	r2, [r3, #24]
	LPC_TMR16B0->TCR = 1;
     39e:	2201      	movs	r2, #1
     3a0:	605a      	str	r2, [r3, #4]
     3a2:	e7d3      	b.n	34c <SysTick_Handler+0x44>
	*SYNC = 0;							// Start sync
	s->Line += 1;
	int line = s->Line;
	if (line == 262)
	{
		line = s->Line = 0;
     3a4:	606a      	str	r2, [r5, #4]
		_vbl++;
     3a6:	4a1c      	ldr	r2, [pc, #112]	(418 <SysTick_Handler+0x110>)
	*SYNC = 0;							// Start sync
	s->Line += 1;
	int line = s->Line;
	if (line == 262)
	{
		line = s->Line = 0;
     3a8:	6869      	ldr	r1, [r5, #4]
		_vbl++;
     3aa:	6813      	ldr	r3, [r2, #0]
     3ac:	3301      	adds	r3, #1
     3ae:	6013      	str	r3, [r2, #0]
	{
		ComeBackIn(256);	// HSYNC
		return;
	}
	//	vertical blanking
	s->Pulse = (line >= 3 && line < 6) ? 0 : 4;
     3b0:	1ecb      	subs	r3, r1, #3
     3b2:	2b02      	cmp	r3, #2
     3b4:	d9ed      	bls.n	392 <SysTick_Handler+0x8a>
     3b6:	e7b9      	b.n	32c <SysTick_Handler+0x24>
		return 0;			// not playing

	//	new note
	if (s->Duration == 1)
	{
		if (!s->TrackMark[0])
     3b8:	218f      	movs	r1, #143
     3ba:	0089      	lsls	r1, r1, #2
     3bc:	586a      	ldr	r2, [r5, r1]
     3be:	7810      	ldrb	r0, [r2, #0]
     3c0:	2800      	cmp	r0, #0
     3c2:	d104      	bne.n	3ce <SysTick_Handler+0xc6>
			s->TrackMark = s->Track;
     3c4:	238e      	movs	r3, #142
     3c6:	009b      	lsls	r3, r3, #2
     3c8:	58ea      	ldr	r2, [r5, r3]
     3ca:	506a      	str	r2, [r5, r1]
     3cc:	7810      	ldrb	r0, [r2, #0]
		u8 n = *s->TrackMark++;
     3ce:	238f      	movs	r3, #143
     3d0:	009b      	lsls	r3, r3, #2
     3d2:	3201      	adds	r2, #1
     3d4:	50ea      	str	r2, [r5, r3]
		s->WaveMark = 0;
     3d6:	2390      	movs	r3, #144
     3d8:	009b      	lsls	r3, r3, #2
     3da:	2200      	movs	r2, #0
     3dc:	50ea      	str	r2, [r5, r3]
		s->WaveStep = _waveSampleRates[n & 0x3F];
     3de:	233f      	movs	r3, #63
     3e0:	4a0a      	ldr	r2, [pc, #40]	(40c <SysTick_Handler+0x104>)
     3e2:	4003      	ands	r3, r0
     3e4:	005b      	lsls	r3, r3, #1
     3e6:	18d2      	adds	r2, r2, r3
     3e8:	8a13      	ldrh	r3, [r2, #16]
     3ea:	2191      	movs	r1, #145
     3ec:	0089      	lsls	r1, r1, #2
     3ee:	506b      	str	r3, [r5, r1]
		n >>= 6;
		s->Duration = s->Duration16th << n;
     3f0:	2392      	movs	r3, #146
     3f2:	009b      	lsls	r3, r3, #2
     3f4:	58eb      	ldr	r3, [r5, r3]
     3f6:	0982      	lsrs	r2, r0, #6
     3f8:	4093      	lsls	r3, r2
     3fa:	1c1a      	adds	r2, r3, #0
     3fc:	e7ad      	b.n	35a <SysTick_Handler+0x52>
     3fe:	46c0      	nop			(mov r8, r8)
     400:	50010008 	.word	0x50010008
     404:	10001650 	.word	0x10001650
     408:	4000c000 	.word	0x4000c000
     40c:	0000301c 	.word	0x0000301c
     410:	0000309c 	.word	0x0000309c
     414:	40010000 	.word	0x40010000
     418:	10000470 	.word	0x10000470

0000041c <VideoOutInit>:
		__asm volatile ("WFI");	// power off
	}
}

void VideoOutInit(int width)
{
     41c:	b5f0      	push	{r4, r5, r6, r7, lr}
     41e:	465f      	mov	r7, fp
     420:	4656      	mov	r6, sl
     422:	464d      	mov	r5, r9
     424:	4644      	mov	r4, r8
     426:	b4f0      	push	{r4, r5, r6, r7}
	// port 2 d4-d7 luminance out
	LPC_GPIO0->DIR = 0x2;
     428:	23a0      	movs	r3, #160
     42a:	2280      	movs	r2, #128
     42c:	0212      	lsls	r2, r2, #8
     42e:	2402      	movs	r4, #2
     430:	05db      	lsls	r3, r3, #23
     432:	509c      	str	r4, [r3, r2]
	LPC_GPIO0->DIR = 0x2;	// NOP! for color phase!
     434:	509c      	str	r4, [r3, r2]
	LPC_IOCON->PIO0_1 = 1;	// clock out
     436:	4b6b      	ldr	r3, [pc, #428]	(5e4 <VideoOutInit+0x1c8>)
     438:	2601      	movs	r6, #1
     43a:	611e      	str	r6, [r3, #16]
     43c:	469c      	mov	ip, r3
	LPC_GPIO2->DIR = 0xFF;	// ouy
     43e:	4b6a      	ldr	r3, [pc, #424]	(5e8 <VideoOutInit+0x1cc>)
     440:	21ff      	movs	r1, #255
     442:	5099      	str	r1, [r3, r2]
	LPC_GPIO3->DIR = 0x7;
     444:	4969      	ldr	r1, [pc, #420]	(5ec <VideoOutInit+0x1d0>)
	STATE = 0;
     446:	2500      	movs	r5, #0
	// port 2 d4-d7 luminance out
	LPC_GPIO0->DIR = 0x2;
	LPC_GPIO0->DIR = 0x2;	// NOP! for color phase!
	LPC_IOCON->PIO0_1 = 1;	// clock out
	LPC_GPIO2->DIR = 0xFF;	// ouy
	LPC_GPIO3->DIR = 0x7;
     448:	2307      	movs	r3, #7
     44a:	508b      	str	r3, [r1, r2]
	STATE = 0;
     44c:	61cd      	str	r5, [r1, #28]

	LPC_GPIO1->DIR |= 0x2;	// sync
     44e:	4968      	ldr	r1, [pc, #416]	(5f0 <VideoOutInit+0x1d4>)
	LPC_SYSCON->CLKOUTCLKSEL = 3;
	LPC_SYSCON->CLKOUTUEN = 0;
	LPC_SYSCON->CLKOUTUEN = 1;
	LPC_SYSCON->CLKOUTDIV = 1;

	gScreen.Width = width;
     450:	4f68      	ldr	r7, [pc, #416]	(5f4 <VideoOutInit+0x1d8>)
	LPC_IOCON->PIO0_1 = 1;	// clock out
	LPC_GPIO2->DIR = 0xFF;	// ouy
	LPC_GPIO3->DIR = 0x7;
	STATE = 0;

	LPC_GPIO1->DIR |= 0x2;	// sync
     452:	588b      	ldr	r3, [r1, r2]
		__asm volatile ("WFI");	// power off
	}
}

void VideoOutInit(int width)
{
     454:	b083      	sub	sp, #12
	LPC_IOCON->PIO0_1 = 1;	// clock out
	LPC_GPIO2->DIR = 0xFF;	// ouy
	LPC_GPIO3->DIR = 0x7;
	STATE = 0;

	LPC_GPIO1->DIR |= 0x2;	// sync
     456:	4323      	orrs	r3, r4
     458:	508b      	str	r3, [r1, r2]
	LPC_IOCON->R_PIO1_1= 1;

	LPC_SYSCON->CLKOUTCLKSEL = 3;
     45a:	4a67      	ldr	r2, [pc, #412]	(5f8 <VideoOutInit+0x1dc>)
	LPC_GPIO2->DIR = 0xFF;	// ouy
	LPC_GPIO3->DIR = 0x7;
	STATE = 0;

	LPC_GPIO1->DIR |= 0x2;	// sync
	LPC_IOCON->R_PIO1_1= 1;
     45c:	4664      	mov	r4, ip

	LPC_SYSCON->CLKOUTCLKSEL = 3;
     45e:	2103      	movs	r1, #3
     460:	23e0      	movs	r3, #224
	LPC_GPIO2->DIR = 0xFF;	// ouy
	LPC_GPIO3->DIR = 0x7;
	STATE = 0;

	LPC_GPIO1->DIR |= 0x2;	// sync
	LPC_IOCON->R_PIO1_1= 1;
     462:	67e6      	str	r6, [r4, #124]

	LPC_SYSCON->CLKOUTCLKSEL = 3;
     464:	50d1      	str	r1, [r2, r3]
	LPC_SYSCON->CLKOUTUEN = 0;
     466:	23e4      	movs	r3, #228
     468:	50d5      	str	r5, [r2, r3]
	LPC_SYSCON->CLKOUTUEN = 1;
     46a:	50d6      	str	r6, [r2, r3]
	LPC_SYSCON->CLKOUTDIV = 1;
     46c:	23e8      	movs	r3, #232
     46e:	50d6      	str	r6, [r2, r3]

	gScreen.Width = width;
     470:	60b8      	str	r0, [r7, #8]
}

void InitScreen(ScreenState* s)
{
	int b;
	s->Write = s->Read = 0;
     472:	617d      	str	r5, [r7, #20]
     474:	697b      	ldr	r3, [r7, #20]
     476:	4e61      	ldr	r6, [pc, #388]	(5fc <VideoOutInit+0x1e0>)
     478:	613b      	str	r3, [r7, #16]
	s->Width = 256;
     47a:	2380      	movs	r3, #128
     47c:	005b      	lsls	r3, r3, #1
	//	red
	//	pink
	//	purple
	//	blue

	uint8_t _map[8] = { 0x00,0xC1,0xE0,0x70,0x38,0x1C,0x0E,0x07 };	// 3 bit default 0x83->0x00 for BW
     47e:	1c30      	adds	r0, r6, #0
	return _map[b];
     480:	2207      	movs	r2, #7

void InitScreen(ScreenState* s)
{
	int b;
	s->Write = s->Read = 0;
	s->Width = 256;
     482:	60bb      	str	r3, [r7, #8]
     484:	4669      	mov	r1, sp
     486:	46b2      	mov	sl, r6
	//	red
	//	pink
	//	purple
	//	blue

	uint8_t _map[8] = { 0x00,0xC1,0xE0,0x70,0x38,0x1C,0x0E,0x07 };	// 3 bit default 0x83->0x00 for BW
     488:	300c      	adds	r0, #12
	return _map[b];
     48a:	4694      	mov	ip, r2
	int b;
	s->Write = s->Read = 0;
	s->Width = 256;

	for (b = 0; b < 256; b++)
		s->pal[b] = chroma_palette(b);
     48c:	46bb      	mov	fp, r7
{
	int b;
	s->Write = s->Read = 0;
	s->Width = 256;

	for (b = 0; b < 256; b++)
     48e:	4699      	mov	r9, r3
	//	red
	//	pink
	//	purple
	//	blue

	uint8_t _map[8] = { 0x00,0xC1,0xE0,0x70,0x38,0x1C,0x0E,0x07 };	// 3 bit default 0x83->0x00 for BW
     490:	1c0b      	adds	r3, r1, #0
     492:	1c02      	adds	r2, r0, #0
     494:	ca50      	ldmia	r2!, {r4, r6}
     496:	c350      	stmia	r3!, {r4, r6}
	return _map[b];
     498:	4663      	mov	r3, ip
     49a:	402b      	ands	r3, r5
     49c:	2207      	movs	r2, #7
     49e:	4690      	mov	r8, r2
     4a0:	5cca      	ldrb	r2, [r1, r3]
	int b;
	s->Write = s->Read = 0;
	s->Width = 256;

	for (b = 0; b < 256; b++)
		s->pal[b] = chroma_palette(b);
     4a2:	197b      	adds	r3, r7, r5
     4a4:	3338      	adds	r3, #56
{
	int b;
	s->Write = s->Read = 0;
	s->Width = 256;

	for (b = 0; b < 256; b++)
     4a6:	3501      	adds	r5, #1
		s->pal[b] = chroma_palette(b);
     4a8:	701a      	strb	r2, [r3, #0]
{
	int b;
	s->Write = s->Read = 0;
	s->Width = 256;

	for (b = 0; b < 256; b++)
     4aa:	454d      	cmp	r5, r9
     4ac:	d1f0      	bne.n	490 <VideoOutInit+0x74>

void SSPInit( void )
{
  uint8_t i, Dummy;

  LPC_SYSCON->PRESETCTRL |= (0x1<<0);
     4ae:	4e52      	ldr	r6, [pc, #328]	(5f8 <VideoOutInit+0x1dc>)
     4b0:	2401      	movs	r4, #1
     4b2:	6873      	ldr	r3, [r6, #4]
  LPC_SYSCON->SYSAHBCLKCTRL |= (1<<11);
     4b4:	2180      	movs	r1, #128

void SSPInit( void )
{
  uint8_t i, Dummy;

  LPC_SYSCON->PRESETCTRL |= (0x1<<0);
     4b6:	4323      	orrs	r3, r4
     4b8:	6073      	str	r3, [r6, #4]
  LPC_SYSCON->SYSAHBCLKCTRL |= (1<<11);
     4ba:	5872      	ldr	r2, [r6, r1]
     4bc:	2380      	movs	r3, #128
     4be:	011b      	lsls	r3, r3, #4
     4c0:	431a      	orrs	r2, r3
     4c2:	5072      	str	r2, [r6, r1]
  LPC_SYSCON->SYSTICKCLKDIV  = 0x02;			/* Divided by 2 */
     4c4:	23b0      	movs	r3, #176
  LPC_IOCON->PIO0_8 &= ~0x07;	/*  SSP I/O config */
     4c6:	4a47      	ldr	r2, [pc, #284]	(5e4 <VideoOutInit+0x1c8>)
{
  uint8_t i, Dummy;

  LPC_SYSCON->PRESETCTRL |= (0x1<<0);
  LPC_SYSCON->SYSAHBCLKCTRL |= (1<<11);
  LPC_SYSCON->SYSTICKCLKDIV  = 0x02;			/* Divided by 2 */
     4c8:	2102      	movs	r1, #2
     4ca:	50f1      	str	r1, [r6, r3]
     4cc:	4699      	mov	r9, r3
  LPC_IOCON->PIO0_8 &= ~0x07;	/*  SSP I/O config */
     4ce:	6e13      	ldr	r3, [r2, #96]
     4d0:	4640      	mov	r0, r8
     4d2:	4383      	bics	r3, r0
     4d4:	6613      	str	r3, [r2, #96]
  LPC_IOCON->PIO0_8 |= 0x01;	/* SSP MISO */
     4d6:	6e13      	ldr	r3, [r2, #96]
     4d8:	4323      	orrs	r3, r4
     4da:	6613      	str	r3, [r2, #96]
  LPC_IOCON->PIO0_9  &= ~0x07;
     4dc:	6e53      	ldr	r3, [r2, #100]
     4de:	4383      	bics	r3, r0
     4e0:	6653      	str	r3, [r2, #100]
  LPC_IOCON->PIO0_9 |= 0x01;	/* SSP MOSI */
     4e2:	6e53      	ldr	r3, [r2, #100]
     4e4:	4323      	orrs	r3, r4
     4e6:	6653      	str	r3, [r2, #100]

  LPC_IOCON->SCK_LOC = 0x02;
     4e8:	464b      	mov	r3, r9
     4ea:	50d1      	str	r1, [r2, r3]
  LPC_IOCON->PIO0_6 = 0x02;		/* P0.6 function 2 is SSP clock, need to combined with IOCONSCKLOC register setting */
     4ec:	64d1      	str	r1, [r2, #76]

  LPC_IOCON->PIO0_2 &= ~0x07;		/* SSP SSEL is a GPIO pin */
     4ee:	69d3      	ldr	r3, [r2, #28]
     4f0:	4383      	bics	r3, r0
     4f2:	61d3      	str	r3, [r2, #28]

  LPC_SSP0->CR0 = 0x008F;	// 16-bit, 24Mhz CPOL = 0, CPHA = 1
     4f4:	4b42      	ldr	r3, [pc, #264]	(600 <VideoOutInit+0x1e4>)
     4f6:	228f      	movs	r2, #143
     4f8:	601a      	str	r2, [r3, #0]

  /* SSPCPSR clock prescale register, master mode, minimum divisor is 0x02 */
  LPC_SSP0->CPSR = 0x2;
     4fa:	6119      	str	r1, [r3, #16]

  for ( i = 0; i < FIFOSIZE; i++ )
	Dummy = LPC_SSP0->DR;		/* clear the RxFIFO */
     4fc:	689a      	ldr	r2, [r3, #8]
     4fe:	689a      	ldr	r2, [r3, #8]
     500:	689a      	ldr	r2, [r3, #8]
     502:	689a      	ldr	r2, [r3, #8]
     504:	689a      	ldr	r2, [r3, #8]
     506:	689a      	ldr	r2, [r3, #8]
     508:	689a      	ldr	r2, [r3, #8]
     50a:	689a      	ldr	r2, [r3, #8]

  /* Master mode */
  LPC_SSP0->CR1 = SSPCR1_SSE;
     50c:	6059      	str	r1, [r3, #4]

	for (b = 0; b < 256; b++)
		s->pal[b] = chroma_palette(b);
	SSPInit();

	memcpy(s->blitprocbuf,(void*)((int)&blit_proc & 0xFFFFFFFE),256);
     50e:	229c      	movs	r2, #156
     510:	493c      	ldr	r1, [pc, #240]	(604 <VideoOutInit+0x1e8>)
     512:	0052      	lsls	r2, r2, #1
     514:	43a1      	bics	r1, r4
     516:	1c10      	adds	r0, r2, #0
	s->blit = (blit_ptr)(((int)s->blitprocbuf) + 1);
     518:	4c3b      	ldr	r4, [pc, #236]	(608 <VideoOutInit+0x1ec>)

	for (b = 0; b < 256; b++)
		s->pal[b] = chroma_palette(b);
	SSPInit();

	memcpy(s->blitprocbuf,(void*)((int)&blit_proc & 0xFFFFFFFE),256);
     51a:	1c2a      	adds	r2, r5, #0
     51c:	4458      	add	r0, fp
     51e:	f002 fccb 	bl	2eb8 <memcpy>
	s->blit = (blit_ptr)(((int)s->blitprocbuf) + 1);
     522:	1c23      	adds	r3, r4, #0
     524:	445b      	add	r3, fp
     526:	603b      	str	r3, [r7, #0]

	s->Line = 0;
	s->Pulse = -1;
     528:	2301      	movs	r3, #1
	SSPInit();

	memcpy(s->blitprocbuf,(void*)((int)&blit_proc & 0xFFFFFFFE),256);
	s->blit = (blit_ptr)(((int)s->blitprocbuf) + 1);

	s->Line = 0;
     52a:	2400      	movs	r4, #0
	s->Pulse = -1;
     52c:	425b      	negs	r3, r3
	SSPInit();

	memcpy(s->blitprocbuf,(void*)((int)&blit_proc & 0xFFFFFFFE),256);
	s->blit = (blit_ptr)(((int)s->blitprocbuf) + 1);

	s->Line = 0;
     52e:	607c      	str	r4, [r7, #4]
 */
static __INLINE uint32_t SysTick_Config(uint32_t ticks)
{ 
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */
                                                               
  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
     530:	4936      	ldr	r1, [pc, #216]	(60c <VideoOutInit+0x1f0>)
	s->Pulse = -1;
     532:	60fb      	str	r3, [r7, #12]
     534:	4b36      	ldr	r3, [pc, #216]	(610 <VideoOutInit+0x1f4>)
 * Note: The priority cannot be set for every core interrupt.
 */
static __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) | 
     536:	4837      	ldr	r0, [pc, #220]	(614 <VideoOutInit+0x1f8>)
 */
static __INLINE uint32_t SysTick_Config(uint32_t ticks)
{ 
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */
                                                               
  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
     538:	604b      	str	r3, [r1, #4]
 * Note: The priority cannot be set for every core interrupt.
 */
static __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) | 
     53a:	6a03      	ldr	r3, [r0, #32]
     53c:	4a36      	ldr	r2, [pc, #216]	(618 <VideoOutInit+0x1fc>)
     53e:	4013      	ands	r3, r2
     540:	4a36      	ldr	r2, [pc, #216]	(61c <VideoOutInit+0x200>)
     542:	4313      	orrs	r3, r2
     544:	6203      	str	r3, [r0, #32]
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */
                                                               
  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Cortex-M0 System Interrupts */
  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk | 
     546:	4640      	mov	r0, r8
{ 
  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */
                                                               
  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Cortex-M0 System Interrupts */
  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
     548:	608c      	str	r4, [r1, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk | 
     54a:	6008      	str	r0, [r1, #0]

	gScreen.Width = width;
	InitScreen(&gScreen);

	SysTick_Config(3648);	// Clock per scanline
	if ( !(SysTick->CTRL & (1<<SysTick_CTRL_CLKSOURCE_Msk)) )
     54c:	680b      	ldr	r3, [r1, #0]
     54e:	06da      	lsls	r2, r3, #27
     550:	d402      	bmi.n	558 <VideoOutInit+0x13c>
		LPC_SYSCON->SYSTICKCLKDIV = 0x08;
     552:	2308      	movs	r3, #8
     554:	464c      	mov	r4, r9
     556:	5133      	str	r3, [r6, r4]
	return chroma_phase(b&7);
}

void InitTimer()
{
    LPC_SYSCON->SYSAHBCLKCTRL |= (1<<7);	// enable TMR16B0
     558:	4927      	ldr	r1, [pc, #156]	(5f8 <VideoOutInit+0x1dc>)
     55a:	2080      	movs	r0, #128
     55c:	580b      	ldr	r3, [r1, r0]
	LPC_TMR16B0->MCR = 7;	//
     55e:	2207      	movs	r2, #7
	return chroma_phase(b&7);
}

void InitTimer()
{
    LPC_SYSCON->SYSAHBCLKCTRL |= (1<<7);	// enable TMR16B0
     560:	4303      	orrs	r3, r0
     562:	500b      	str	r3, [r1, r0]
	LPC_TMR16B0->MCR = 7;	//
     564:	4b2e      	ldr	r3, [pc, #184]	(620 <VideoOutInit+0x204>)
	InitTimer();

	//	PIO1_9,PIO_10 PWM audio out
    LPC_SYSCON->SYSAHBCLKCTRL |= (1<<8);	// enable TMR16B1
	//LPC_GPIO1->DIR |= (1<<9)|(1<<10);
	LPC_IOCON->PIO1_9 = 1;	//	CT16B1_MAT0
     566:	2501      	movs	r5, #1
}

void InitTimer()
{
    LPC_SYSCON->SYSAHBCLKCTRL |= (1<<7);	// enable TMR16B0
	LPC_TMR16B0->MCR = 7;	//
     568:	615a      	str	r2, [r3, #20]
 * Enable a device specific interupt in the NVIC interrupt controller.
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
     56a:	4a2e      	ldr	r2, [pc, #184]	(624 <VideoOutInit+0x208>)
     56c:	2380      	movs	r3, #128
     56e:	025b      	lsls	r3, r3, #9
     570:	6013      	str	r3, [r2, #0]
		LPC_SYSCON->SYSTICKCLKDIV = 0x08;

	InitTimer();

	//	PIO1_9,PIO_10 PWM audio out
    LPC_SYSCON->SYSAHBCLKCTRL |= (1<<8);	// enable TMR16B1
     572:	580a      	ldr	r2, [r1, r0]
     574:	2380      	movs	r3, #128
     576:	005b      	lsls	r3, r3, #1
     578:	431a      	orrs	r2, r3
     57a:	500a      	str	r2, [r1, r0]
	//LPC_GPIO1->DIR |= (1<<9)|(1<<10);
	LPC_IOCON->PIO1_9 = 1;	//	CT16B1_MAT0
     57c:	4a19      	ldr	r2, [pc, #100]	(5e4 <VideoOutInit+0x1c8>)
	LPC_IOCON->PIO1_10 = 2;	//	CT16B1_MAT1
     57e:	2302      	movs	r3, #2
	InitTimer();

	//	PIO1_9,PIO_10 PWM audio out
    LPC_SYSCON->SYSAHBCLKCTRL |= (1<<8);	// enable TMR16B1
	//LPC_GPIO1->DIR |= (1<<9)|(1<<10);
	LPC_IOCON->PIO1_9 = 1;	//	CT16B1_MAT0
     580:	6395      	str	r5, [r2, #56]
	LPC_IOCON->PIO1_10 = 2;	//	CT16B1_MAT1
     582:	66d3      	str	r3, [r2, #108]
	LPC_TMR16B1->PWMC = 3;	// Enable PWM
     584:	4a28      	ldr	r2, [pc, #160]	(628 <VideoOutInit+0x20c>)
     586:	2303      	movs	r3, #3
}

void ADCInit()
{
	int ADC_Clk = 4500000;
	LPC_SYSCON->PDRUNCFG &= ~(0x1<<4);		// Power on
     588:	248e      	movs	r4, #142
	//	PIO1_9,PIO_10 PWM audio out
    LPC_SYSCON->SYSAHBCLKCTRL |= (1<<8);	// enable TMR16B1
	//LPC_GPIO1->DIR |= (1<<9)|(1<<10);
	LPC_IOCON->PIO1_9 = 1;	//	CT16B1_MAT0
	LPC_IOCON->PIO1_10 = 2;	//	CT16B1_MAT1
	LPC_TMR16B1->PWMC = 3;	// Enable PWM
     58a:	6753      	str	r3, [r2, #116]
}

void ADCInit()
{
	int ADC_Clk = 4500000;
	LPC_SYSCON->PDRUNCFG &= ~(0x1<<4);		// Power on
     58c:	00a4      	lsls	r4, r4, #2
    LPC_SYSCON->SYSAHBCLKCTRL |= (1<<8);	// enable TMR16B1
	//LPC_GPIO1->DIR |= (1<<9)|(1<<10);
	LPC_IOCON->PIO1_9 = 1;	//	CT16B1_MAT0
	LPC_IOCON->PIO1_10 = 2;	//	CT16B1_MAT1
	LPC_TMR16B1->PWMC = 3;	// Enable PWM
	LPC_TMR16B1->TCR = 1;
     58e:	6055      	str	r5, [r2, #4]
}

void ADCInit()
{
	int ADC_Clk = 4500000;
	LPC_SYSCON->PDRUNCFG &= ~(0x1<<4);		// Power on
     590:	590b      	ldr	r3, [r1, r4]
     592:	2210      	movs	r2, #16
     594:	4393      	bics	r3, r2
     596:	510b      	str	r3, [r1, r4]
	LPC_SYSCON->SYSAHBCLKCTRL |= (1<<13);	// Enable AHB clock
     598:	580a      	ldr	r2, [r1, r0]
     59a:	2380      	movs	r3, #128
     59c:	019b      	lsls	r3, r3, #6
     59e:	431a      	orrs	r2, r3
	LPC_ADC->CR = ((SystemCoreClock/LPC_SYSCON->SYSAHBCLKDIV)/ADC_Clk-1)<<8;
     5a0:	4b22      	ldr	r3, [pc, #136]	(62c <VideoOutInit+0x210>)

void ADCInit()
{
	int ADC_Clk = 4500000;
	LPC_SYSCON->PDRUNCFG &= ~(0x1<<4);		// Power on
	LPC_SYSCON->SYSAHBCLKCTRL |= (1<<13);	// Enable AHB clock
     5a2:	500a      	str	r2, [r1, r0]
	LPC_ADC->CR = ((SystemCoreClock/LPC_SYSCON->SYSAHBCLKDIV)/ADC_Clk-1)<<8;
     5a4:	6f89      	ldr	r1, [r1, #120]
     5a6:	6818      	ldr	r0, [r3, #0]
     5a8:	f002 fd2c 	bl	3004 <__aeabi_uidiv>
     5ac:	4920      	ldr	r1, [pc, #128]	(630 <VideoOutInit+0x214>)
     5ae:	f002 fd29 	bl	3004 <__aeabi_uidiv>
     5b2:	4b20      	ldr	r3, [pc, #128]	(634 <VideoOutInit+0x218>)
     5b4:	3801      	subs	r0, #1
     5b6:	0200      	lsls	r0, r0, #8
     5b8:	6018      	str	r0, [r3, #0]
};


void MusicPlay(MusicState* s,const u8* track)
{
	s->Duration16th = (15700*15)/track[0];	// hsyncs per 16th
     5ba:	4a1f      	ldr	r2, [pc, #124]	(638 <VideoOutInit+0x21c>)
     5bc:	2392      	movs	r3, #146
     5be:	009b      	lsls	r3, r3, #2
     5c0:	50fa      	str	r2, [r7, r3]
	s->TrackMark = s->Track = track+1;
     5c2:	4652      	mov	r2, sl
     5c4:	238f      	movs	r3, #143
     5c6:	3215      	adds	r2, #21
     5c8:	009b      	lsls	r3, r3, #2
     5ca:	50fa      	str	r2, [r7, r3]
	s->Duration = 1;
     5cc:	2393      	movs	r3, #147
     5ce:	009b      	lsls	r3, r3, #2
	LPC_TMR16B1->PWMC = 3;	// Enable PWM
	LPC_TMR16B1->TCR = 1;

	ADCInit();
	MusicPlay(&gScreen.Music,_clocks);	// play someth'n
}
     5d0:	b003      	add	sp, #12
     5d2:	50fd      	str	r5, [r7, r3]


void MusicPlay(MusicState* s,const u8* track)
{
	s->Duration16th = (15700*15)/track[0];	// hsyncs per 16th
	s->TrackMark = s->Track = track+1;
     5d4:	513a      	str	r2, [r7, r4]
     5d6:	bc3c      	pop	{r2, r3, r4, r5}
     5d8:	4690      	mov	r8, r2
     5da:	4699      	mov	r9, r3
     5dc:	46a2      	mov	sl, r4
     5de:	46ab      	mov	fp, r5
     5e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
     5e2:	46c0      	nop			(mov r8, r8)
     5e4:	40044000 	.word	0x40044000
     5e8:	50020000 	.word	0x50020000
     5ec:	50030000 	.word	0x50030000
     5f0:	50010000 	.word	0x50010000
     5f4:	10001650 	.word	0x10001650
     5f8:	40048000 	.word	0x40048000
     5fc:	0000319c 	.word	0x0000319c
     600:	40040000 	.word	0x40040000
     604:	000000d5 	.word	0x000000d5
     608:	00000139 	.word	0x00000139
     60c:	e000e010 	.word	0xe000e010
     610:	00000e3f 	.word	0x00000e3f
     614:	e000ed00 	.word	0xe000ed00
     618:	00ffffff 	.word	0x00ffffff
     61c:	c0000000 	.word	0xc0000000
     620:	4000c000 	.word	0x4000c000
     624:	e000e100 	.word	0xe000e100
     628:	40010000 	.word	0x40010000
     62c:	1000046c 	.word	0x1000046c
     630:	0044aa20 	.word	0x0044aa20
     634:	4001c000 	.word	0x4001c000
     638:	00000692 	.word	0x00000692

0000063c <TIMER16_0_IRQHandler>:
	}
}

//	Called at end of HSYNC, at start of active video
void TIMER16_0_IRQHandler()
{
     63c:	b530      	push	{r4, r5, lr}
	//STATE |= 2;
	int ir = LPC_TMR16B0->IR;
     63e:	492f      	ldr	r1, [pc, #188]	(6fc <TIMER16_0_IRQHandler+0xc0>)
	LPC_TMR16B0->IR = ir;
	if (gScreen.Pulse < 0)
     640:	4c2f      	ldr	r4, [pc, #188]	(700 <TIMER16_0_IRQHandler+0xc4>)

//	Called at end of HSYNC, at start of active video
void TIMER16_0_IRQHandler()
{
	//STATE |= 2;
	int ir = LPC_TMR16B0->IR;
     642:	680b      	ldr	r3, [r1, #0]
	}
}

//	Called at end of HSYNC, at start of active video
void TIMER16_0_IRQHandler()
{
     644:	b083      	sub	sp, #12
	//STATE |= 2;
	int ir = LPC_TMR16B0->IR;
	LPC_TMR16B0->IR = ir;
     646:	600b      	str	r3, [r1, #0]
	if (gScreen.Pulse < 0)
     648:	68e3      	ldr	r3, [r4, #12]
     64a:	2b00      	cmp	r3, #0
     64c:	db1f      	blt.n	68e <TIMER16_0_IRQHandler+0x52>
		ActiveVideo();
	else
	{
		int t = _pulses[gScreen.Pulse++];
     64e:	68e3      	ldr	r3, [r4, #12]
     650:	492c      	ldr	r1, [pc, #176]	(704 <TIMER16_0_IRQHandler+0xc8>)
     652:	005a      	lsls	r2, r3, #1
     654:	3301      	adds	r3, #1
     656:	60e3      	str	r3, [r4, #12]
		*SYNC = (gScreen.Pulse & 1) ? 0 : SYNC1;
     658:	68e3      	ldr	r3, [r4, #12]
	LPC_TMR16B0->IR = ir;
	if (gScreen.Pulse < 0)
		ActiveVideo();
	else
	{
		int t = _pulses[gScreen.Pulse++];
     65a:	5e51      	ldrsh	r1, [r2, r1]
		*SYNC = (gScreen.Pulse & 1) ? 0 : SYNC1;
     65c:	07da      	lsls	r2, r3, #31
     65e:	d40d      	bmi.n	67c <TIMER16_0_IRQHandler+0x40>
     660:	4b29      	ldr	r3, [pc, #164]	(708 <TIMER16_0_IRQHandler+0xcc>)
     662:	2202      	movs	r2, #2
     664:	601a      	str	r2, [r3, #0]
		if (t == 0)
     666:	2900      	cmp	r1, #0
     668:	d00d      	beq.n	686 <TIMER16_0_IRQHandler+0x4a>
			gScreen.Pulse = -1;
		else
		{
			LPC_TMR16B0->MR0 = t>>1;
     66a:	4a24      	ldr	r2, [pc, #144]	(6fc <TIMER16_0_IRQHandler+0xc0>)
     66c:	104b      	asrs	r3, r1, #1
     66e:	6193      	str	r3, [r2, #24]
			LPC_TMR16B0->TC = 0;
     670:	2300      	movs	r3, #0
     672:	6093      	str	r3, [r2, #8]
			LPC_TMR16B0->TCR = 1;
     674:	2301      	movs	r3, #1
     676:	6053      	str	r3, [r2, #4]
		}
	}
	//STATE &= ~2;
}
     678:	b003      	add	sp, #12
     67a:	bd30      	pop	{r4, r5, pc}
	if (gScreen.Pulse < 0)
		ActiveVideo();
	else
	{
		int t = _pulses[gScreen.Pulse++];
		*SYNC = (gScreen.Pulse & 1) ? 0 : SYNC1;
     67c:	4b22      	ldr	r3, [pc, #136]	(708 <TIMER16_0_IRQHandler+0xcc>)
     67e:	2200      	movs	r2, #0
     680:	601a      	str	r2, [r3, #0]
		if (t == 0)
     682:	2900      	cmp	r1, #0
     684:	d1f1      	bne.n	66a <TIMER16_0_IRQHandler+0x2e>
			gScreen.Pulse = -1;
     686:	2301      	movs	r3, #1
     688:	425b      	negs	r3, r3
     68a:	60e3      	str	r3, [r4, #12]
     68c:	e7f4      	b.n	678 <TIMER16_0_IRQHandler+0x3c>
}

void ActiveVideo()
{
	ScreenState* s = &gScreen;
	if (*SYNC == 0)
     68e:	4a1e      	ldr	r2, [pc, #120]	(708 <TIMER16_0_IRQHandler+0xcc>)
     690:	6810      	ldr	r0, [r2, #0]
     692:	2800      	cmp	r0, #0
     694:	d01a      	beq.n	6cc <TIMER16_0_IRQHandler+0x90>
		b = 256 + (b << 5);
		ComeBackIn(b-6);			// -6 fudge is to align colorbusrt with first color clock in active video
	}
	else
	{
		if (s->Read == s->Write || s->Line < 22)
     696:	6962      	ldr	r2, [r4, #20]
     698:	6923      	ldr	r3, [r4, #16]
     69a:	429a      	cmp	r2, r3
     69c:	d0ec      	beq.n	678 <TIMER16_0_IRQHandler+0x3c>
     69e:	6863      	ldr	r3, [r4, #4]
     6a0:	2b15      	cmp	r3, #21
     6a2:	dde9      	ble.n	678 <TIMER16_0_IRQHandler+0x3c>
			return;
		int mask = LINE_QUEUE_SIZE-1;
		u8** handle = s->LineQueue[s->Read++ & mask];
     6a4:	6962      	ldr	r2, [r4, #20]
     6a6:	2307      	movs	r3, #7
     6a8:	4013      	ands	r3, r2
     6aa:	3306      	adds	r3, #6
     6ac:	3201      	adds	r2, #1
     6ae:	6162      	str	r2, [r4, #20]
     6b0:	009b      	lsls	r3, r3, #2
     6b2:	591d      	ldr	r5, [r3, r4]
		s->blit(&LPC_GPIO2->MASKED_ACCESS[0xF8],&LPC_SSP0->DR,*handle,s->pal,s->Width);
     6b4:	68a1      	ldr	r1, [r4, #8]
     6b6:	682a      	ldr	r2, [r5, #0]
     6b8:	1c23      	adds	r3, r4, #0
     6ba:	9100      	str	r1, [sp, #0]
     6bc:	3338      	adds	r3, #56
     6be:	6824      	ldr	r4, [r4, #0]
     6c0:	4812      	ldr	r0, [pc, #72]	(70c <TIMER16_0_IRQHandler+0xd0>)
     6c2:	4913      	ldr	r1, [pc, #76]	(710 <TIMER16_0_IRQHandler+0xd4>)
     6c4:	47a0      	blx	r4
		*handle = 0;
     6c6:	2300      	movs	r3, #0
     6c8:	602b      	str	r3, [r5, #0]
     6ca:	e7d5      	b.n	678 <TIMER16_0_IRQHandler+0x3c>
void ActiveVideo()
{
	ScreenState* s = &gScreen;
	if (*SYNC == 0)
	{
		*SYNC = SYNC1;	// End of sync, send colorburst
     6cc:	2302      	movs	r3, #2
     6ce:	6013      	str	r3, [r2, #0]
		volatile uint32_t* spi = &LPC_SSP0->DR;
		*spi = 0x0000;	// breezeway
     6d0:	4b0f      	ldr	r3, [pc, #60]	(710 <TIMER16_0_IRQHandler+0xd4>)
		*spi = 0x0000;
		*spi = 0xF0F0;	// colorburst 10 cycles into fifo
     6d2:	4a10      	ldr	r2, [pc, #64]	(714 <TIMER16_0_IRQHandler+0xd8>)
	ScreenState* s = &gScreen;
	if (*SYNC == 0)
	{
		*SYNC = SYNC1;	// End of sync, send colorburst
		volatile uint32_t* spi = &LPC_SSP0->DR;
		*spi = 0x0000;	// breezeway
     6d4:	6018      	str	r0, [r3, #0]
		*spi = 0x0000;
     6d6:	6018      	str	r0, [r3, #0]
		*spi = 0xF0F0;	// colorburst 10 cycles into fifo
     6d8:	601a      	str	r2, [r3, #0]
		*spi = 0xF0F0;
     6da:	601a      	str	r2, [r3, #0]
		*spi = 0xF0F0;
     6dc:	601a      	str	r2, [r3, #0]
		*spi = 0xF0F0;
     6de:	601a      	str	r2, [r3, #0]
		*spi = 0xF0F0;
     6e0:	601a      	str	r2, [r3, #0]

		int b = (360-s->Width)>>3;	// center active video
     6e2:	68a2      	ldr	r2, [r4, #8]
}

void ComeBackIn(int count)
{
	LPC_TMR16B0->TC = 0;
	LPC_TMR16B0->MR0 = count>>1;
     6e4:	23b4      	movs	r3, #180
     6e6:	005b      	lsls	r3, r3, #1
     6e8:	1a9b      	subs	r3, r3, r2
     6ea:	10db      	asrs	r3, r3, #3
     6ec:	015b      	lsls	r3, r3, #5
     6ee:	33fa      	adds	r3, #250
     6f0:	105b      	asrs	r3, r3, #1
	return b-a;
}

void ComeBackIn(int count)
{
	LPC_TMR16B0->TC = 0;
     6f2:	6088      	str	r0, [r1, #8]
	LPC_TMR16B0->MR0 = count>>1;
     6f4:	618b      	str	r3, [r1, #24]
	LPC_TMR16B0->TCR = 1;
     6f6:	2301      	movs	r3, #1
     6f8:	604b      	str	r3, [r1, #4]
     6fa:	e7bd      	b.n	678 <TIMER16_0_IRQHandler+0x3c>
     6fc:	4000c000 	.word	0x4000c000
     700:	10001650 	.word	0x10001650
     704:	0000301c 	.word	0x0000301c
     708:	50010008 	.word	0x50010008
     70c:	500203e0 	.word	0x500203e0
     710:	40040008 	.word	0x40040008
     714:	0000f0f0 	.word	0x0000f0f0

00000718 <_ZN8Renderer5SortYEii>:
        t[j] = tmp;
    }
    
    //  Sort triangles by Y
    //  Could use a more expanded data structure at beginning of frame to speed this up
    void SortY(int left, int right)
     718:	b5f0      	push	{r4, r5, r6, r7, lr}
     71a:	465f      	mov	r7, fp
     71c:	4656      	mov	r6, sl
     71e:	464d      	mov	r5, r9
     720:	4644      	mov	r4, r8
     722:	b4f0      	push	{r4, r5, r6, r7}
     724:	b093      	sub	sp, #76
     726:	4681      	mov	r9, r0
     728:	9101      	str	r1, [sp, #4]
     72a:	9200      	str	r2, [sp, #0]
        dst->z = v.z;
    }

    short TriangleMinY(byte ti)
    {
        return _vertexes[_triangles[ti].p0].y;
     72c:	9901      	ldr	r1, [sp, #4]
     72e:	9a00      	ldr	r2, [sp, #0]
     730:	188b      	adds	r3, r1, r2
     732:	105b      	asrs	r3, r3, #1
     734:	b2db      	uxtb	r3, r3
     736:	3390      	adds	r3, #144
     738:	009b      	lsls	r3, r3, #2
     73a:	444b      	add	r3, r9
     73c:	799a      	ldrb	r2, [r3, #6]
     73e:	21fc      	movs	r1, #252
     740:	0053      	lsls	r3, r2, #1
     742:	189b      	adds	r3, r3, r2
     744:	005b      	lsls	r3, r3, #1
     746:	0049      	lsls	r1, r1, #1
     748:	444b      	add	r3, r9
     74a:	185b      	adds	r3, r3, r1
     74c:	9a01      	ldr	r2, [sp, #4]
     74e:	9900      	ldr	r1, [sp, #0]
     750:	9202      	str	r2, [sp, #8]
     752:	9103      	str	r1, [sp, #12]
     754:	2208      	movs	r2, #8
     756:	5e9e      	ldrsh	r6, [r3, r2]
    {
        int i = left;
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
     758:	9a02      	ldr	r2, [sp, #8]
     75a:	9b03      	ldr	r3, [sp, #12]
     75c:	429a      	cmp	r2, r3
     75e:	dc38      	bgt.n	7d2 <_ZN8Renderer5SortYEii+0xba>
     760:	466a      	mov	r2, sp
     762:	230c      	movs	r3, #12
     764:	5c99      	ldrb	r1, [r3, r2]
     766:	e002      	b.n	76e <_ZN8Renderer5SortYEii+0x56>
        {
            while (TriangleMinY(i) < pivot)
                i++;
     768:	9b02      	ldr	r3, [sp, #8]
     76a:	3301      	adds	r3, #1
     76c:	9302      	str	r3, [sp, #8]
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
     76e:	466a      	mov	r2, sp
     770:	3208      	adds	r2, #8
     772:	7813      	ldrb	r3, [r2, #0]
     774:	1c1d      	adds	r5, r3, #0
     776:	3590      	adds	r5, #144
     778:	00ab      	lsls	r3, r5, #2
     77a:	444b      	add	r3, r9
     77c:	799a      	ldrb	r2, [r3, #6]
     77e:	0053      	lsls	r3, r2, #1
     780:	189b      	adds	r3, r3, r2
     782:	005b      	lsls	r3, r3, #1
     784:	22fc      	movs	r2, #252
     786:	0052      	lsls	r2, r2, #1
     788:	444b      	add	r3, r9
     78a:	189b      	adds	r3, r3, r2
     78c:	2208      	movs	r2, #8
     78e:	5e9b      	ldrsh	r3, [r3, r2]
     790:	42b3      	cmp	r3, r6
     792:	dbe9      	blt.n	768 <_ZN8Renderer5SortYEii+0x50>
     794:	e005      	b.n	7a2 <_ZN8Renderer5SortYEii+0x8a>
                i++;
            while (TriangleMinY(j) > pivot)
                j--;
     796:	9b03      	ldr	r3, [sp, #12]
     798:	466a      	mov	r2, sp
     79a:	3b01      	subs	r3, #1
     79c:	9303      	str	r3, [sp, #12]
     79e:	230c      	movs	r3, #12
     7a0:	5c99      	ldrb	r1, [r3, r2]

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
                i++;
            while (TriangleMinY(j) > pivot)
     7a2:	1c0c      	adds	r4, r1, #0
     7a4:	3490      	adds	r4, #144
     7a6:	00a3      	lsls	r3, r4, #2
     7a8:	444b      	add	r3, r9
     7aa:	799a      	ldrb	r2, [r3, #6]
     7ac:	0053      	lsls	r3, r2, #1
     7ae:	189b      	adds	r3, r3, r2
     7b0:	005b      	lsls	r3, r3, #1
     7b2:	22fc      	movs	r2, #252
     7b4:	0052      	lsls	r2, r2, #1
     7b6:	444b      	add	r3, r9
     7b8:	189b      	adds	r3, r3, r2
     7ba:	2208      	movs	r2, #8
     7bc:	5e9b      	ldrsh	r3, [r3, r2]
     7be:	42b3      	cmp	r3, r6
     7c0:	dce9      	bgt.n	796 <_ZN8Renderer5SortYEii+0x7e>
                j--;
            if (i <= j)
     7c2:	9b02      	ldr	r3, [sp, #8]
     7c4:	9a03      	ldr	r2, [sp, #12]
     7c6:	4293      	cmp	r3, r2
     7c8:	dd13      	ble.n	7f2 <_ZN8Renderer5SortYEii+0xda>
    {
        int i = left;
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
     7ca:	9a03      	ldr	r2, [sp, #12]
     7cc:	9b02      	ldr	r3, [sp, #8]
     7ce:	429a      	cmp	r2, r3
     7d0:	dacd      	bge.n	76e <_ZN8Renderer5SortYEii+0x56>
                i++;
                j--;
            }
        }

        if (left < j)
     7d2:	9b01      	ldr	r3, [sp, #4]
     7d4:	9903      	ldr	r1, [sp, #12]
     7d6:	428b      	cmp	r3, r1
     7d8:	db4e      	blt.n	878 <_ZN8Renderer5SortYEii+0x160>
            SortY(left, j);
        if (i < right)
     7da:	9902      	ldr	r1, [sp, #8]
     7dc:	9a00      	ldr	r2, [sp, #0]
     7de:	9101      	str	r1, [sp, #4]
     7e0:	428a      	cmp	r2, r1
     7e2:	dca3      	bgt.n	72c <_ZN8Renderer5SortYEii+0x14>
            SortY(i, right);
    }
     7e4:	b013      	add	sp, #76
     7e6:	bc3c      	pop	{r2, r3, r4, r5}
     7e8:	4690      	mov	r8, r2
     7ea:	4699      	mov	r9, r3
     7ec:	46a2      	mov	sl, r4
     7ee:	46ab      	mov	fp, r5
     7f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
     7f2:	00ad      	lsls	r5, r5, #2
     7f4:	444d      	add	r5, r9
        t[i] = t[j];
     7f6:	00a4      	lsls	r4, r4, #2
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
     7f8:	3506      	adds	r5, #6
        t[i] = t[j];
     7fa:	444c      	add	r4, r9
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
     7fc:	1c29      	adds	r1, r5, #0
     7fe:	2204      	movs	r2, #4
        t[i] = t[j];
     800:	3406      	adds	r4, #6
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
     802:	a811      	add	r0, sp, #68
     804:	f002 fb58 	bl	2eb8 <memcpy>
        t[i] = t[j];
     808:	1c21      	adds	r1, r4, #0
     80a:	2204      	movs	r2, #4
     80c:	1c28      	adds	r0, r5, #0
     80e:	f002 fb53 	bl	2eb8 <memcpy>
        t[j] = tmp;
     812:	a911      	add	r1, sp, #68
     814:	1c20      	adds	r0, r4, #0
     816:	2204      	movs	r2, #4
     818:	f002 fb4e 	bl	2eb8 <memcpy>
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
     81c:	9b02      	ldr	r3, [sp, #8]
                j--;
     81e:	9903      	ldr	r1, [sp, #12]
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
     820:	3301      	adds	r3, #1
                j--;
     822:	3901      	subs	r1, #1
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
     824:	9302      	str	r3, [sp, #8]
                j--;
     826:	9103      	str	r1, [sp, #12]
     828:	e796      	b.n	758 <_ZN8Renderer5SortYEii+0x40>
        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
                i++;
            while (TriangleMinY(j) > pivot)
                j--;
     82a:	9b05      	ldr	r3, [sp, #20]
     82c:	466a      	mov	r2, sp
     82e:	3b01      	subs	r3, #1
     830:	9305      	str	r3, [sp, #20]
     832:	2314      	movs	r3, #20
     834:	5c99      	ldrb	r1, [r3, r2]

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
                i++;
            while (TriangleMinY(j) > pivot)
     836:	1c0c      	adds	r4, r1, #0
     838:	3490      	adds	r4, #144
     83a:	00a3      	lsls	r3, r4, #2
     83c:	444b      	add	r3, r9
     83e:	799a      	ldrb	r2, [r3, #6]
     840:	0053      	lsls	r3, r2, #1
     842:	189b      	adds	r3, r3, r2
     844:	005b      	lsls	r3, r3, #1
     846:	22fc      	movs	r2, #252
     848:	0052      	lsls	r2, r2, #1
     84a:	444b      	add	r3, r9
     84c:	189b      	adds	r3, r3, r2
     84e:	2208      	movs	r2, #8
     850:	5e9b      	ldrsh	r3, [r3, r2]
     852:	42b3      	cmp	r3, r6
     854:	dce9      	bgt.n	82a <_ZN8Renderer5SortYEii+0x112>
                j--;
            if (i <= j)
     856:	9b04      	ldr	r3, [sp, #16]
     858:	9a05      	ldr	r2, [sp, #20]
     85a:	4293      	cmp	r3, r2
     85c:	dd41      	ble.n	8e2 <_ZN8Renderer5SortYEii+0x1ca>
    {
        int i = left;
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
     85e:	9a05      	ldr	r2, [sp, #20]
     860:	9b04      	ldr	r3, [sp, #16]
     862:	429a      	cmp	r2, r3
     864:	da29      	bge.n	8ba <_ZN8Renderer5SortYEii+0x1a2>
                i++;
                j--;
            }
        }

        if (left < j)
     866:	9b01      	ldr	r3, [sp, #4]
     868:	9905      	ldr	r1, [sp, #20]
     86a:	428b      	cmp	r3, r1
     86c:	db7d      	blt.n	96a <_ZN8Renderer5SortYEii+0x252>
            SortY(left, j);
        if (i < right)
     86e:	9a04      	ldr	r2, [sp, #16]
     870:	9b03      	ldr	r3, [sp, #12]
     872:	429a      	cmp	r2, r3
     874:	dab1      	bge.n	7da <_ZN8Renderer5SortYEii+0xc2>
     876:	9201      	str	r2, [sp, #4]
        dst->z = v.z;
    }

    short TriangleMinY(byte ti)
    {
        return _vertexes[_triangles[ti].p0].y;
     878:	9a01      	ldr	r2, [sp, #4]
     87a:	9903      	ldr	r1, [sp, #12]
     87c:	1853      	adds	r3, r2, r1
     87e:	105b      	asrs	r3, r3, #1
     880:	b2db      	uxtb	r3, r3
     882:	3390      	adds	r3, #144
     884:	009b      	lsls	r3, r3, #2
     886:	444b      	add	r3, r9
     888:	799a      	ldrb	r2, [r3, #6]
     88a:	9901      	ldr	r1, [sp, #4]
     88c:	0053      	lsls	r3, r2, #1
     88e:	189b      	adds	r3, r3, r2
     890:	005b      	lsls	r3, r3, #1
     892:	22fc      	movs	r2, #252
     894:	0052      	lsls	r2, r2, #1
     896:	444b      	add	r3, r9
     898:	189b      	adds	r3, r3, r2
     89a:	9a03      	ldr	r2, [sp, #12]
     89c:	9104      	str	r1, [sp, #16]
     89e:	9205      	str	r2, [sp, #20]
     8a0:	2108      	movs	r1, #8
     8a2:	5e5e      	ldrsh	r6, [r3, r1]
    {
        int i = left;
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
     8a4:	9a04      	ldr	r2, [sp, #16]
     8a6:	9b05      	ldr	r3, [sp, #20]
     8a8:	429a      	cmp	r2, r3
     8aa:	dcdc      	bgt.n	866 <_ZN8Renderer5SortYEii+0x14e>
     8ac:	466a      	mov	r2, sp
     8ae:	2314      	movs	r3, #20
     8b0:	5c99      	ldrb	r1, [r3, r2]
     8b2:	e002      	b.n	8ba <_ZN8Renderer5SortYEii+0x1a2>
        {
            while (TriangleMinY(i) < pivot)
                i++;
     8b4:	9a04      	ldr	r2, [sp, #16]
     8b6:	3201      	adds	r2, #1
     8b8:	9204      	str	r2, [sp, #16]
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
     8ba:	466a      	mov	r2, sp
     8bc:	3210      	adds	r2, #16
     8be:	7813      	ldrb	r3, [r2, #0]
     8c0:	1c1d      	adds	r5, r3, #0
     8c2:	3590      	adds	r5, #144
     8c4:	00ab      	lsls	r3, r5, #2
     8c6:	444b      	add	r3, r9
     8c8:	799a      	ldrb	r2, [r3, #6]
     8ca:	0053      	lsls	r3, r2, #1
     8cc:	189b      	adds	r3, r3, r2
     8ce:	005b      	lsls	r3, r3, #1
     8d0:	22fc      	movs	r2, #252
     8d2:	0052      	lsls	r2, r2, #1
     8d4:	444b      	add	r3, r9
     8d6:	189b      	adds	r3, r3, r2
     8d8:	2208      	movs	r2, #8
     8da:	5e9b      	ldrsh	r3, [r3, r2]
     8dc:	42b3      	cmp	r3, r6
     8de:	dbe9      	blt.n	8b4 <_ZN8Renderer5SortYEii+0x19c>
     8e0:	e7a9      	b.n	836 <_ZN8Renderer5SortYEii+0x11e>
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
     8e2:	00ad      	lsls	r5, r5, #2
     8e4:	444d      	add	r5, r9
        t[i] = t[j];
     8e6:	00a4      	lsls	r4, r4, #2
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
     8e8:	3506      	adds	r5, #6
        t[i] = t[j];
     8ea:	444c      	add	r4, r9
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
     8ec:	1c29      	adds	r1, r5, #0
     8ee:	2204      	movs	r2, #4
        t[i] = t[j];
     8f0:	3406      	adds	r4, #6
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
     8f2:	a811      	add	r0, sp, #68
     8f4:	f002 fae0 	bl	2eb8 <memcpy>
        t[i] = t[j];
     8f8:	1c21      	adds	r1, r4, #0
     8fa:	2204      	movs	r2, #4
     8fc:	1c28      	adds	r0, r5, #0
     8fe:	f002 fadb 	bl	2eb8 <memcpy>
        t[j] = tmp;
     902:	a911      	add	r1, sp, #68
     904:	1c20      	adds	r0, r4, #0
     906:	2204      	movs	r2, #4
     908:	f002 fad6 	bl	2eb8 <memcpy>
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
     90c:	9b04      	ldr	r3, [sp, #16]
                j--;
     90e:	9905      	ldr	r1, [sp, #20]
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
     910:	3301      	adds	r3, #1
                j--;
     912:	3901      	subs	r1, #1
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
     914:	9304      	str	r3, [sp, #16]
                j--;
     916:	9105      	str	r1, [sp, #20]
     918:	e7c4      	b.n	8a4 <_ZN8Renderer5SortYEii+0x18c>
        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
                i++;
            while (TriangleMinY(j) > pivot)
                j--;
     91a:	9b07      	ldr	r3, [sp, #28]
     91c:	466a      	mov	r2, sp
     91e:	3b01      	subs	r3, #1
     920:	9307      	str	r3, [sp, #28]
     922:	231c      	movs	r3, #28
     924:	5c99      	ldrb	r1, [r3, r2]

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
                i++;
            while (TriangleMinY(j) > pivot)
     926:	1c0c      	adds	r4, r1, #0
     928:	3490      	adds	r4, #144
     92a:	00a3      	lsls	r3, r4, #2
     92c:	444b      	add	r3, r9
     92e:	799a      	ldrb	r2, [r3, #6]
     930:	0053      	lsls	r3, r2, #1
     932:	189b      	adds	r3, r3, r2
     934:	005b      	lsls	r3, r3, #1
     936:	22fc      	movs	r2, #252
     938:	0052      	lsls	r2, r2, #1
     93a:	444b      	add	r3, r9
     93c:	189b      	adds	r3, r3, r2
     93e:	2208      	movs	r2, #8
     940:	5e9b      	ldrsh	r3, [r3, r2]
     942:	42b3      	cmp	r3, r6
     944:	dce9      	bgt.n	91a <_ZN8Renderer5SortYEii+0x202>
                j--;
            if (i <= j)
     946:	9b06      	ldr	r3, [sp, #24]
     948:	9a07      	ldr	r2, [sp, #28]
     94a:	4293      	cmp	r3, r2
     94c:	dd42      	ble.n	9d4 <_ZN8Renderer5SortYEii+0x2bc>
    {
        int i = left;
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
     94e:	9a07      	ldr	r2, [sp, #28]
     950:	9b06      	ldr	r3, [sp, #24]
     952:	429a      	cmp	r2, r3
     954:	da2a      	bge.n	9ac <_ZN8Renderer5SortYEii+0x294>
                i++;
                j--;
            }
        }

        if (left < j)
     956:	9b01      	ldr	r3, [sp, #4]
     958:	9907      	ldr	r1, [sp, #28]
     95a:	428b      	cmp	r3, r1
     95c:	da00      	bge.n	960 <_ZN8Renderer5SortYEii+0x248>
     95e:	e08f      	b.n	a80 <_ZN8Renderer5SortYEii+0x368>
            SortY(left, j);
        if (i < right)
     960:	9b06      	ldr	r3, [sp, #24]
     962:	9905      	ldr	r1, [sp, #20]
     964:	428b      	cmp	r3, r1
     966:	da82      	bge.n	86e <_ZN8Renderer5SortYEii+0x156>
     968:	9301      	str	r3, [sp, #4]
        dst->z = v.z;
    }

    short TriangleMinY(byte ti)
    {
        return _vertexes[_triangles[ti].p0].y;
     96a:	9a01      	ldr	r2, [sp, #4]
     96c:	9905      	ldr	r1, [sp, #20]
     96e:	1853      	adds	r3, r2, r1
     970:	105b      	asrs	r3, r3, #1
     972:	b2db      	uxtb	r3, r3
     974:	3390      	adds	r3, #144
     976:	009b      	lsls	r3, r3, #2
     978:	444b      	add	r3, r9
     97a:	799a      	ldrb	r2, [r3, #6]
     97c:	9901      	ldr	r1, [sp, #4]
     97e:	0053      	lsls	r3, r2, #1
     980:	189b      	adds	r3, r3, r2
     982:	005b      	lsls	r3, r3, #1
     984:	22fc      	movs	r2, #252
     986:	0052      	lsls	r2, r2, #1
     988:	444b      	add	r3, r9
     98a:	189b      	adds	r3, r3, r2
     98c:	9a05      	ldr	r2, [sp, #20]
     98e:	9106      	str	r1, [sp, #24]
     990:	9207      	str	r2, [sp, #28]
     992:	2108      	movs	r1, #8
     994:	5e5e      	ldrsh	r6, [r3, r1]
    {
        int i = left;
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
     996:	9a06      	ldr	r2, [sp, #24]
     998:	9b07      	ldr	r3, [sp, #28]
     99a:	429a      	cmp	r2, r3
     99c:	dcdb      	bgt.n	956 <_ZN8Renderer5SortYEii+0x23e>
     99e:	466a      	mov	r2, sp
     9a0:	231c      	movs	r3, #28
     9a2:	5c99      	ldrb	r1, [r3, r2]
     9a4:	e002      	b.n	9ac <_ZN8Renderer5SortYEii+0x294>
        {
            while (TriangleMinY(i) < pivot)
                i++;
     9a6:	9a06      	ldr	r2, [sp, #24]
     9a8:	3201      	adds	r2, #1
     9aa:	9206      	str	r2, [sp, #24]
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
     9ac:	466a      	mov	r2, sp
     9ae:	3218      	adds	r2, #24
     9b0:	7813      	ldrb	r3, [r2, #0]
     9b2:	1c1d      	adds	r5, r3, #0
     9b4:	3590      	adds	r5, #144
     9b6:	00ab      	lsls	r3, r5, #2
     9b8:	444b      	add	r3, r9
     9ba:	799a      	ldrb	r2, [r3, #6]
     9bc:	0053      	lsls	r3, r2, #1
     9be:	189b      	adds	r3, r3, r2
     9c0:	005b      	lsls	r3, r3, #1
     9c2:	22fc      	movs	r2, #252
     9c4:	0052      	lsls	r2, r2, #1
     9c6:	444b      	add	r3, r9
     9c8:	189b      	adds	r3, r3, r2
     9ca:	2208      	movs	r2, #8
     9cc:	5e9b      	ldrsh	r3, [r3, r2]
     9ce:	42b3      	cmp	r3, r6
     9d0:	dbe9      	blt.n	9a6 <_ZN8Renderer5SortYEii+0x28e>
     9d2:	e7a8      	b.n	926 <_ZN8Renderer5SortYEii+0x20e>
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
     9d4:	00ad      	lsls	r5, r5, #2
     9d6:	444d      	add	r5, r9
        t[i] = t[j];
     9d8:	00a4      	lsls	r4, r4, #2
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
     9da:	3506      	adds	r5, #6
        t[i] = t[j];
     9dc:	444c      	add	r4, r9
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
     9de:	1c29      	adds	r1, r5, #0
     9e0:	2204      	movs	r2, #4
        t[i] = t[j];
     9e2:	3406      	adds	r4, #6
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
     9e4:	a811      	add	r0, sp, #68
     9e6:	f002 fa67 	bl	2eb8 <memcpy>
        t[i] = t[j];
     9ea:	1c21      	adds	r1, r4, #0
     9ec:	2204      	movs	r2, #4
     9ee:	1c28      	adds	r0, r5, #0
     9f0:	f002 fa62 	bl	2eb8 <memcpy>
        t[j] = tmp;
     9f4:	a911      	add	r1, sp, #68
     9f6:	1c20      	adds	r0, r4, #0
     9f8:	2204      	movs	r2, #4
     9fa:	f002 fa5d 	bl	2eb8 <memcpy>
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
     9fe:	9b06      	ldr	r3, [sp, #24]
                j--;
     a00:	9907      	ldr	r1, [sp, #28]
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
     a02:	3301      	adds	r3, #1
                j--;
     a04:	3901      	subs	r1, #1
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
     a06:	9306      	str	r3, [sp, #24]
                j--;
     a08:	9107      	str	r1, [sp, #28]
     a0a:	e7c4      	b.n	996 <_ZN8Renderer5SortYEii+0x27e>
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
     a0c:	9008      	str	r0, [sp, #32]
                i++;
            while (TriangleMinY(j) > pivot)
     a0e:	aa09      	add	r2, sp, #36
     a10:	7813      	ldrb	r3, [r2, #0]
     a12:	21fc      	movs	r1, #252
     a14:	1c1c      	adds	r4, r3, #0
     a16:	3490      	adds	r4, #144
     a18:	00a3      	lsls	r3, r4, #2
     a1a:	444b      	add	r3, r9
     a1c:	799a      	ldrb	r2, [r3, #6]
     a1e:	0049      	lsls	r1, r1, #1
     a20:	0053      	lsls	r3, r2, #1
     a22:	189b      	adds	r3, r3, r2
     a24:	005b      	lsls	r3, r3, #1
     a26:	444b      	add	r3, r9
     a28:	185b      	adds	r3, r3, r1
     a2a:	2208      	movs	r2, #8
     a2c:	5e9b      	ldrsh	r3, [r3, r2]
     a2e:	42b3      	cmp	r3, r6
     a30:	dc01      	bgt.n	a36 <_ZN8Renderer5SortYEii+0x31e>
     a32:	e2ed      	b.n	1010 <_ZN8Renderer5SortYEii+0x8f8>
     a34:	9109      	str	r1, [sp, #36]
                j--;
     a36:	9909      	ldr	r1, [sp, #36]
     a38:	3901      	subs	r1, #1
     a3a:	b2cb      	uxtb	r3, r1

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
                i++;
            while (TriangleMinY(j) > pivot)
     a3c:	1c1c      	adds	r4, r3, #0
     a3e:	3490      	adds	r4, #144
     a40:	00a3      	lsls	r3, r4, #2
     a42:	444b      	add	r3, r9
     a44:	799a      	ldrb	r2, [r3, #6]
     a46:	0053      	lsls	r3, r2, #1
     a48:	189b      	adds	r3, r3, r2
     a4a:	005b      	lsls	r3, r3, #1
     a4c:	22fc      	movs	r2, #252
     a4e:	0052      	lsls	r2, r2, #1
     a50:	444b      	add	r3, r9
     a52:	189b      	adds	r3, r3, r2
     a54:	2208      	movs	r2, #8
     a56:	5e9b      	ldrsh	r3, [r3, r2]
     a58:	42b3      	cmp	r3, r6
     a5a:	dceb      	bgt.n	a34 <_ZN8Renderer5SortYEii+0x31c>
     a5c:	9109      	str	r1, [sp, #36]
                j--;
            if (i <= j)
     a5e:	4288      	cmp	r0, r1
     a60:	dc00      	bgt.n	a64 <_ZN8Renderer5SortYEii+0x34c>
     a62:	e2b7      	b.n	fd4 <_ZN8Renderer5SortYEii+0x8bc>
    {
        int i = left;
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
     a64:	9908      	ldr	r1, [sp, #32]
     a66:	9a09      	ldr	r2, [sp, #36]
     a68:	4291      	cmp	r1, r2
     a6a:	dd23      	ble.n	ab4 <_ZN8Renderer5SortYEii+0x39c>
                i++;
                j--;
            }
        }

        if (left < j)
     a6c:	9a01      	ldr	r2, [sp, #4]
     a6e:	9b09      	ldr	r3, [sp, #36]
     a70:	429a      	cmp	r2, r3
     a72:	db6a      	blt.n	b4a <_ZN8Renderer5SortYEii+0x432>
            SortY(left, j);
        if (i < right)
     a74:	9908      	ldr	r1, [sp, #32]
     a76:	9a07      	ldr	r2, [sp, #28]
     a78:	4291      	cmp	r1, r2
     a7a:	db00      	blt.n	a7e <_ZN8Renderer5SortYEii+0x366>
     a7c:	e770      	b.n	960 <_ZN8Renderer5SortYEii+0x248>
     a7e:	9101      	str	r1, [sp, #4]
        dst->z = v.z;
    }

    short TriangleMinY(byte ti)
    {
        return _vertexes[_triangles[ti].p0].y;
     a80:	9a01      	ldr	r2, [sp, #4]
     a82:	9907      	ldr	r1, [sp, #28]
     a84:	1853      	adds	r3, r2, r1
     a86:	105b      	asrs	r3, r3, #1
     a88:	b2db      	uxtb	r3, r3
     a8a:	3390      	adds	r3, #144
     a8c:	009b      	lsls	r3, r3, #2
     a8e:	444b      	add	r3, r9
     a90:	799a      	ldrb	r2, [r3, #6]
     a92:	9901      	ldr	r1, [sp, #4]
     a94:	0053      	lsls	r3, r2, #1
     a96:	189b      	adds	r3, r3, r2
     a98:	005b      	lsls	r3, r3, #1
     a9a:	22fc      	movs	r2, #252
     a9c:	0052      	lsls	r2, r2, #1
     a9e:	444b      	add	r3, r9
     aa0:	189b      	adds	r3, r3, r2
     aa2:	9a07      	ldr	r2, [sp, #28]
     aa4:	9108      	str	r1, [sp, #32]
     aa6:	9209      	str	r2, [sp, #36]
     aa8:	2108      	movs	r1, #8
     aaa:	5e5e      	ldrsh	r6, [r3, r1]
    {
        int i = left;
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
     aac:	9a08      	ldr	r2, [sp, #32]
     aae:	9b09      	ldr	r3, [sp, #36]
     ab0:	429a      	cmp	r2, r3
     ab2:	dcdb      	bgt.n	a6c <_ZN8Renderer5SortYEii+0x354>
        {
            while (TriangleMinY(i) < pivot)
     ab4:	a908      	add	r1, sp, #32
     ab6:	780b      	ldrb	r3, [r1, #0]
     ab8:	1c1d      	adds	r5, r3, #0
     aba:	3590      	adds	r5, #144
     abc:	00ab      	lsls	r3, r5, #2
     abe:	444b      	add	r3, r9
     ac0:	799a      	ldrb	r2, [r3, #6]
     ac2:	0053      	lsls	r3, r2, #1
     ac4:	189b      	adds	r3, r3, r2
     ac6:	005b      	lsls	r3, r3, #1
     ac8:	22fc      	movs	r2, #252
     aca:	444b      	add	r3, r9
     acc:	0052      	lsls	r2, r2, #1
     ace:	189b      	adds	r3, r3, r2
     ad0:	2108      	movs	r1, #8
     ad2:	5e5b      	ldrsh	r3, [r3, r1]
     ad4:	42b3      	cmp	r3, r6
     ad6:	db01      	blt.n	adc <_ZN8Renderer5SortYEii+0x3c4>
     ad8:	e298      	b.n	100c <_ZN8Renderer5SortYEii+0x8f4>
        dst->z = v.z;
    }

    short TriangleMinY(byte ti)
    {
        return _vertexes[_triangles[ti].p0].y;
     ada:	9008      	str	r0, [sp, #32]
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
                i++;
     adc:	9808      	ldr	r0, [sp, #32]
     ade:	3001      	adds	r0, #1
     ae0:	b2c3      	uxtb	r3, r0
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
     ae2:	1c1d      	adds	r5, r3, #0
     ae4:	3590      	adds	r5, #144
     ae6:	00ab      	lsls	r3, r5, #2
     ae8:	444b      	add	r3, r9
     aea:	799a      	ldrb	r2, [r3, #6]
     aec:	0053      	lsls	r3, r2, #1
     aee:	189b      	adds	r3, r3, r2
     af0:	005b      	lsls	r3, r3, #1
     af2:	22fc      	movs	r2, #252
     af4:	444b      	add	r3, r9
     af6:	0052      	lsls	r2, r2, #1
     af8:	189b      	adds	r3, r3, r2
     afa:	2108      	movs	r1, #8
     afc:	5e5b      	ldrsh	r3, [r3, r1]
     afe:	42b3      	cmp	r3, r6
     b00:	dbeb      	blt.n	ada <_ZN8Renderer5SortYEii+0x3c2>
     b02:	e783      	b.n	a0c <_ZN8Renderer5SortYEii+0x2f4>
                i++;
            while (TriangleMinY(j) > pivot)
     b04:	aa0b      	add	r2, sp, #44
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
     b06:	960a      	str	r6, [sp, #40]
                i++;
            while (TriangleMinY(j) > pivot)
     b08:	7813      	ldrb	r3, [r2, #0]
     b0a:	e001      	b.n	b10 <_ZN8Renderer5SortYEii+0x3f8>
                j--;
     b0c:	3901      	subs	r1, #1
     b0e:	b2cb      	uxtb	r3, r1

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
                i++;
            while (TriangleMinY(j) > pivot)
     b10:	1c1c      	adds	r4, r3, #0
     b12:	3490      	adds	r4, #144
     b14:	00a3      	lsls	r3, r4, #2
     b16:	444b      	add	r3, r9
     b18:	799a      	ldrb	r2, [r3, #6]
     b1a:	0053      	lsls	r3, r2, #1
     b1c:	189b      	adds	r3, r3, r2
     b1e:	005b      	lsls	r3, r3, #1
     b20:	22fc      	movs	r2, #252
     b22:	0052      	lsls	r2, r2, #1
     b24:	444b      	add	r3, r9
     b26:	189b      	adds	r3, r3, r2
     b28:	2208      	movs	r2, #8
     b2a:	5e9b      	ldrsh	r3, [r3, r2]
     b2c:	42bb      	cmp	r3, r7
     b2e:	dced      	bgt.n	b0c <_ZN8Renderer5SortYEii+0x3f4>
     b30:	910b      	str	r1, [sp, #44]
                j--;
            if (i <= j)
     b32:	428e      	cmp	r6, r1
     b34:	dc00      	bgt.n	b38 <_ZN8Renderer5SortYEii+0x420>
     b36:	e232      	b.n	f9e <_ZN8Renderer5SortYEii+0x886>
                i++;
                j--;
            }
        }

        if (left < j)
     b38:	9b01      	ldr	r3, [sp, #4]
     b3a:	990b      	ldr	r1, [sp, #44]
     b3c:	428b      	cmp	r3, r1
     b3e:	db69      	blt.n	c14 <_ZN8Renderer5SortYEii+0x4fc>
            SortY(left, j);
        if (i < right)
     b40:	9a0a      	ldr	r2, [sp, #40]
     b42:	9b09      	ldr	r3, [sp, #36]
     b44:	429a      	cmp	r2, r3
     b46:	da95      	bge.n	a74 <_ZN8Renderer5SortYEii+0x35c>
     b48:	9201      	str	r2, [sp, #4]
        dst->z = v.z;
    }

    short TriangleMinY(byte ti)
    {
        return _vertexes[_triangles[ti].p0].y;
     b4a:	9901      	ldr	r1, [sp, #4]
     b4c:	9a09      	ldr	r2, [sp, #36]
     b4e:	188b      	adds	r3, r1, r2
     b50:	105b      	asrs	r3, r3, #1
     b52:	b2db      	uxtb	r3, r3
     b54:	3390      	adds	r3, #144
     b56:	009b      	lsls	r3, r3, #2
     b58:	444b      	add	r3, r9
     b5a:	799a      	ldrb	r2, [r3, #6]
     b5c:	21fc      	movs	r1, #252
     b5e:	0053      	lsls	r3, r2, #1
     b60:	189b      	adds	r3, r3, r2
     b62:	005b      	lsls	r3, r3, #1
     b64:	0049      	lsls	r1, r1, #1
     b66:	444b      	add	r3, r9
     b68:	185b      	adds	r3, r3, r1
     b6a:	9a01      	ldr	r2, [sp, #4]
     b6c:	9909      	ldr	r1, [sp, #36]
     b6e:	920a      	str	r2, [sp, #40]
     b70:	910b      	str	r1, [sp, #44]
     b72:	2208      	movs	r2, #8
     b74:	5e9f      	ldrsh	r7, [r3, r2]
    {
        int i = left;
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
     b76:	990a      	ldr	r1, [sp, #40]
     b78:	9a0b      	ldr	r2, [sp, #44]
     b7a:	4291      	cmp	r1, r2
     b7c:	dcdc      	bgt.n	b38 <_ZN8Renderer5SortYEii+0x420>
     b7e:	1c0e      	adds	r6, r1, #0
     b80:	990b      	ldr	r1, [sp, #44]
     b82:	e000      	b.n	b86 <_ZN8Renderer5SortYEii+0x46e>
        {
            while (TriangleMinY(i) < pivot)
                i++;
     b84:	3601      	adds	r6, #1
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
     b86:	b2f3      	uxtb	r3, r6
     b88:	1c1d      	adds	r5, r3, #0
     b8a:	3590      	adds	r5, #144
     b8c:	00ab      	lsls	r3, r5, #2
     b8e:	444b      	add	r3, r9
     b90:	799a      	ldrb	r2, [r3, #6]
     b92:	0053      	lsls	r3, r2, #1
     b94:	189b      	adds	r3, r3, r2
     b96:	005b      	lsls	r3, r3, #1
     b98:	22fc      	movs	r2, #252
     b9a:	0052      	lsls	r2, r2, #1
     b9c:	444b      	add	r3, r9
     b9e:	189b      	adds	r3, r3, r2
     ba0:	2208      	movs	r2, #8
     ba2:	5e9b      	ldrsh	r3, [r3, r2]
     ba4:	42bb      	cmp	r3, r7
     ba6:	dbed      	blt.n	b84 <_ZN8Renderer5SortYEii+0x46c>
     ba8:	e7ac      	b.n	b04 <_ZN8Renderer5SortYEii+0x3ec>
                i++;
            while (TriangleMinY(j) > pivot)
     baa:	aa0d      	add	r2, sp, #52
     bac:	7813      	ldrb	r3, [r2, #0]
     bae:	21fc      	movs	r1, #252
     bb0:	1c1c      	adds	r4, r3, #0
     bb2:	3490      	adds	r4, #144
     bb4:	00a3      	lsls	r3, r4, #2
     bb6:	444b      	add	r3, r9
     bb8:	799a      	ldrb	r2, [r3, #6]
     bba:	0049      	lsls	r1, r1, #1
     bbc:	0053      	lsls	r3, r2, #1
     bbe:	189b      	adds	r3, r3, r2
     bc0:	005b      	lsls	r3, r3, #1
     bc2:	444b      	add	r3, r9
     bc4:	185b      	adds	r3, r3, r1
     bc6:	2208      	movs	r2, #8
     bc8:	5e9b      	ldrsh	r3, [r3, r2]
     bca:	42b3      	cmp	r3, r6
     bcc:	dd14      	ble.n	bf8 <_ZN8Renderer5SortYEii+0x4e0>
                j--;
     bce:	9b0d      	ldr	r3, [sp, #52]
     bd0:	a90d      	add	r1, sp, #52
     bd2:	3b01      	subs	r3, #1
     bd4:	930d      	str	r3, [sp, #52]
     bd6:	780b      	ldrb	r3, [r1, #0]

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
                i++;
            while (TriangleMinY(j) > pivot)
     bd8:	1c1c      	adds	r4, r3, #0
     bda:	3490      	adds	r4, #144
     bdc:	00a3      	lsls	r3, r4, #2
     bde:	444b      	add	r3, r9
     be0:	799a      	ldrb	r2, [r3, #6]
     be2:	0053      	lsls	r3, r2, #1
     be4:	189b      	adds	r3, r3, r2
     be6:	005b      	lsls	r3, r3, #1
     be8:	22fc      	movs	r2, #252
     bea:	444b      	add	r3, r9
     bec:	0052      	lsls	r2, r2, #1
     bee:	189b      	adds	r3, r3, r2
     bf0:	2108      	movs	r1, #8
     bf2:	5e5b      	ldrsh	r3, [r3, r1]
     bf4:	42b3      	cmp	r3, r6
     bf6:	dcea      	bgt.n	bce <_ZN8Renderer5SortYEii+0x4b6>
                j--;
            if (i <= j)
     bf8:	9a0c      	ldr	r2, [sp, #48]
     bfa:	9b0d      	ldr	r3, [sp, #52]
     bfc:	429a      	cmp	r2, r3
     bfe:	dc00      	bgt.n	c02 <_ZN8Renderer5SortYEii+0x4ea>
     c00:	e1af      	b.n	f62 <_ZN8Renderer5SortYEii+0x84a>
                i++;
                j--;
            }
        }

        if (left < j)
     c02:	9b01      	ldr	r3, [sp, #4]
     c04:	990d      	ldr	r1, [sp, #52]
     c06:	428b      	cmp	r3, r1
     c08:	db7b      	blt.n	d02 <_ZN8Renderer5SortYEii+0x5ea>
            SortY(left, j);
        if (i < right)
     c0a:	9b0c      	ldr	r3, [sp, #48]
     c0c:	990b      	ldr	r1, [sp, #44]
     c0e:	428b      	cmp	r3, r1
     c10:	da96      	bge.n	b40 <_ZN8Renderer5SortYEii+0x428>
     c12:	9301      	str	r3, [sp, #4]
        dst->z = v.z;
    }

    short TriangleMinY(byte ti)
    {
        return _vertexes[_triangles[ti].p0].y;
     c14:	9a01      	ldr	r2, [sp, #4]
     c16:	990b      	ldr	r1, [sp, #44]
     c18:	1853      	adds	r3, r2, r1
     c1a:	105b      	asrs	r3, r3, #1
     c1c:	b2db      	uxtb	r3, r3
     c1e:	3390      	adds	r3, #144
     c20:	009b      	lsls	r3, r3, #2
     c22:	444b      	add	r3, r9
     c24:	799a      	ldrb	r2, [r3, #6]
     c26:	9901      	ldr	r1, [sp, #4]
     c28:	0053      	lsls	r3, r2, #1
     c2a:	189b      	adds	r3, r3, r2
     c2c:	005b      	lsls	r3, r3, #1
     c2e:	22fc      	movs	r2, #252
     c30:	0052      	lsls	r2, r2, #1
     c32:	444b      	add	r3, r9
     c34:	189b      	adds	r3, r3, r2
     c36:	9a0b      	ldr	r2, [sp, #44]
     c38:	910c      	str	r1, [sp, #48]
     c3a:	920d      	str	r2, [sp, #52]
     c3c:	2108      	movs	r1, #8
     c3e:	5e5e      	ldrsh	r6, [r3, r1]
     c40:	9b0c      	ldr	r3, [sp, #48]
     c42:	1c11      	adds	r1, r2, #0
    {
        int i = left;
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
     c44:	428b      	cmp	r3, r1
     c46:	dcdc      	bgt.n	c02 <_ZN8Renderer5SortYEii+0x4ea>
     c48:	aa0c      	add	r2, sp, #48
     c4a:	7813      	ldrb	r3, [r2, #0]
        {
            while (TriangleMinY(i) < pivot)
     c4c:	21fc      	movs	r1, #252
     c4e:	1c1d      	adds	r5, r3, #0
     c50:	3590      	adds	r5, #144
     c52:	00ab      	lsls	r3, r5, #2
     c54:	444b      	add	r3, r9
     c56:	799a      	ldrb	r2, [r3, #6]
     c58:	0049      	lsls	r1, r1, #1
     c5a:	0053      	lsls	r3, r2, #1
     c5c:	189b      	adds	r3, r3, r2
     c5e:	005b      	lsls	r3, r3, #1
     c60:	444b      	add	r3, r9
     c62:	185b      	adds	r3, r3, r1
     c64:	2208      	movs	r2, #8
     c66:	5e9b      	ldrsh	r3, [r3, r2]
     c68:	42b3      	cmp	r3, r6
     c6a:	da9e      	bge.n	baa <_ZN8Renderer5SortYEii+0x492>
                i++;
     c6c:	9a0c      	ldr	r2, [sp, #48]
     c6e:	a90c      	add	r1, sp, #48
     c70:	3201      	adds	r2, #1
     c72:	920c      	str	r2, [sp, #48]
     c74:	780b      	ldrb	r3, [r1, #0]
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
     c76:	1c1d      	adds	r5, r3, #0
     c78:	3590      	adds	r5, #144
     c7a:	00ab      	lsls	r3, r5, #2
     c7c:	444b      	add	r3, r9
     c7e:	799a      	ldrb	r2, [r3, #6]
     c80:	0053      	lsls	r3, r2, #1
     c82:	189b      	adds	r3, r3, r2
     c84:	005b      	lsls	r3, r3, #1
     c86:	22fc      	movs	r2, #252
     c88:	444b      	add	r3, r9
     c8a:	0052      	lsls	r2, r2, #1
     c8c:	189b      	adds	r3, r3, r2
     c8e:	2108      	movs	r1, #8
     c90:	5e5b      	ldrsh	r3, [r3, r1]
     c92:	42b3      	cmp	r3, r6
     c94:	dbea      	blt.n	c6c <_ZN8Renderer5SortYEii+0x554>
     c96:	e788      	b.n	baa <_ZN8Renderer5SortYEii+0x492>
                i++;
            while (TriangleMinY(j) > pivot)
     c98:	aa0e      	add	r2, sp, #56
     c9a:	7813      	ldrb	r3, [r2, #0]
     c9c:	21fc      	movs	r1, #252
     c9e:	1c1c      	adds	r4, r3, #0
     ca0:	3490      	adds	r4, #144
     ca2:	00a3      	lsls	r3, r4, #2
     ca4:	444b      	add	r3, r9
     ca6:	799a      	ldrb	r2, [r3, #6]
     ca8:	0049      	lsls	r1, r1, #1
     caa:	0053      	lsls	r3, r2, #1
     cac:	189b      	adds	r3, r3, r2
     cae:	005b      	lsls	r3, r3, #1
     cb0:	444b      	add	r3, r9
     cb2:	185b      	adds	r3, r3, r1
     cb4:	2208      	movs	r2, #8
     cb6:	5e9b      	ldrsh	r3, [r3, r2]
     cb8:	42b3      	cmp	r3, r6
     cba:	dd14      	ble.n	ce6 <_ZN8Renderer5SortYEii+0x5ce>
                j--;
     cbc:	9b0e      	ldr	r3, [sp, #56]
     cbe:	a90e      	add	r1, sp, #56
     cc0:	3b01      	subs	r3, #1
     cc2:	930e      	str	r3, [sp, #56]
     cc4:	780b      	ldrb	r3, [r1, #0]

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
                i++;
            while (TriangleMinY(j) > pivot)
     cc6:	1c1c      	adds	r4, r3, #0
     cc8:	3490      	adds	r4, #144
     cca:	00a3      	lsls	r3, r4, #2
     ccc:	444b      	add	r3, r9
     cce:	799a      	ldrb	r2, [r3, #6]
     cd0:	0053      	lsls	r3, r2, #1
     cd2:	189b      	adds	r3, r3, r2
     cd4:	005b      	lsls	r3, r3, #1
     cd6:	22fc      	movs	r2, #252
     cd8:	444b      	add	r3, r9
     cda:	0052      	lsls	r2, r2, #1
     cdc:	189b      	adds	r3, r3, r2
     cde:	2108      	movs	r1, #8
     ce0:	5e5b      	ldrsh	r3, [r3, r1]
     ce2:	42b3      	cmp	r3, r6
     ce4:	dcea      	bgt.n	cbc <_ZN8Renderer5SortYEii+0x5a4>
                j--;
            if (i <= j)
     ce6:	9a0f      	ldr	r2, [sp, #60]
     ce8:	9b0e      	ldr	r3, [sp, #56]
     cea:	429a      	cmp	r2, r3
     cec:	dc00      	bgt.n	cf0 <_ZN8Renderer5SortYEii+0x5d8>
     cee:	e114      	b.n	f1a <_ZN8Renderer5SortYEii+0x802>
                i++;
                j--;
            }
        }

        if (left < j)
     cf0:	9b01      	ldr	r3, [sp, #4]
     cf2:	990e      	ldr	r1, [sp, #56]
     cf4:	428b      	cmp	r3, r1
     cf6:	db69      	blt.n	dcc <_ZN8Renderer5SortYEii+0x6b4>
            SortY(left, j);
        if (i < right)
     cf8:	990d      	ldr	r1, [sp, #52]
     cfa:	9a0f      	ldr	r2, [sp, #60]
     cfc:	4291      	cmp	r1, r2
     cfe:	dd84      	ble.n	c0a <_ZN8Renderer5SortYEii+0x4f2>
     d00:	9201      	str	r2, [sp, #4]
        dst->z = v.z;
    }

    short TriangleMinY(byte ti)
    {
        return _vertexes[_triangles[ti].p0].y;
     d02:	9a01      	ldr	r2, [sp, #4]
     d04:	990d      	ldr	r1, [sp, #52]
     d06:	1853      	adds	r3, r2, r1
     d08:	105b      	asrs	r3, r3, #1
     d0a:	b2db      	uxtb	r3, r3
     d0c:	3390      	adds	r3, #144
     d0e:	009b      	lsls	r3, r3, #2
     d10:	444b      	add	r3, r9
     d12:	799a      	ldrb	r2, [r3, #6]
     d14:	9901      	ldr	r1, [sp, #4]
     d16:	0053      	lsls	r3, r2, #1
     d18:	189b      	adds	r3, r3, r2
     d1a:	005b      	lsls	r3, r3, #1
     d1c:	22fc      	movs	r2, #252
     d1e:	0052      	lsls	r2, r2, #1
     d20:	444b      	add	r3, r9
     d22:	189b      	adds	r3, r3, r2
     d24:	9a0d      	ldr	r2, [sp, #52]
     d26:	910f      	str	r1, [sp, #60]
     d28:	920e      	str	r2, [sp, #56]
     d2a:	2108      	movs	r1, #8
     d2c:	5e5e      	ldrsh	r6, [r3, r1]
     d2e:	9b0f      	ldr	r3, [sp, #60]
     d30:	1c11      	adds	r1, r2, #0
    {
        int i = left;
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
     d32:	428b      	cmp	r3, r1
     d34:	dcdc      	bgt.n	cf0 <_ZN8Renderer5SortYEii+0x5d8>
     d36:	aa0f      	add	r2, sp, #60
     d38:	7813      	ldrb	r3, [r2, #0]
        {
            while (TriangleMinY(i) < pivot)
     d3a:	21fc      	movs	r1, #252
     d3c:	1c1d      	adds	r5, r3, #0
     d3e:	3590      	adds	r5, #144
     d40:	00ab      	lsls	r3, r5, #2
     d42:	444b      	add	r3, r9
     d44:	799a      	ldrb	r2, [r3, #6]
     d46:	0049      	lsls	r1, r1, #1
     d48:	0053      	lsls	r3, r2, #1
     d4a:	189b      	adds	r3, r3, r2
     d4c:	005b      	lsls	r3, r3, #1
     d4e:	444b      	add	r3, r9
     d50:	185b      	adds	r3, r3, r1
     d52:	2208      	movs	r2, #8
     d54:	5e9b      	ldrsh	r3, [r3, r2]
     d56:	42b3      	cmp	r3, r6
     d58:	da9e      	bge.n	c98 <_ZN8Renderer5SortYEii+0x580>
                i++;
     d5a:	9a0f      	ldr	r2, [sp, #60]
     d5c:	a90f      	add	r1, sp, #60
     d5e:	3201      	adds	r2, #1
     d60:	920f      	str	r2, [sp, #60]
     d62:	780b      	ldrb	r3, [r1, #0]
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
     d64:	1c1d      	adds	r5, r3, #0
     d66:	3590      	adds	r5, #144
     d68:	00ab      	lsls	r3, r5, #2
     d6a:	444b      	add	r3, r9
     d6c:	799a      	ldrb	r2, [r3, #6]
     d6e:	0053      	lsls	r3, r2, #1
     d70:	189b      	adds	r3, r3, r2
     d72:	005b      	lsls	r3, r3, #1
     d74:	22fc      	movs	r2, #252
     d76:	444b      	add	r3, r9
     d78:	0052      	lsls	r2, r2, #1
     d7a:	189b      	adds	r3, r3, r2
     d7c:	2108      	movs	r1, #8
     d7e:	5e5b      	ldrsh	r3, [r3, r1]
     d80:	42b3      	cmp	r3, r6
     d82:	dbea      	blt.n	d5a <_ZN8Renderer5SortYEii+0x642>
     d84:	e788      	b.n	c98 <_ZN8Renderer5SortYEii+0x580>
                i++;
            while (TriangleMinY(j) > pivot)
                j--;
     d86:	2301      	movs	r3, #1
     d88:	425b      	negs	r3, r3
     d8a:	449a      	add	sl, r3

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
                i++;
            while (TriangleMinY(j) > pivot)
     d8c:	4652      	mov	r2, sl
     d8e:	b2d3      	uxtb	r3, r2
     d90:	1c1c      	adds	r4, r3, #0
     d92:	3490      	adds	r4, #144
     d94:	00a3      	lsls	r3, r4, #2
     d96:	444b      	add	r3, r9
     d98:	799a      	ldrb	r2, [r3, #6]
     d9a:	0053      	lsls	r3, r2, #1
     d9c:	189b      	adds	r3, r3, r2
     d9e:	005b      	lsls	r3, r3, #1
     da0:	22fc      	movs	r2, #252
     da2:	0052      	lsls	r2, r2, #1
     da4:	444b      	add	r3, r9
     da6:	189b      	adds	r3, r3, r2
     da8:	2208      	movs	r2, #8
     daa:	5e9b      	ldrsh	r3, [r3, r2]
     dac:	42b3      	cmp	r3, r6
     dae:	dcea      	bgt.n	d86 <_ZN8Renderer5SortYEii+0x66e>
                j--;
            if (i <= j)
     db0:	45d3      	cmp	fp, sl
     db2:	dc00      	bgt.n	db6 <_ZN8Renderer5SortYEii+0x69e>
     db4:	e096      	b.n	ee4 <_ZN8Renderer5SortYEii+0x7cc>
    {
        int i = left;
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
     db6:	45da      	cmp	sl, fp
     db8:	da26      	bge.n	e08 <_ZN8Renderer5SortYEii+0x6f0>
                i++;
                j--;
            }
        }

        if (left < j)
     dba:	9b01      	ldr	r3, [sp, #4]
     dbc:	4553      	cmp	r3, sl
     dbe:	db4e      	blt.n	e5e <_ZN8Renderer5SortYEii+0x746>
            SortY(left, j);
        if (i < right)
     dc0:	990e      	ldr	r1, [sp, #56]
     dc2:	4559      	cmp	r1, fp
     dc4:	dd98      	ble.n	cf8 <_ZN8Renderer5SortYEii+0x5e0>
     dc6:	465a      	mov	r2, fp
     dc8:	990e      	ldr	r1, [sp, #56]
     dca:	9201      	str	r2, [sp, #4]
        dst->z = v.z;
    }

    short TriangleMinY(byte ti)
    {
        return _vertexes[_triangles[ti].p0].y;
     dcc:	9a01      	ldr	r2, [sp, #4]
     dce:	1853      	adds	r3, r2, r1
     dd0:	105b      	asrs	r3, r3, #1
     dd2:	b2db      	uxtb	r3, r3
     dd4:	3390      	adds	r3, #144
     dd6:	009b      	lsls	r3, r3, #2
     dd8:	444b      	add	r3, r9
     dda:	799a      	ldrb	r2, [r3, #6]
     ddc:	9901      	ldr	r1, [sp, #4]
     dde:	0053      	lsls	r3, r2, #1
     de0:	189b      	adds	r3, r3, r2
     de2:	005b      	lsls	r3, r3, #1
     de4:	22fc      	movs	r2, #252
     de6:	0052      	lsls	r2, r2, #1
     de8:	444b      	add	r3, r9
     dea:	189b      	adds	r3, r3, r2
     dec:	9a0e      	ldr	r2, [sp, #56]
     dee:	468b      	mov	fp, r1
     df0:	2108      	movs	r1, #8
     df2:	5e5e      	ldrsh	r6, [r3, r1]
     df4:	4692      	mov	sl, r2
    {
        int i = left;
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
     df6:	45d3      	cmp	fp, sl
     df8:	dcdf      	bgt.n	dba <_ZN8Renderer5SortYEii+0x6a2>
     dfa:	465a      	mov	r2, fp
     dfc:	b2d1      	uxtb	r1, r2
     dfe:	e003      	b.n	e08 <_ZN8Renderer5SortYEii+0x6f0>
        {
            while (TriangleMinY(i) < pivot)
                i++;
     e00:	2201      	movs	r2, #1
     e02:	4493      	add	fp, r2
     e04:	465b      	mov	r3, fp
     e06:	b2d9      	uxtb	r1, r3
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
     e08:	1c0d      	adds	r5, r1, #0
     e0a:	3590      	adds	r5, #144
     e0c:	00ab      	lsls	r3, r5, #2
     e0e:	444b      	add	r3, r9
     e10:	799a      	ldrb	r2, [r3, #6]
     e12:	0053      	lsls	r3, r2, #1
     e14:	189b      	adds	r3, r3, r2
     e16:	005b      	lsls	r3, r3, #1
     e18:	22fc      	movs	r2, #252
     e1a:	0052      	lsls	r2, r2, #1
     e1c:	444b      	add	r3, r9
     e1e:	189b      	adds	r3, r3, r2
     e20:	2208      	movs	r2, #8
     e22:	5e9b      	ldrsh	r3, [r3, r2]
     e24:	42b3      	cmp	r3, r6
     e26:	dbeb      	blt.n	e00 <_ZN8Renderer5SortYEii+0x6e8>
     e28:	e7b0      	b.n	d8c <_ZN8Renderer5SortYEii+0x674>
                i++;
            while (TriangleMinY(j) > pivot)
                j--;
     e2a:	3e01      	subs	r6, #1

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
                i++;
            while (TriangleMinY(j) > pivot)
     e2c:	b2f3      	uxtb	r3, r6
     e2e:	1c1c      	adds	r4, r3, #0
     e30:	3490      	adds	r4, #144
     e32:	00a3      	lsls	r3, r4, #2
     e34:	444b      	add	r3, r9
     e36:	799a      	ldrb	r2, [r3, #6]
     e38:	21fc      	movs	r1, #252
     e3a:	0053      	lsls	r3, r2, #1
     e3c:	189b      	adds	r3, r3, r2
     e3e:	005b      	lsls	r3, r3, #1
     e40:	444b      	add	r3, r9
     e42:	0049      	lsls	r1, r1, #1
     e44:	185b      	adds	r3, r3, r1
     e46:	2208      	movs	r2, #8
     e48:	5e9b      	ldrsh	r3, [r3, r2]
     e4a:	4543      	cmp	r3, r8
     e4c:	dced      	bgt.n	e2a <_ZN8Renderer5SortYEii+0x712>
                j--;
            if (i <= j)
     e4e:	42b7      	cmp	r7, r6
     e50:	dd30      	ble.n	eb4 <_ZN8Renderer5SortYEii+0x79c>
                i++;
                j--;
            }
        }

        if (left < j)
     e52:	9b01      	ldr	r3, [sp, #4]
     e54:	42b3      	cmp	r3, r6
     e56:	db7e      	blt.n	f56 <_ZN8Renderer5SortYEii+0x83e>
            SortY(left, j);
        if (i < right)
     e58:	45ba      	cmp	sl, r7
     e5a:	ddb1      	ble.n	dc0 <_ZN8Renderer5SortYEii+0x6a8>
     e5c:	9701      	str	r7, [sp, #4]
        dst->z = v.z;
    }

    short TriangleMinY(byte ti)
    {
        return _vertexes[_triangles[ti].p0].y;
     e5e:	9901      	ldr	r1, [sp, #4]
     e60:	4656      	mov	r6, sl
     e62:	1c0b      	adds	r3, r1, #0
     e64:	4453      	add	r3, sl
     e66:	105b      	asrs	r3, r3, #1
     e68:	b2db      	uxtb	r3, r3
     e6a:	3390      	adds	r3, #144
     e6c:	009b      	lsls	r3, r3, #2
     e6e:	444b      	add	r3, r9
     e70:	799a      	ldrb	r2, [r3, #6]
     e72:	1c0f      	adds	r7, r1, #0
     e74:	0053      	lsls	r3, r2, #1
     e76:	189b      	adds	r3, r3, r2
     e78:	005b      	lsls	r3, r3, #1
     e7a:	22fc      	movs	r2, #252
     e7c:	0052      	lsls	r2, r2, #1
     e7e:	444b      	add	r3, r9
     e80:	189b      	adds	r3, r3, r2
     e82:	2208      	movs	r2, #8
     e84:	5e99      	ldrsh	r1, [r3, r2]
     e86:	4688      	mov	r8, r1
    {
        int i = left;
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
     e88:	42b7      	cmp	r7, r6
     e8a:	dd01      	ble.n	e90 <_ZN8Renderer5SortYEii+0x778>
     e8c:	e7e1      	b.n	e52 <_ZN8Renderer5SortYEii+0x73a>
        {
            while (TriangleMinY(i) < pivot)
                i++;
     e8e:	3701      	adds	r7, #1
     e90:	b2fb      	uxtb	r3, r7
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
     e92:	1c1d      	adds	r5, r3, #0
     e94:	3590      	adds	r5, #144
     e96:	00ab      	lsls	r3, r5, #2
     e98:	444b      	add	r3, r9
     e9a:	799a      	ldrb	r2, [r3, #6]
     e9c:	21fc      	movs	r1, #252
     e9e:	0053      	lsls	r3, r2, #1
     ea0:	189b      	adds	r3, r3, r2
     ea2:	005b      	lsls	r3, r3, #1
     ea4:	444b      	add	r3, r9
     ea6:	0049      	lsls	r1, r1, #1
     ea8:	185b      	adds	r3, r3, r1
     eaa:	2208      	movs	r2, #8
     eac:	5e9b      	ldrsh	r3, [r3, r2]
     eae:	4543      	cmp	r3, r8
     eb0:	dbed      	blt.n	e8e <_ZN8Renderer5SortYEii+0x776>
     eb2:	e7bb      	b.n	e2c <_ZN8Renderer5SortYEii+0x714>
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
     eb4:	00ad      	lsls	r5, r5, #2
     eb6:	444d      	add	r5, r9
        t[i] = t[j];
     eb8:	00a4      	lsls	r4, r4, #2
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
     eba:	3506      	adds	r5, #6
        t[i] = t[j];
     ebc:	444c      	add	r4, r9
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
     ebe:	1c29      	adds	r1, r5, #0
     ec0:	2204      	movs	r2, #4
        t[i] = t[j];
     ec2:	3406      	adds	r4, #6
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
     ec4:	a811      	add	r0, sp, #68
     ec6:	f001 fff7 	bl	2eb8 <memcpy>
        t[i] = t[j];
     eca:	1c21      	adds	r1, r4, #0
     ecc:	2204      	movs	r2, #4
     ece:	1c28      	adds	r0, r5, #0
     ed0:	f001 fff2 	bl	2eb8 <memcpy>
        t[j] = tmp;
     ed4:	1c20      	adds	r0, r4, #0
     ed6:	a911      	add	r1, sp, #68
     ed8:	2204      	movs	r2, #4
     eda:	f001 ffed 	bl	2eb8 <memcpy>
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
     ede:	3701      	adds	r7, #1
                j--;
     ee0:	3e01      	subs	r6, #1
     ee2:	e7d1      	b.n	e88 <_ZN8Renderer5SortYEii+0x770>
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
     ee4:	00ad      	lsls	r5, r5, #2
     ee6:	444d      	add	r5, r9
        t[i] = t[j];
     ee8:	00a4      	lsls	r4, r4, #2
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
     eea:	3506      	adds	r5, #6
        t[i] = t[j];
     eec:	444c      	add	r4, r9
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
     eee:	1c29      	adds	r1, r5, #0
     ef0:	2204      	movs	r2, #4
        t[i] = t[j];
     ef2:	3406      	adds	r4, #6
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
     ef4:	a811      	add	r0, sp, #68
     ef6:	f001 ffdf 	bl	2eb8 <memcpy>
        t[i] = t[j];
     efa:	1c21      	adds	r1, r4, #0
     efc:	2204      	movs	r2, #4
     efe:	1c28      	adds	r0, r5, #0
     f00:	f001 ffda 	bl	2eb8 <memcpy>
        t[j] = tmp;
     f04:	a911      	add	r1, sp, #68
     f06:	1c20      	adds	r0, r4, #0
     f08:	2204      	movs	r2, #4
     f0a:	f001 ffd5 	bl	2eb8 <memcpy>
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
                j--;
     f0e:	2101      	movs	r1, #1
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
     f10:	2301      	movs	r3, #1
                j--;
     f12:	4249      	negs	r1, r1
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
     f14:	449b      	add	fp, r3
                j--;
     f16:	448a      	add	sl, r1
     f18:	e76d      	b.n	df6 <_ZN8Renderer5SortYEii+0x6de>
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
     f1a:	00ad      	lsls	r5, r5, #2
     f1c:	444d      	add	r5, r9
        t[i] = t[j];
     f1e:	00a4      	lsls	r4, r4, #2
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
     f20:	3506      	adds	r5, #6
        t[i] = t[j];
     f22:	444c      	add	r4, r9
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
     f24:	1c29      	adds	r1, r5, #0
     f26:	2204      	movs	r2, #4
        t[i] = t[j];
     f28:	3406      	adds	r4, #6
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
     f2a:	a811      	add	r0, sp, #68
     f2c:	f001 ffc4 	bl	2eb8 <memcpy>
        t[i] = t[j];
     f30:	1c21      	adds	r1, r4, #0
     f32:	2204      	movs	r2, #4
     f34:	1c28      	adds	r0, r5, #0
     f36:	f001 ffbf 	bl	2eb8 <memcpy>
        t[j] = tmp;
     f3a:	a911      	add	r1, sp, #68
     f3c:	2204      	movs	r2, #4
     f3e:	1c20      	adds	r0, r4, #0
     f40:	f001 ffba 	bl	2eb8 <memcpy>
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
                j--;
     f44:	9a0e      	ldr	r2, [sp, #56]
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
     f46:	990f      	ldr	r1, [sp, #60]
                j--;
     f48:	3a01      	subs	r2, #1
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
     f4a:	3101      	adds	r1, #1
                j--;
     f4c:	920e      	str	r2, [sp, #56]
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
     f4e:	910f      	str	r1, [sp, #60]
     f50:	1c0b      	adds	r3, r1, #0
     f52:	990e      	ldr	r1, [sp, #56]
     f54:	e6ed      	b.n	d32 <_ZN8Renderer5SortYEii+0x61a>
                j--;
            }
        }

        if (left < j)
            SortY(left, j);
     f56:	4648      	mov	r0, r9
     f58:	1c19      	adds	r1, r3, #0
     f5a:	1c32      	adds	r2, r6, #0
     f5c:	f7ff fbdc 	bl	718 <_ZN8Renderer5SortYEii>
     f60:	e77a      	b.n	e58 <_ZN8Renderer5SortYEii+0x740>
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
     f62:	00ad      	lsls	r5, r5, #2
     f64:	444d      	add	r5, r9
        t[i] = t[j];
     f66:	00a4      	lsls	r4, r4, #2
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
     f68:	3506      	adds	r5, #6
        t[i] = t[j];
     f6a:	444c      	add	r4, r9
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
     f6c:	1c29      	adds	r1, r5, #0
     f6e:	2204      	movs	r2, #4
        t[i] = t[j];
     f70:	3406      	adds	r4, #6
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
     f72:	a811      	add	r0, sp, #68
     f74:	f001 ffa0 	bl	2eb8 <memcpy>
        t[i] = t[j];
     f78:	1c21      	adds	r1, r4, #0
     f7a:	2204      	movs	r2, #4
     f7c:	1c28      	adds	r0, r5, #0
     f7e:	f001 ff9b 	bl	2eb8 <memcpy>
        t[j] = tmp;
     f82:	a911      	add	r1, sp, #68
     f84:	2204      	movs	r2, #4
     f86:	1c20      	adds	r0, r4, #0
     f88:	f001 ff96 	bl	2eb8 <memcpy>
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
                j--;
     f8c:	9a0d      	ldr	r2, [sp, #52]
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
     f8e:	990c      	ldr	r1, [sp, #48]
                j--;
     f90:	3a01      	subs	r2, #1
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
     f92:	3101      	adds	r1, #1
                j--;
     f94:	920d      	str	r2, [sp, #52]
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
     f96:	910c      	str	r1, [sp, #48]
     f98:	1c0b      	adds	r3, r1, #0
     f9a:	990d      	ldr	r1, [sp, #52]
     f9c:	e652      	b.n	c44 <_ZN8Renderer5SortYEii+0x52c>
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
     f9e:	00ad      	lsls	r5, r5, #2
     fa0:	444d      	add	r5, r9
        t[i] = t[j];
     fa2:	00a4      	lsls	r4, r4, #2
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
     fa4:	3506      	adds	r5, #6
        t[i] = t[j];
     fa6:	444c      	add	r4, r9
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
     fa8:	1c29      	adds	r1, r5, #0
     faa:	2204      	movs	r2, #4
        t[i] = t[j];
     fac:	3406      	adds	r4, #6
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
     fae:	a811      	add	r0, sp, #68
     fb0:	f001 ff82 	bl	2eb8 <memcpy>
        t[i] = t[j];
     fb4:	1c21      	adds	r1, r4, #0
     fb6:	2204      	movs	r2, #4
     fb8:	1c28      	adds	r0, r5, #0
     fba:	f001 ff7d 	bl	2eb8 <memcpy>
        t[j] = tmp;
     fbe:	1c20      	adds	r0, r4, #0
     fc0:	a911      	add	r1, sp, #68
     fc2:	2204      	movs	r2, #4
     fc4:	f001 ff78 	bl	2eb8 <memcpy>
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
                j--;
     fc8:	9b0b      	ldr	r3, [sp, #44]
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
     fca:	3601      	adds	r6, #1
                j--;
     fcc:	3b01      	subs	r3, #1
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
     fce:	960a      	str	r6, [sp, #40]
                j--;
     fd0:	930b      	str	r3, [sp, #44]
     fd2:	e5d0      	b.n	b76 <_ZN8Renderer5SortYEii+0x45e>
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
     fd4:	00ad      	lsls	r5, r5, #2
     fd6:	444d      	add	r5, r9
        t[i] = t[j];
     fd8:	00a4      	lsls	r4, r4, #2
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
     fda:	3506      	adds	r5, #6
        t[i] = t[j];
     fdc:	444c      	add	r4, r9
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
     fde:	1c29      	adds	r1, r5, #0
     fe0:	2204      	movs	r2, #4
        t[i] = t[j];
     fe2:	3406      	adds	r4, #6
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
     fe4:	a811      	add	r0, sp, #68
     fe6:	f001 ff67 	bl	2eb8 <memcpy>
        t[i] = t[j];
     fea:	1c21      	adds	r1, r4, #0
     fec:	2204      	movs	r2, #4
     fee:	1c28      	adds	r0, r5, #0
     ff0:	f001 ff62 	bl	2eb8 <memcpy>
        t[j] = tmp;
     ff4:	a911      	add	r1, sp, #68
     ff6:	1c20      	adds	r0, r4, #0
     ff8:	2204      	movs	r2, #4
     ffa:	f001 ff5d 	bl	2eb8 <memcpy>
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
     ffe:	9b08      	ldr	r3, [sp, #32]
                j--;
    1000:	9909      	ldr	r1, [sp, #36]
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
    1002:	3301      	adds	r3, #1
                j--;
    1004:	3901      	subs	r1, #1
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
    1006:	9308      	str	r3, [sp, #32]
                j--;
    1008:	9109      	str	r1, [sp, #36]
    100a:	e54f      	b.n	aac <_ZN8Renderer5SortYEii+0x394>
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
    100c:	9808      	ldr	r0, [sp, #32]
    100e:	e4fe      	b.n	a0e <_ZN8Renderer5SortYEii+0x2f6>
                i++;
            while (TriangleMinY(j) > pivot)
    1010:	9909      	ldr	r1, [sp, #36]
    1012:	e524      	b.n	a5e <_ZN8Renderer5SortYEii+0x346>

00001014 <_Z13DrawTrianglesiPhi>:
};

#endif

void Sampler(short countdown);
void DrawTriangles(int keys, byte* appBuffer, int len)
    1014:	b5f0      	push	{r4, r5, r6, r7, lr}
    1016:	465f      	mov	r7, fp
    1018:	4656      	mov	r6, sl
    101a:	464d      	mov	r5, r9
    101c:	4644      	mov	r4, r8
    101e:	b4f0      	push	{r4, r5, r6, r7}
{    
    ModelState* m = (ModelState*)appBuffer;
	int i = (_model++ >> 8) & 3;
    1020:	4cdf      	ldr	r4, [pc, #892]	(13a0 <_Z13DrawTrianglesiPhi+0x38c>)
};

#endif

void Sampler(short countdown);
void DrawTriangles(int keys, byte* appBuffer, int len)
    1022:	b0c5      	sub	sp, #276
{    
    ModelState* m = (ModelState*)appBuffer;
	int i = (_model++ >> 8) & 3;
    1024:	6823      	ldr	r3, [r4, #0]
};

#endif

void Sampler(short countdown);
void DrawTriangles(int keys, byte* appBuffer, int len)
    1026:	910b      	str	r1, [sp, #44]
{    
    ModelState* m = (ModelState*)appBuffer;
	int i = (_model++ >> 8) & 3;
    1028:	059a      	lsls	r2, r3, #22
    102a:	0f92      	lsrs	r2, r2, #30
    102c:	3301      	adds	r3, #1
    102e:	6023      	str	r3, [r4, #0]
	_hackyColor = i+3;
    1030:	1cd3      	adds	r3, r2, #3
    1032:	6063      	str	r3, [r4, #4]
	const Model* model = _models[i];
    1034:	4bdb      	ldr	r3, [pc, #876]	(13a4 <_Z13DrawTrianglesiPhi+0x390>)
    1036:	0092      	lsls	r2, r2, #2
    1038:	189b      	adds	r3, r3, r2
    103a:	69db      	ldr	r3, [r3, #28]
	m->Draw(keys,(Triangle*)model->Triangles,model->TriangleCount,(Vec3Char*)model->Vertexes,model->VertexCount);
    103c:	ae09      	add	r6, sp, #36
    103e:	68da      	ldr	r2, [r3, #12]
    1040:	6859      	ldr	r1, [r3, #4]
    1042:	9209      	str	r2, [sp, #36]
    1044:	7836      	ldrb	r6, [r6, #0]
    1046:	9108      	str	r1, [sp, #32]
    1048:	689f      	ldr	r7, [r3, #8]
    104a:	6819      	ldr	r1, [r3, #0]
    short _bottom;
    Renderer _r;
   
    void Key(short key)
    {
     	if ((_phase++ & 0xFF) == 0)
    104c:	9b0b      	ldr	r3, [sp, #44]
{    
    ModelState* m = (ModelState*)appBuffer;
	int i = (_model++ >> 8) & 3;
	_hackyColor = i+3;
	const Model* model = _models[i];
	m->Draw(keys,(Triangle*)model->Triangles,model->TriangleCount,(Vec3Char*)model->Vertexes,model->VertexCount);
    104e:	960a      	str	r6, [sp, #40]
    short _bottom;
    Renderer _r;
   
    void Key(short key)
    {
     	if ((_phase++ & 0xFF) == 0)
    1050:	7b1a      	ldrb	r2, [r3, #12]
    1052:	9e0b      	ldr	r6, [sp, #44]
    1054:	1c53      	adds	r3, r2, #1
{    
    ModelState* m = (ModelState*)appBuffer;
	int i = (_model++ >> 8) & 3;
	_hackyColor = i+3;
	const Model* model = _models[i];
	m->Draw(keys,(Triangle*)model->Triangles,model->TriangleCount,(Vec3Char*)model->Vertexes,model->VertexCount);
    1056:	b280      	uxth	r0, r0
    1058:	4689      	mov	r9, r1
    short _bottom;
    Renderer _r;
   
    void Key(short key)
    {
     	if ((_phase++ & 0xFF) == 0)
    105a:	7333      	strb	r3, [r6, #12]
    105c:	2a00      	cmp	r2, #0
    105e:	d102      	bne.n	1066 <_Z13DrawTrianglesiPhi+0x52>
     		_zdst = FARZ;	// Trigger zoom away
    1060:	23a0      	movs	r3, #160
    1062:	041b      	lsls	r3, r3, #16
    1064:	60b3      	str	r3, [r6, #8]

        if (key == 1 || key == 0x80)
    1066:	b202      	sxth	r2, r0
    1068:	1c13      	adds	r3, r2, #0
    106a:	3b80      	subs	r3, #128
    106c:	4259      	negs	r1, r3
    106e:	4159      	adcs	r1, r3
    1070:	2a01      	cmp	r2, #1
    1072:	d100      	bne.n	1076 <_Z13DrawTrianglesiPhi+0x62>
    1074:	e0e4      	b.n	1240 <_Z13DrawTrianglesiPhi+0x22c>
    1076:	2900      	cmp	r1, #0
    1078:	d000      	beq.n	107c <_Z13DrawTrianglesiPhi+0x68>
    107a:	e0e3      	b.n	1244 <_Z13DrawTrianglesiPhi+0x230>
    
    void Rotate()
    {
        #if 1
    	int x,y;
    	if (ReadXY(&y,&x) & 1)
    107c:	a842      	add	r0, sp, #264
    107e:	a943      	add	r1, sp, #268
    1080:	f7ff f89a 	bl	1b8 <ReadXY>
    1084:	07c3      	lsls	r3, r0, #31
    1086:	d504      	bpl.n	1092 <_Z13DrawTrianglesiPhi+0x7e>
    		_model = (_model + 0xFF) & ~0xFF;
    1088:	6823      	ldr	r3, [r4, #0]
    108a:	22ff      	movs	r2, #255
    108c:	33ff      	adds	r3, #255
    108e:	4393      	bics	r3, r2
    1090:	6023      	str	r3, [r4, #0]
#define FARZ (160L << FPP)
#define NEARZ (16L << FPP)

inline int DELTA(int x)
{
	x = (x - 512) >> 5;
    1092:	9b43      	ldr	r3, [sp, #268]
    1094:	4ec4      	ldr	r6, [pc, #784]	(13a8 <_Z13DrawTrianglesiPhi+0x394>)
    {
        #if 1
    	int x,y;
    	if (ReadXY(&y,&x) & 1)
    		_model = (_model + 0xFF) & ~0xFF;
    	_rotX += DELTA(x);
    1096:	9c0b      	ldr	r4, [sp, #44]
#define FARZ (160L << FPP)
#define NEARZ (16L << FPP)

inline int DELTA(int x)
{
	x = (x - 512) >> 5;
    1098:	199b      	adds	r3, r3, r6
    109a:	115b      	asrs	r3, r3, #5
	bool sign = x < 0;
    109c:	0fda      	lsrs	r2, r3, #31
    {
        #if 1
    	int x,y;
    	if (ReadXY(&y,&x) & 1)
    		_model = (_model + 0xFF) & ~0xFF;
    	_rotX += DELTA(x);
    109e:	7b61      	ldrb	r1, [r4, #13]

inline int DELTA(int x)
{
	x = (x - 512) >> 5;
	bool sign = x < 0;
	if (sign)
    10a0:	2a00      	cmp	r2, #0
    10a2:	d000      	beq.n	10a6 <_Z13DrawTrianglesiPhi+0x92>
		x = -x;
    10a4:	425b      	negs	r3, r3
	x -= 3;	// deadzone
    10a6:	3b03      	subs	r3, #3
	if (x <= 0)
    10a8:	2b00      	cmp	r3, #0
    10aa:	dc00      	bgt.n	10ae <_Z13DrawTrianglesiPhi+0x9a>
    10ac:	e0dc      	b.n	1268 <_Z13DrawTrianglesiPhi+0x254>
		return 0;
	return sign ? -x : x;
    10ae:	2a00      	cmp	r2, #0
    10b0:	d000      	beq.n	10b4 <_Z13DrawTrianglesiPhi+0xa0>
    10b2:	425b      	negs	r3, r3
    10b4:	b2db      	uxtb	r3, r3
    {
        #if 1
    	int x,y;
    	if (ReadXY(&y,&x) & 1)
    		_model = (_model + 0xFF) & ~0xFF;
    	_rotX += DELTA(x);
    10b6:	980b      	ldr	r0, [sp, #44]
    10b8:	185b      	adds	r3, r3, r1
    10ba:	7343      	strb	r3, [r0, #13]
#define FARZ (160L << FPP)
#define NEARZ (16L << FPP)

inline int DELTA(int x)
{
	x = (x - 512) >> 5;
    10bc:	4aba      	ldr	r2, [pc, #744]	(13a8 <_Z13DrawTrianglesiPhi+0x394>)
    10be:	9b42      	ldr	r3, [sp, #264]
        #if 1
    	int x,y;
    	if (ReadXY(&y,&x) & 1)
    		_model = (_model + 0xFF) & ~0xFF;
    	_rotX += DELTA(x);
    	_rotY += DELTA(y);
    10c0:	7b81      	ldrb	r1, [r0, #14]
#define FARZ (160L << FPP)
#define NEARZ (16L << FPP)

inline int DELTA(int x)
{
	x = (x - 512) >> 5;
    10c2:	189b      	adds	r3, r3, r2
    10c4:	115b      	asrs	r3, r3, #5
	bool sign = x < 0;
    10c6:	0fda      	lsrs	r2, r3, #31
	if (sign)
    10c8:	2a00      	cmp	r2, #0
    10ca:	d000      	beq.n	10ce <_Z13DrawTrianglesiPhi+0xba>
		x = -x;
    10cc:	425b      	negs	r3, r3
	x -= 3;	// deadzone
    10ce:	3b03      	subs	r3, #3
	if (x <= 0)
    10d0:	2b00      	cmp	r3, #0
    10d2:	dc00      	bgt.n	10d6 <_Z13DrawTrianglesiPhi+0xc2>
    10d4:	e0b2      	b.n	123c <_Z13DrawTrianglesiPhi+0x228>
		return 0;
	return sign ? -x : x;
    10d6:	2a00      	cmp	r2, #0
    10d8:	d000      	beq.n	10dc <_Z13DrawTrianglesiPhi+0xc8>
    10da:	425b      	negs	r3, r3
    10dc:	b2db      	uxtb	r3, r3
        #if 1
    	int x,y;
    	if (ReadXY(&y,&x) & 1)
    		_model = (_model + 0xFF) & ~0xFF;
    	_rotX += DELTA(x);
    	_rotY += DELTA(y);
    10de:	9c0b      	ldr	r4, [sp, #44]
#define FPI(x)		((x)<<FPP)

class Matrix
{
public:
	Matrix () { Identity (); }
    10e0:	ad2f      	add	r5, sp, #188
    10e2:	185b      	adds	r3, r3, r1
    10e4:	73a3      	strb	r3, [r4, #14]
    10e6:	1c28      	adds	r0, r5, #0
    10e8:	f001 fda4 	bl	2c34 <_ZN6Matrix8IdentityEv>
    Vec3    _vertexes[MAXVERTEXES];    
    Triangle _triangles[MAXTRIANGLES];
        
    void Init()
    {
        _vertexCount = _triangleCount = 0;
    10ec:	4eaf      	ldr	r6, [pc, #700]	(13ac <_Z13DrawTrianglesiPhi+0x398>)
    10ee:	208b      	movs	r0, #139
        memset(_triangles,0x69,sizeof(_triangles));
    10f0:	4aaf      	ldr	r2, [pc, #700]	(13b0 <_Z13DrawTrianglesiPhi+0x39c>)
    Vec3    _vertexes[MAXVERTEXES];    
    Triangle _triangles[MAXTRIANGLES];
        
    void Init()
    {
        _vertexCount = _triangleCount = 0;
    10f2:	2300      	movs	r3, #0
    10f4:	0081      	lsls	r1, r0, #2
    10f6:	55a3      	strb	r3, [r4, r6]
    10f8:	5463      	strb	r3, [r4, r1]
        memset(_triangles,0x69,sizeof(_triangles));
    10fa:	18a0      	adds	r0, r4, r2
    Vec3    _vertexes[MAXVERTEXES];    
    Triangle _triangles[MAXTRIANGLES];
        
    void Init()
    {
        _vertexCount = _triangleCount = 0;
    10fc:	468b      	mov	fp, r1
        memset(_triangles,0x69,sizeof(_triangles));
    10fe:	2250      	movs	r2, #80
    1100:	2169      	movs	r1, #105
    1102:	f001 fef9 	bl	2ef8 <memset>
        memset(_edges,0x0,sizeof(_edges));
    1106:	3460      	adds	r4, #96
    1108:	22c0      	movs	r2, #192
    110a:	1c20      	adds	r0, r4, #0
    110c:	2100      	movs	r1, #0
    110e:	0052      	lsls	r2, r2, #1
    1110:	940c      	str	r4, [sp, #48]
    1112:	f001 fef1 	bl	2ef8 <memset>
        _head.X = -0x7FFFFFFF;
    1116:	9c0b      	ldr	r4, [sp, #44]
    1118:	4ba6      	ldr	r3, [pc, #664]	(13b4 <_Z13DrawTrianglesiPhi+0x3a0>)
    111a:	63e3      	str	r3, [r4, #60]
        _tail.X = 0x7FFFFFFF;
    111c:	3b02      	subs	r3, #2
    111e:	6563      	str	r3, [r4, #84]
    1120:	ac1f      	add	r4, sp, #124
    1122:	1c20      	adds	r0, r4, #0
    1124:	f001 fd86 	bl	2c34 <_ZN6Matrix8IdentityEv>
        
        Matrix matrix;
        _r.Init();
        {
            Matrix m;
            matrix.Translate(0,  FPI(0L), _z);
    1128:	980b      	ldr	r0, [sp, #44]
    112a:	2100      	movs	r1, #0
    112c:	6803      	ldr	r3, [r0, #0]
    112e:	2200      	movs	r2, #0
    1130:	1c28      	adds	r0, r5, #0
    1132:	f001 fd21 	bl	2b78 <_ZN6Matrix9TranslateElll>
            m.RotateX(_rotX);
    1136:	9a0b      	ldr	r2, [sp, #44]
    1138:	1c20      	adds	r0, r4, #0
    113a:	7b51      	ldrb	r1, [r2, #13]
    113c:	f001 fe2c 	bl	2d98 <_ZN6Matrix7RotateXEi>
            matrix.Concatenate(m);
    1140:	1c21      	adds	r1, r4, #0
    1142:	1c28      	adds	r0, r5, #0
    1144:	f001 fd84 	bl	2c50 <_ZN6Matrix11ConcatenateERS_>
            m.RotateY(_rotY);
    1148:	9b0b      	ldr	r3, [sp, #44]
    114a:	1c20      	adds	r0, r4, #0
    114c:	7b99      	ldrb	r1, [r3, #14]
    114e:	f001 fe0f 	bl	2d70 <_ZN6Matrix7RotateYEi>
            matrix.Concatenate(m);
    1152:	1c21      	adds	r1, r4, #0
    1154:	1c28      	adds	r0, r5, #0
    1156:	f001 fd7b 	bl	2c50 <_ZN6Matrix11ConcatenateERS_>
            m.RotateZ(_rotZ);
    115a:	980b      	ldr	r0, [sp, #44]
    115c:	7bc1      	ldrb	r1, [r0, #15]
    115e:	1c20      	adds	r0, r4, #0
    1160:	f001 fdf2 	bl	2d48 <_ZN6Matrix7RotateZEi>
            matrix.Concatenate(m);
    1164:	1c21      	adds	r1, r4, #0
    1166:	1c28      	adds	r0, r5, #0
    1168:	f001 fd72 	bl	2c50 <_ZN6Matrix11ConcatenateERS_>
        _tail.X = 0x7FFFFFFF;
    }
    
    void SetMatrix(const Matrix& m)
    {
		_matrix = m;
    116c:	990b      	ldr	r1, [sp, #44]
    116e:	22f6      	movs	r2, #246
    1170:	0052      	lsls	r2, r2, #1
    1172:	188a      	adds	r2, r1, r2
    1174:	9207      	str	r2, [sp, #28]
    1176:	1c10      	adds	r0, r2, #0
    1178:	1c29      	adds	r1, r5, #0
    117a:	2240      	movs	r2, #64
    117c:	f001 fe9c 	bl	2eb8 <memcpy>
            SortY(i, right);
    }
        
    bool AddTriangles(Triangle* tris, byte tcount, Vec3Char* p, byte pcount)
    {
        if (tcount + _triangleCount > MAXTRIANGLES || pcount + _vertexCount > MAXVERTEXES)
    1180:	9b0b      	ldr	r3, [sp, #44]
    1182:	9c0a      	ldr	r4, [sp, #40]
    1184:	5d9e      	ldrb	r6, [r3, r6]
    1186:	1c23      	adds	r3, r4, #0
    1188:	46b0      	mov	r8, r6
    118a:	4443      	add	r3, r8
    118c:	1c32      	adds	r2, r6, #0
    118e:	2b14      	cmp	r3, #20
    1190:	dd00      	ble.n	1194 <_Z13DrawTrianglesiPhi+0x180>
    1192:	e0e2      	b.n	135a <_Z13DrawTrianglesiPhi+0x346>
    1194:	9e0b      	ldr	r6, [sp, #44]
    1196:	4658      	mov	r0, fp
    1198:	5c36      	ldrb	r6, [r6, r0]
{    
    ModelState* m = (ModelState*)appBuffer;
	int i = (_model++ >> 8) & 3;
	_hackyColor = i+3;
	const Model* model = _models[i];
	m->Draw(keys,(Triangle*)model->Triangles,model->TriangleCount,(Vec3Char*)model->Vertexes,model->VertexCount);
    119a:	b2ff      	uxtb	r7, r7
    119c:	46ba      	mov	sl, r7
            SortY(i, right);
    }
        
    bool AddTriangles(Triangle* tris, byte tcount, Vec3Char* p, byte pcount)
    {
        if (tcount + _triangleCount > MAXTRIANGLES || pcount + _vertexCount > MAXVERTEXES)
    119e:	1c33      	adds	r3, r6, #0
    11a0:	4453      	add	r3, sl
    11a2:	960e      	str	r6, [sp, #56]
    11a4:	2b0c      	cmp	r3, #12
    11a6:	dd00      	ble.n	11aa <_Z13DrawTrianglesiPhi+0x196>
    11a8:	e0d7      	b.n	135a <_Z13DrawTrianglesiPhi+0x346>
            return false;
        
        //  Copy and transform points
        byte pointMark = _vertexCount;
        for (byte i = 0; i < pcount; i++)
    11aa:	2f00      	cmp	r7, #0
    11ac:	d062      	beq.n	1274 <_Z13DrawTrianglesiPhi+0x260>
    11ae:	22fe      	movs	r2, #254
    {
        Vec3 v;
        v.x = (signed char)src->x;
        v.y = (signed char)src->y;
        v.z = (signed char)src->z;
        _matrix.Transform(v);   // comes out 12:4
    11b0:	2100      	movs	r1, #0
    11b2:	446a      	add	r2, sp
    11b4:	464f      	mov	r7, r9
    11b6:	4690      	mov	r8, r2
    11b8:	4689      	mov	r9, r1
            return false;
        
        //  Copy and transform points
        byte pointMark = _vertexCount;
        for (byte i = 0; i < pcount; i++)
            Project(p + i,_vertexes + _vertexCount++);
    11ba:	9c0b      	ldr	r4, [sp, #44]
    11bc:	1c73      	adds	r3, r6, #1
    11be:	4658      	mov	r0, fp
    11c0:	5423      	strb	r3, [r4, r0]
    }
    
    void Project(Vec3Char* src, Vec3* dst)
    {
        Vec3 v;
        v.x = (signed char)src->x;
    11c2:	2300      	movs	r3, #0
    11c4:	56fb      	ldrsb	r3, [r7, r3]
    11c6:	4641      	mov	r1, r8
    11c8:	800b      	strh	r3, [r1, #0]
        v.y = (signed char)src->y;
    11ca:	2301      	movs	r3, #1
    11cc:	56fb      	ldrsb	r3, [r7, r3]
    11ce:	4642      	mov	r2, r8
    11d0:	8053      	strh	r3, [r2, #2]
        v.z = (signed char)src->z;
    11d2:	2302      	movs	r3, #2
    11d4:	56fb      	ldrsb	r3, [r7, r3]
    11d6:	4644      	mov	r4, r8
    11d8:	80a3      	strh	r3, [r4, #4]
        _matrix.Transform(v);   // comes out 12:4
    11da:	9807      	ldr	r0, [sp, #28]
    11dc:	f001 fcfe 	bl	2bdc <_ZN6Matrix9TransformER4Vec3>
        
        int x = v.x;
        int y = -v.y;
        int inv = 0x8000/v.z;    // short div
    11e0:	4641      	mov	r1, r8
    11e2:	888d      	ldrh	r5, [r1, #4]
        v.y = (signed char)src->y;
        v.z = (signed char)src->z;
        _matrix.Transform(v);   // comes out 12:4
        
        int x = v.x;
        int y = -v.y;
    11e4:	4640      	mov	r0, r8
    11e6:	2402      	movs	r4, #2
    11e8:	5f04      	ldrsh	r4, [r0, r4]
        int inv = 0x8000/v.z;    // short div
    11ea:	2080      	movs	r0, #128
    11ec:	b229      	sxth	r1, r5
    11ee:	0200      	lsls	r0, r0, #8
    11f0:	f001 fef0 	bl	2fd4 <__aeabi_idiv>
        dst->x = (x*inv >> 4) + ((SCREEN_WIDTH>>1) << 4);
    11f4:	0072      	lsls	r2, r6, #1
    11f6:	1992      	adds	r2, r2, r6
    11f8:	9b0b      	ldr	r3, [sp, #44]
    11fa:	0052      	lsls	r2, r2, #1
    11fc:	4641      	mov	r1, r8
    11fe:	189a      	adds	r2, r3, r2
    1200:	2300      	movs	r3, #0
    1202:	5ecb      	ldrsh	r3, [r1, r3]
    1204:	268a      	movs	r6, #138
    1206:	4343      	muls	r3, r0
    1208:	00b6      	lsls	r6, r6, #2
        v.y = (signed char)src->y;
        v.z = (signed char)src->z;
        _matrix.Transform(v);   // comes out 12:4
        
        int x = v.x;
        int y = -v.y;
    120a:	4264      	negs	r4, r4
        int inv = 0x8000/v.z;    // short div
        dst->x = (x*inv >> 4) + ((SCREEN_WIDTH>>1) << 4);
    120c:	1992      	adds	r2, r2, r6
        dst->y = (y*inv >> 4) + ((SCREEN_HEIGHT>>1) << 4);
    120e:	4344      	muls	r4, r0
        _matrix.Transform(v);   // comes out 12:4
        
        int x = v.x;
        int y = -v.y;
        int inv = 0x8000/v.z;    // short div
        dst->x = (x*inv >> 4) + ((SCREEN_WIDTH>>1) << 4);
    1210:	26a0      	movs	r6, #160
    1212:	111b      	asrs	r3, r3, #4
    1214:	0136      	lsls	r6, r6, #4
    1216:	199b      	adds	r3, r3, r6
    1218:	80d3      	strh	r3, [r2, #6]
        dst->y = (y*inv >> 4) + ((SCREEN_HEIGHT>>1) << 4);
    121a:	20f0      	movs	r0, #240
        if (tcount + _triangleCount > MAXTRIANGLES || pcount + _vertexCount > MAXVERTEXES)
            return false;
        
        //  Copy and transform points
        byte pointMark = _vertexCount;
        for (byte i = 0; i < pcount; i++)
    121c:	464b      	mov	r3, r9
        
        int x = v.x;
        int y = -v.y;
        int inv = 0x8000/v.z;    // short div
        dst->x = (x*inv >> 4) + ((SCREEN_WIDTH>>1) << 4);
        dst->y = (y*inv >> 4) + ((SCREEN_HEIGHT>>1) << 4);
    121e:	1124      	asrs	r4, r4, #4
    1220:	00c0      	lsls	r0, r0, #3
        if (tcount + _triangleCount > MAXTRIANGLES || pcount + _vertexCount > MAXVERTEXES)
            return false;
        
        //  Copy and transform points
        byte pointMark = _vertexCount;
        for (byte i = 0; i < pcount; i++)
    1222:	3301      	adds	r3, #1
        
        int x = v.x;
        int y = -v.y;
        int inv = 0x8000/v.z;    // short div
        dst->x = (x*inv >> 4) + ((SCREEN_WIDTH>>1) << 4);
        dst->y = (y*inv >> 4) + ((SCREEN_HEIGHT>>1) << 4);
    1224:	1824      	adds	r4, r4, r0
        if (tcount + _triangleCount > MAXTRIANGLES || pcount + _vertexCount > MAXVERTEXES)
            return false;
        
        //  Copy and transform points
        byte pointMark = _vertexCount;
        for (byte i = 0; i < pcount; i++)
    1226:	b2db      	uxtb	r3, r3
        
        int x = v.x;
        int y = -v.y;
        int inv = 0x8000/v.z;    // short div
        dst->x = (x*inv >> 4) + ((SCREEN_WIDTH>>1) << 4);
        dst->y = (y*inv >> 4) + ((SCREEN_HEIGHT>>1) << 4);
    1228:	8114      	strh	r4, [r2, #8]
        dst->z = v.z;
    122a:	8155      	strh	r5, [r2, #10]
        if (tcount + _triangleCount > MAXTRIANGLES || pcount + _vertexCount > MAXVERTEXES)
            return false;
        
        //  Copy and transform points
        byte pointMark = _vertexCount;
        for (byte i = 0; i < pcount; i++)
    122c:	4699      	mov	r9, r3
    122e:	3703      	adds	r7, #3
    1230:	459a      	cmp	sl, r3
    1232:	d91b      	bls.n	126c <_Z13DrawTrianglesiPhi+0x258>
    1234:	990b      	ldr	r1, [sp, #44]
    1236:	465a      	mov	r2, fp
    1238:	5c8e      	ldrb	r6, [r1, r2]
    123a:	e7be      	b.n	11ba <_Z13DrawTrianglesiPhi+0x1a6>
	x = (x - 512) >> 5;
	bool sign = x < 0;
	if (sign)
		x = -x;
	x -= 3;	// deadzone
	if (x <= 0)
    123c:	2300      	movs	r3, #0
    123e:	e74e      	b.n	10de <_Z13DrawTrianglesiPhi+0xca>
     	if ((_phase++ & 0xFF) == 0)
     		_zdst = FARZ;	// Trigger zoom away

        if (key == 1 || key == 0x80)
        {
            if (key == 0x80)
    1240:	2900      	cmp	r1, #0
    1242:	d00b      	beq.n	125c <_Z13DrawTrianglesiPhi+0x248>
            {
            	_zdst = _zsrc = _z = NEARZ;
    1244:	980b      	ldr	r0, [sp, #44]
    1246:	2380      	movs	r3, #128
    1248:	035b      	lsls	r3, r3, #13
    124a:	6003      	str	r3, [r0, #0]
    124c:	6043      	str	r3, [r0, #4]
    124e:	6083      	str	r3, [r0, #8]
                _rotX = _rotY = _rotZ = 0;
    1250:	2300      	movs	r3, #0
    1252:	73c3      	strb	r3, [r0, #15]
    1254:	7383      	strb	r3, [r0, #14]
    1256:	7343      	strb	r3, [r0, #13]
                _phase = 8;
    1258:	2308      	movs	r3, #8
    125a:	7303      	strb	r3, [r0, #12]
             //   Graphics::SetAAColor(0x0000,0xFFFF);
             //   _phase++;
              //  if (_phase == 3)
              //      _phase = 0;
            }
            _top = 0;
    125c:	990b      	ldr	r1, [sp, #44]
    125e:	2300      	movs	r3, #0
    1260:	854b      	strh	r3, [r1, #42]
            _bottom = SCREEN_HEIGHT;
    1262:	23f0      	movs	r3, #240
    1264:	858b      	strh	r3, [r1, #44]
    1266:	e709      	b.n	107c <_Z13DrawTrianglesiPhi+0x68>
	x = (x - 512) >> 5;
	bool sign = x < 0;
	if (sign)
		x = -x;
	x -= 3;	// deadzone
	if (x <= 0)
    1268:	2300      	movs	r3, #0
    126a:	e724      	b.n	10b6 <_Z13DrawTrianglesiPhi+0xa2>
        if (tcount + _triangleCount > MAXTRIANGLES || pcount + _vertexCount > MAXVERTEXES)
            return false;
        
        //  Copy and transform points
        byte pointMark = _vertexCount;
        for (byte i = 0; i < pcount; i++)
    126c:	4b4f      	ldr	r3, [pc, #316]	(13ac <_Z13DrawTrianglesiPhi+0x398>)
    126e:	9c0b      	ldr	r4, [sp, #44]
    1270:	5ce3      	ldrb	r3, [r4, r3]
    1272:	4698      	mov	r8, r3
            Project(p + i,_vertexes + _vertexCount++);

        //  Copy triangles to buffer, map point indexes
        byte triangleMark = _triangleCount;
        for (byte i = 0; i < tcount; i++)
    1274:	9e0a      	ldr	r6, [sp, #40]
    1276:	2e00      	cmp	r6, #0
    1278:	d065      	beq.n	1346 <_Z13DrawTrianglesiPhi+0x332>
    127a:	9b09      	ldr	r3, [sp, #36]
{    
    ModelState* m = (ModelState*)appBuffer;
	int i = (_model++ >> 8) & 3;
	_hackyColor = i+3;
	const Model* model = _models[i];
	m->Draw(keys,(Triangle*)model->Triangles,model->TriangleCount,(Vec3Char*)model->Vertexes,model->VertexCount);
    127c:	9808      	ldr	r0, [sp, #32]
    127e:	3b01      	subs	r3, #1
        for (byte i = 0; i < pcount; i++)
            Project(p + i,_vertexes + _vertexCount++);

        //  Copy triangles to buffer, map point indexes
        byte triangleMark = _triangleCount;
        for (byte i = 0; i < tcount; i++)
    1280:	b2db      	uxtb	r3, r3
    1282:	3301      	adds	r3, #1
{    
    ModelState* m = (ModelState*)appBuffer;
	int i = (_model++ >> 8) & 3;
	_hackyColor = i+3;
	const Model* model = _models[i];
	m->Draw(keys,(Triangle*)model->Triangles,model->TriangleCount,(Vec3Char*)model->Vertexes,model->VertexCount);
    1284:	4683      	mov	fp, r0
            //  order point v0,v1,v2 by y
            if (_vertexes[t.p0].y > _vertexes[t.p1].y) { SWAP(t.p0,t.p1); d = !d;  }
            if (_vertexes[t.p0].y > _vertexes[t.p2].y) { SWAP(t.p0,t.p2); d = !d;  }
            if (_vertexes[t.p1].y > _vertexes[t.p2].y) { SWAP(t.p1,t.p2); d = !d;  }
            if (d)
                t.fill |= 0x80; // dem in top bit of fill, 4 byte tris
    1286:	2180      	movs	r1, #128
        for (byte i = 0; i < pcount; i++)
            Project(p + i,_vertexes + _vertexCount++);

        //  Copy triangles to buffer, map point indexes
        byte triangleMark = _triangleCount;
        for (byte i = 0; i < tcount; i++)
    1288:	009b      	lsls	r3, r3, #2
            //  order point v0,v1,v2 by y
            if (_vertexes[t.p0].y > _vertexes[t.p1].y) { SWAP(t.p0,t.p1); d = !d;  }
            if (_vertexes[t.p0].y > _vertexes[t.p2].y) { SWAP(t.p0,t.p2); d = !d;  }
            if (_vertexes[t.p1].y > _vertexes[t.p2].y) { SWAP(t.p1,t.p2); d = !d;  }
            if (d)
                t.fill |= 0x80; // dem in top bit of fill, 4 byte tris
    128a:	4249      	negs	r1, r1
        for (byte i = 0; i < pcount; i++)
            Project(p + i,_vertexes + _vertexCount++);

        //  Copy triangles to buffer, map point indexes
        byte triangleMark = _triangleCount;
        for (byte i = 0; i < tcount; i++)
    128c:	445b      	add	r3, fp
            //  order point v0,v1,v2 by y
            if (_vertexes[t.p0].y > _vertexes[t.p1].y) { SWAP(t.p0,t.p1); d = !d;  }
            if (_vertexes[t.p0].y > _vertexes[t.p2].y) { SWAP(t.p0,t.p2); d = !d;  }
            if (_vertexes[t.p1].y > _vertexes[t.p2].y) { SWAP(t.p1,t.p2); d = !d;  }
            if (d)
                t.fill |= 0x80; // dem in top bit of fill, 4 byte tris
    128e:	9105      	str	r1, [sp, #20]
        for (byte i = 0; i < pcount; i++)
            Project(p + i,_vertexes + _vertexCount++);

        //  Copy triangles to buffer, map point indexes
        byte triangleMark = _triangleCount;
        for (byte i = 0; i < tcount; i++)
    1290:	9304      	str	r3, [sp, #16]
        {
            Triangle& t = _triangles[triangleMark];
            t = *tris++;
    1292:	4643      	mov	r3, r8
    1294:	9c0b      	ldr	r4, [sp, #44]
    1296:	339c      	adds	r3, #156
    1298:	9306      	str	r3, [sp, #24]
    129a:	009b      	lsls	r3, r3, #2
    129c:	18e6      	adds	r6, r4, r3
    129e:	4659      	mov	r1, fp
    12a0:	2204      	movs	r2, #4
    12a2:	1db0      	adds	r0, r6, #6
    12a4:	f001 fe08 	bl	2eb8 <memcpy>
            t.p0 += pointMark;  // do this later
    12a8:	990e      	ldr	r1, [sp, #56]
    12aa:	79b3      	ldrb	r3, [r6, #6]
        //  Copy triangles to buffer, map point indexes
        byte triangleMark = _triangleCount;
        for (byte i = 0; i < tcount; i++)
        {
            Triangle& t = _triangles[triangleMark];
            t = *tris++;
    12ac:	2004      	movs	r0, #4
            t.p0 += pointMark;  // do this later
    12ae:	18cb      	adds	r3, r1, r3
    12b0:	71b3      	strb	r3, [r6, #6]
            t.p1 += pointMark;
    12b2:	79f3      	ldrb	r3, [r6, #7]
        //  Copy triangles to buffer, map point indexes
        byte triangleMark = _triangleCount;
        for (byte i = 0; i < tcount; i++)
        {
            Triangle& t = _triangles[triangleMark];
            t = *tris++;
    12b4:	4483      	add	fp, r0
            t.p0 += pointMark;  // do this later
            t.p1 += pointMark;
    12b6:	18cb      	adds	r3, r1, r3
    12b8:	71f3      	strb	r3, [r6, #7]
            t.p2 += pointMark;
    12ba:	7a33      	ldrb	r3, [r6, #8]
            
            // Cull backfaces
            Vec3& v0 = _vertexes[t.p0];
		    Vec3& v1 = _vertexes[t.p1];
    12bc:	79f2      	ldrb	r2, [r6, #7]
        {
            Triangle& t = _triangles[triangleMark];
            t = *tris++;
            t.p0 += pointMark;  // do this later
            t.p1 += pointMark;
            t.p2 += pointMark;
    12be:	18cb      	adds	r3, r1, r3
    12c0:	b2db      	uxtb	r3, r3
            
            // Cull backfaces
            Vec3& v0 = _vertexes[t.p0];
		    Vec3& v1 = _vertexes[t.p1];
    12c2:	4694      	mov	ip, r2
		    Vec3& v2 = _vertexes[t.p2];
		    bool d = ((long)(v0.x-v2.x))*(v1.y - v2.y) > ((long)(v1.x-v2.x))*(v0.y - v2.y);
    12c4:	005a      	lsls	r2, r3, #1
    12c6:	18d2      	adds	r2, r2, r3
        {
            Triangle& t = _triangles[triangleMark];
            t = *tris++;
            t.p0 += pointMark;  // do this later
            t.p1 += pointMark;
            t.p2 += pointMark;
    12c8:	7233      	strb	r3, [r6, #8]
            
            // Cull backfaces
            Vec3& v0 = _vertexes[t.p0];
		    Vec3& v1 = _vertexes[t.p1];
		    Vec3& v2 = _vertexes[t.p2];
		    bool d = ((long)(v0.x-v2.x))*(v1.y - v2.y) > ((long)(v1.x-v2.x))*(v0.y - v2.y);
    12ca:	4660      	mov	r0, ip
    12cc:	0052      	lsls	r2, r2, #1
    12ce:	238a      	movs	r3, #138
    12d0:	18a2      	adds	r2, r4, r2
    12d2:	009b      	lsls	r3, r3, #2
    12d4:	0041      	lsls	r1, r0, #1
    12d6:	18d2      	adds	r2, r2, r3
    12d8:	4461      	add	r1, ip
    12da:	9b0b      	ldr	r3, [sp, #44]
    12dc:	2406      	movs	r4, #6
    12de:	5f15      	ldrsh	r5, [r2, r4]
            t.p0 += pointMark;  // do this later
            t.p1 += pointMark;
            t.p2 += pointMark;
            
            // Cull backfaces
            Vec3& v0 = _vertexes[t.p0];
    12e0:	79b7      	ldrb	r7, [r6, #6]
		    Vec3& v1 = _vertexes[t.p1];
		    Vec3& v2 = _vertexes[t.p2];
		    bool d = ((long)(v0.x-v2.x))*(v1.y - v2.y) > ((long)(v1.x-v2.x))*(v0.y - v2.y);
    12e2:	0049      	lsls	r1, r1, #1
    12e4:	248a      	movs	r4, #138
    12e6:	1859      	adds	r1, r3, r1
    12e8:	00a4      	lsls	r4, r4, #2
    12ea:	1909      	adds	r1, r1, r4
    12ec:	007c      	lsls	r4, r7, #1
    12ee:	2308      	movs	r3, #8
    12f0:	5ed0      	ldrsh	r0, [r2, r3]
    12f2:	19e3      	adds	r3, r4, r7
    12f4:	9a0b      	ldr	r2, [sp, #44]
    12f6:	46a2      	mov	sl, r4
    12f8:	005b      	lsls	r3, r3, #1
    12fa:	248a      	movs	r4, #138
    12fc:	00a4      	lsls	r4, r4, #2
    12fe:	18d3      	adds	r3, r2, r3
    1300:	191b      	adds	r3, r3, r4
            if (!d)
    1302:	2408      	movs	r4, #8
    1304:	5f0a      	ldrsh	r2, [r1, r4]
    1306:	4691      	mov	r9, r2
    1308:	1a12      	subs	r2, r2, r0
    130a:	9201      	str	r2, [sp, #4]
    130c:	2406      	movs	r4, #6
    130e:	5f1a      	ldrsh	r2, [r3, r4]
    1310:	9c01      	ldr	r4, [sp, #4]
    1312:	1b52      	subs	r2, r2, r5
    1314:	4354      	muls	r4, r2
    1316:	9403      	str	r4, [sp, #12]
    1318:	2208      	movs	r2, #8
    131a:	5e9c      	ldrsh	r4, [r3, r2]
    131c:	2206      	movs	r2, #6
    131e:	5e8b      	ldrsh	r3, [r1, r2]
    1320:	1a20      	subs	r0, r4, r0
    1322:	1b5b      	subs	r3, r3, r5
    1324:	4343      	muls	r3, r0
    1326:	9803      	ldr	r0, [sp, #12]
    1328:	4298      	cmp	r0, r3
    132a:	dd00      	ble.n	132e <_Z13DrawTrianglesiPhi+0x31a>
    132c:	e07d      	b.n	142a <_Z13DrawTrianglesiPhi+0x416>
    132e:	4642      	mov	r2, r8
        for (byte i = 0; i < pcount; i++)
            Project(p + i,_vertexes + _vertexCount++);

        //  Copy triangles to buffer, map point indexes
        byte triangleMark = _triangleCount;
        for (byte i = 0; i < tcount; i++)
    1330:	9b04      	ldr	r3, [sp, #16]
    1332:	459b      	cmp	fp, r3
    1334:	d001      	beq.n	133a <_Z13DrawTrianglesiPhi+0x326>
    1336:	4690      	mov	r8, r2
    1338:	e7ab      	b.n	1292 <_Z13DrawTrianglesiPhi+0x27e>
            if (d)
                t.fill |= 0x80; // dem in top bit of fill, 4 byte tris
            triangleMark++;     // Keep this one
        }
        
        if (triangleMark == _triangleCount)
    133a:	4b1c      	ldr	r3, [pc, #112]	(13ac <_Z13DrawTrianglesiPhi+0x398>)
    133c:	9c0b      	ldr	r4, [sp, #44]
        for (byte i = 0; i < pcount; i++)
            Project(p + i,_vertexes + _vertexCount++);

        //  Copy triangles to buffer, map point indexes
        byte triangleMark = _triangleCount;
        for (byte i = 0; i < tcount; i++)
    133e:	4690      	mov	r8, r2
            if (d)
                t.fill |= 0x80; // dem in top bit of fill, 4 byte tris
            triangleMark++;     // Keep this one
        }
        
        if (triangleMark == _triangleCount)
    1340:	5ce3      	ldrb	r3, [r4, r3]
    1342:	4293      	cmp	r3, r2
    1344:	d106      	bne.n	1354 <_Z13DrawTrianglesiPhi+0x340>
            _vertexCount = pointMark;    // All triangles were clipped, ditch points
    1346:	ae0e      	add	r6, sp, #56
    1348:	7830      	ldrb	r0, [r6, #0]
    134a:	238b      	movs	r3, #139
    134c:	9e0b      	ldr	r6, [sp, #44]
    134e:	009b      	lsls	r3, r3, #2
    1350:	54f0      	strb	r0, [r6, r3]
    1352:	4642      	mov	r2, r8
        _triangleCount = triangleMark;
    1354:	4b15      	ldr	r3, [pc, #84]	(13ac <_Z13DrawTrianglesiPhi+0x398>)
    1356:	990b      	ldr	r1, [sp, #44]
    1358:	54ca      	strb	r2, [r1, r3]
       if (_z < (150L << FPP))
           _z += (1L<<FPP)/256;
#endif
            
        _r.AddTriangles(triangles,tcount,vertexes,vcount);
		_r.DrawBegin();
    135a:	9b0b      	ldr	r3, [sp, #44]
	int _nextY;
	int _triangleIndex;

    void DrawBegin()
    {
        SortY(0,_triangleCount-1);
    135c:	3a01      	subs	r2, #1
       if (_z < (150L << FPP))
           _z += (1L<<FPP)/256;
#endif
            
        _r.AddTriangles(triangles,tcount,vertexes,vcount);
		_r.DrawBegin();
    135e:	4699      	mov	r9, r3
	int _nextY;
	int _triangleIndex;

    void DrawBegin()
    {
        SortY(0,_triangleCount-1);
    1360:	2400      	movs	r4, #0
       if (_z < (150L << FPP))
           _z += (1L<<FPP)/256;
#endif
            
        _r.AddTriangles(triangles,tcount,vertexes,vcount);
		_r.DrawBegin();
    1362:	2330      	movs	r3, #48
    1364:	4499      	add	r9, r3
	int _nextY;
	int _triangleIndex;

    void DrawBegin()
    {
        SortY(0,_triangleCount-1);
    1366:	9210      	str	r2, [sp, #64]
    1368:	9411      	str	r4, [sp, #68]
        dst->z = v.z;
    }

    short TriangleMinY(byte ti)
    {
        return _vertexes[_triangles[ti].p0].y;
    136a:	9e11      	ldr	r6, [sp, #68]
    136c:	9810      	ldr	r0, [sp, #64]
    136e:	21fc      	movs	r1, #252
    1370:	1833      	adds	r3, r6, r0
    1372:	105b      	asrs	r3, r3, #1
    1374:	b2db      	uxtb	r3, r3
    1376:	3390      	adds	r3, #144
    1378:	009b      	lsls	r3, r3, #2
    137a:	444b      	add	r3, r9
    137c:	799a      	ldrb	r2, [r3, #6]
    137e:	0049      	lsls	r1, r1, #1
    1380:	0053      	lsls	r3, r2, #1
    1382:	189b      	adds	r3, r3, r2
    1384:	005b      	lsls	r3, r3, #1
    1386:	444b      	add	r3, r9
    1388:	185b      	adds	r3, r3, r1
    138a:	9612      	str	r6, [sp, #72]
    138c:	9013      	str	r0, [sp, #76]
    138e:	2208      	movs	r2, #8
    1390:	5e9e      	ldrsh	r6, [r3, r2]
    {
        int i = left;
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
    1392:	9912      	ldr	r1, [sp, #72]
    1394:	9a13      	ldr	r2, [sp, #76]
    1396:	4291      	cmp	r1, r2
    1398:	dc3c      	bgt.n	1414 <_Z13DrawTrianglesiPhi+0x400>
    139a:	ab13      	add	r3, sp, #76
    139c:	781c      	ldrb	r4, [r3, #0]
    139e:	e00e      	b.n	13be <_Z13DrawTrianglesiPhi+0x3aa>
    13a0:	1000047c 	.word	0x1000047c
    13a4:	10000004 	.word	0x10000004
    13a8:	fffffe00 	.word	0xfffffe00
    13ac:	0000022d 	.word	0x0000022d
    13b0:	00000276 	.word	0x00000276
    13b4:	80000001 	.word	0x80000001
        {
            while (TriangleMinY(i) < pivot)
                i++;
    13b8:	9b12      	ldr	r3, [sp, #72]
    13ba:	3301      	adds	r3, #1
    13bc:	9312      	str	r3, [sp, #72]
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
    13be:	a812      	add	r0, sp, #72
    13c0:	7803      	ldrb	r3, [r0, #0]
    13c2:	21fc      	movs	r1, #252
    13c4:	1c1d      	adds	r5, r3, #0
    13c6:	3590      	adds	r5, #144
    13c8:	00ab      	lsls	r3, r5, #2
    13ca:	444b      	add	r3, r9
    13cc:	799a      	ldrb	r2, [r3, #6]
    13ce:	0049      	lsls	r1, r1, #1
    13d0:	0053      	lsls	r3, r2, #1
    13d2:	189b      	adds	r3, r3, r2
    13d4:	005b      	lsls	r3, r3, #1
    13d6:	444b      	add	r3, r9
    13d8:	185b      	adds	r3, r3, r1
    13da:	2208      	movs	r2, #8
    13dc:	5e9b      	ldrsh	r3, [r3, r2]
    13de:	42b3      	cmp	r3, r6
    13e0:	dbea      	blt.n	13b8 <_Z13DrawTrianglesiPhi+0x3a4>
    13e2:	e004      	b.n	13ee <_Z13DrawTrianglesiPhi+0x3da>
                i++;
            while (TriangleMinY(j) > pivot)
                j--;
    13e4:	9a13      	ldr	r2, [sp, #76]
    13e6:	ab13      	add	r3, sp, #76
    13e8:	3a01      	subs	r2, #1
    13ea:	9213      	str	r2, [sp, #76]
    13ec:	781c      	ldrb	r4, [r3, #0]

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
                i++;
            while (TriangleMinY(j) > pivot)
    13ee:	3490      	adds	r4, #144
    13f0:	00a3      	lsls	r3, r4, #2
    13f2:	444b      	add	r3, r9
    13f4:	799a      	ldrb	r2, [r3, #6]
    13f6:	20fc      	movs	r0, #252
    13f8:	0053      	lsls	r3, r2, #1
    13fa:	189b      	adds	r3, r3, r2
    13fc:	005b      	lsls	r3, r3, #1
    13fe:	444b      	add	r3, r9
    1400:	0040      	lsls	r0, r0, #1
    1402:	181b      	adds	r3, r3, r0
    1404:	2108      	movs	r1, #8
    1406:	5e5b      	ldrsh	r3, [r3, r1]
    1408:	42b3      	cmp	r3, r6
    140a:	dceb      	bgt.n	13e4 <_Z13DrawTrianglesiPhi+0x3d0>
                j--;
            if (i <= j)
    140c:	9a12      	ldr	r2, [sp, #72]
    140e:	9b13      	ldr	r3, [sp, #76]
    1410:	429a      	cmp	r2, r3
    1412:	dd64      	ble.n	14de <_Z13DrawTrianglesiPhi+0x4ca>
                i++;
                j--;
            }
        }

        if (left < j)
    1414:	9b11      	ldr	r3, [sp, #68]
    1416:	9c13      	ldr	r4, [sp, #76]
    1418:	42a3      	cmp	r3, r4
    141a:	da00      	bge.n	141e <_Z13DrawTrianglesiPhi+0x40a>
    141c:	e0db      	b.n	15d6 <_Z13DrawTrianglesiPhi+0x5c2>
            SortY(left, j);
        if (i < right)
    141e:	9810      	ldr	r0, [sp, #64]
    1420:	9912      	ldr	r1, [sp, #72]
    1422:	4288      	cmp	r0, r1
    1424:	dd77      	ble.n	1516 <_Z13DrawTrianglesiPhi+0x502>
    1426:	9111      	str	r1, [sp, #68]
    1428:	e79f      	b.n	136a <_Z13DrawTrianglesiPhi+0x356>
                continue;
                
            //  TODO garbage collect unused vertexes from culled triangles
                              
            //  order point v0,v1,v2 by y
            if (_vertexes[t.p0].y > _vertexes[t.p1].y) { SWAP(t.p0,t.p1); d = !d;  }
    142a:	45a1      	cmp	r9, r4
    142c:	db46      	blt.n	14bc <_Z13DrawTrianglesiPhi+0x4a8>
    142e:	2501      	movs	r5, #1
            if (_vertexes[t.p0].y > _vertexes[t.p2].y) { SWAP(t.p0,t.p2); d = !d;  }
    1430:	9906      	ldr	r1, [sp, #24]
    1432:	9a0b      	ldr	r2, [sp, #44]
    1434:	008b      	lsls	r3, r1, #2
    1436:	18d1      	adds	r1, r2, r3
    1438:	7a0a      	ldrb	r2, [r1, #8]
    143a:	9e0b      	ldr	r6, [sp, #44]
    143c:	0053      	lsls	r3, r2, #1
    143e:	189b      	adds	r3, r3, r2
    1440:	005b      	lsls	r3, r3, #1
    1442:	208a      	movs	r0, #138
    1444:	18f3      	adds	r3, r6, r3
    1446:	0080      	lsls	r0, r0, #2
    1448:	181b      	adds	r3, r3, r0
    144a:	2608      	movs	r6, #8
    144c:	5f98      	ldrsh	r0, [r3, r6]
    144e:	42a0      	cmp	r0, r4
    1450:	db24      	blt.n	149c <_Z13DrawTrianglesiPhi+0x488>
    1452:	1c17      	adds	r7, r2, #0
            if (_vertexes[t.p1].y > _vertexes[t.p2].y) { SWAP(t.p1,t.p2); d = !d;  }
    1454:	9e06      	ldr	r6, [sp, #24]
    1456:	9a0b      	ldr	r2, [sp, #44]
    1458:	00b3      	lsls	r3, r6, #2
    145a:	18d1      	adds	r1, r2, r3
    145c:	79ca      	ldrb	r2, [r1, #7]
    145e:	9c0b      	ldr	r4, [sp, #44]
    1460:	0053      	lsls	r3, r2, #1
    1462:	189b      	adds	r3, r3, r2
    1464:	005b      	lsls	r3, r3, #1
    1466:	268a      	movs	r6, #138
    1468:	18e3      	adds	r3, r4, r3
    146a:	00b6      	lsls	r6, r6, #2
    146c:	199b      	adds	r3, r3, r6
    146e:	2408      	movs	r4, #8
    1470:	5f1b      	ldrsh	r3, [r3, r4]
    1472:	4283      	cmp	r3, r0
    1474:	dd04      	ble.n	1480 <_Z13DrawTrianglesiPhi+0x46c>
    1476:	2301      	movs	r3, #1
    1478:	406b      	eors	r3, r5
}

void SWAP(byte& a, byte& b)
{
    byte tmp = a;
    a = b;
    147a:	71cf      	strb	r7, [r1, #7]
    b = tmp;
    147c:	720a      	strb	r2, [r1, #8]
            //  TODO garbage collect unused vertexes from culled triangles
                              
            //  order point v0,v1,v2 by y
            if (_vertexes[t.p0].y > _vertexes[t.p1].y) { SWAP(t.p0,t.p1); d = !d;  }
            if (_vertexes[t.p0].y > _vertexes[t.p2].y) { SWAP(t.p0,t.p2); d = !d;  }
            if (_vertexes[t.p1].y > _vertexes[t.p2].y) { SWAP(t.p1,t.p2); d = !d;  }
    147e:	b2dd      	uxtb	r5, r3
            if (d)
    1480:	2d00      	cmp	r5, #0
    1482:	d007      	beq.n	1494 <_Z13DrawTrianglesiPhi+0x480>
                t.fill |= 0x80; // dem in top bit of fill, 4 byte tris
    1484:	9e06      	ldr	r6, [sp, #24]
    1486:	980b      	ldr	r0, [sp, #44]
    1488:	00b2      	lsls	r2, r6, #2
    148a:	1882      	adds	r2, r0, r2
    148c:	7a53      	ldrb	r3, [r2, #9]
    148e:	9905      	ldr	r1, [sp, #20]
    1490:	430b      	orrs	r3, r1
    1492:	7253      	strb	r3, [r2, #9]
            triangleMark++;     // Keep this one
    1494:	4643      	mov	r3, r8
    1496:	3301      	adds	r3, #1
    1498:	b2da      	uxtb	r2, r3
    149a:	e749      	b.n	1330 <_Z13DrawTrianglesiPhi+0x31c>
                
            //  TODO garbage collect unused vertexes from culled triangles
                              
            //  order point v0,v1,v2 by y
            if (_vertexes[t.p0].y > _vertexes[t.p1].y) { SWAP(t.p0,t.p1); d = !d;  }
            if (_vertexes[t.p0].y > _vertexes[t.p2].y) { SWAP(t.p0,t.p2); d = !d;  }
    149c:	2301      	movs	r3, #1
}

void SWAP(byte& a, byte& b)
{
    byte tmp = a;
    a = b;
    149e:	718a      	strb	r2, [r1, #6]
    b = tmp;
    14a0:	720f      	strb	r7, [r1, #8]
                
            //  TODO garbage collect unused vertexes from culled triangles
                              
            //  order point v0,v1,v2 by y
            if (_vertexes[t.p0].y > _vertexes[t.p1].y) { SWAP(t.p0,t.p1); d = !d;  }
            if (_vertexes[t.p0].y > _vertexes[t.p2].y) { SWAP(t.p0,t.p2); d = !d;  }
    14a2:	406b      	eors	r3, r5
    14a4:	4650      	mov	r0, sl
    14a6:	b2dd      	uxtb	r5, r3
    14a8:	990b      	ldr	r1, [sp, #44]
    14aa:	19c3      	adds	r3, r0, r7
    14ac:	005b      	lsls	r3, r3, #1
    14ae:	228a      	movs	r2, #138
    14b0:	18cb      	adds	r3, r1, r3
    14b2:	0092      	lsls	r2, r2, #2
    14b4:	189b      	adds	r3, r3, r2
    14b6:	2408      	movs	r4, #8
    14b8:	5f18      	ldrsh	r0, [r3, r4]
    14ba:	e7cb      	b.n	1454 <_Z13DrawTrianglesiPhi+0x440>
}

void SWAP(byte& a, byte& b)
{
    byte tmp = a;
    a = b;
    14bc:	4661      	mov	r1, ip
    b = tmp;
    14be:	71f7      	strb	r7, [r6, #7]
    14c0:	b2cf      	uxtb	r7, r1
}

void SWAP(byte& a, byte& b)
{
    byte tmp = a;
    a = b;
    14c2:	71b1      	strb	r1, [r6, #6]
    b = tmp;
    14c4:	007a      	lsls	r2, r7, #1
    14c6:	9c0b      	ldr	r4, [sp, #44]
    14c8:	19d3      	adds	r3, r2, r7
    14ca:	005b      	lsls	r3, r3, #1
    14cc:	268a      	movs	r6, #138
    14ce:	18e3      	adds	r3, r4, r3
    14d0:	00b6      	lsls	r6, r6, #2
    14d2:	199b      	adds	r3, r3, r6
    14d4:	4692      	mov	sl, r2
    14d6:	2500      	movs	r5, #0
    14d8:	2008      	movs	r0, #8
    14da:	5e1c      	ldrsh	r4, [r3, r0]
    14dc:	e7a8      	b.n	1430 <_Z13DrawTrianglesiPhi+0x41c>
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
    14de:	00ad      	lsls	r5, r5, #2
    14e0:	444d      	add	r5, r9
        t[i] = t[j];
    14e2:	00a4      	lsls	r4, r4, #2
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
    14e4:	3506      	adds	r5, #6
        t[i] = t[j];
    14e6:	444c      	add	r4, r9
    14e8:	3406      	adds	r4, #6
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
    14ea:	1c29      	adds	r1, r5, #0
    14ec:	2204      	movs	r2, #4
    14ee:	a841      	add	r0, sp, #260
    14f0:	f001 fce2 	bl	2eb8 <memcpy>
        t[i] = t[j];
    14f4:	1c21      	adds	r1, r4, #0
    14f6:	2204      	movs	r2, #4
    14f8:	1c28      	adds	r0, r5, #0
    14fa:	f001 fcdd 	bl	2eb8 <memcpy>
        t[j] = tmp;
    14fe:	1c20      	adds	r0, r4, #0
    1500:	a941      	add	r1, sp, #260
    1502:	2204      	movs	r2, #4
    1504:	f001 fcd8 	bl	2eb8 <memcpy>
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
    1508:	9c12      	ldr	r4, [sp, #72]
                j--;
    150a:	9813      	ldr	r0, [sp, #76]
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
    150c:	3401      	adds	r4, #1
                j--;
    150e:	3801      	subs	r0, #1
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
    1510:	9412      	str	r4, [sp, #72]
                j--;
    1512:	9013      	str	r0, [sp, #76]
    1514:	e73d      	b.n	1392 <_Z13DrawTrianglesiPhi+0x37e>
            }
        }

        if (left < j)
            SortY(left, j);
        if (i < right)
    1516:	990b      	ldr	r1, [sp, #44]
    1518:	2201      	movs	r2, #1
    151a:	3164      	adds	r1, #100
    }
    
    void InitEdgeList()
    {
        for (int i = 0; i < MAXEDGES; i++)
            _edges[i].Next = _edges + i + 1;
    151c:	0053      	lsls	r3, r2, #1
    151e:	189b      	adds	r3, r3, r2
    1520:	00db      	lsls	r3, r3, #3
    1522:	9c0b      	ldr	r4, [sp, #44]
    1524:	3360      	adds	r3, #96
    1526:	18e3      	adds	r3, r4, r3
    1528:	3201      	adds	r2, #1
    152a:	600b      	str	r3, [r1, #0]
    152c:	3118      	adds	r1, #24
        return true;
    }
    
    void InitEdgeList()
    {
        for (int i = 0; i < MAXEDGES; i++)
    152e:	2a11      	cmp	r2, #17
    1530:	d1f4      	bne.n	151c <_Z13DrawTrianglesiPhi+0x508>
            _edges[i].Next = _edges + i + 1;
        _edges[MAXEDGES-1].Next = 0;
    1532:	23e6      	movs	r3, #230
    1534:	2100      	movs	r1, #0
    1536:	005b      	lsls	r3, r3, #1
    1538:	50e1      	str	r1, [r4, r3]
        _freeList = _edges;
    153a:	9e0c      	ldr	r6, [sp, #48]
    153c:	23f0      	movs	r3, #240
    153e:	005b      	lsls	r3, r3, #1
    1540:	50e6      	str	r6, [r4, r3]
        _newEdgeList = 0;
    1542:	23f2      	movs	r3, #242
    1544:	005b      	lsls	r3, r3, #1
    1546:	50e1      	str	r1, [r4, r3]
        _head.Prev = _tail.Next = 0;
        _head.Next = &_tail;
    1548:	1c23      	adds	r3, r4, #0
    154a:	3348      	adds	r3, #72
    154c:	6363      	str	r3, [r4, #52]
        _tail.Prev = &_head;
    154e:	4648      	mov	r0, r9
        SortY(0,_triangleCount-1);
        InitEdgeList();        
        
        // slight hack to only draw dirty lines
        int yy = _vertexes[_triangles[0].p0].y;
        _nextY = (int) CEIL(yy);  //
    1550:	4bae      	ldr	r3, [pc, #696]	(180c <_Z13DrawTrianglesiPhi+0x7f8>)
        for (int i = 0; i < MAXEDGES; i++)
            _edges[i].Next = _edges + i + 1;
        _edges[MAXEDGES-1].Next = 0;
        _freeList = _edges;
        _newEdgeList = 0;
        _head.Prev = _tail.Next = 0;
    1552:	64e1      	str	r1, [r4, #76]
    1554:	6321      	str	r1, [r4, #48]
        _head.Next = &_tail;
        _tail.Prev = &_head;
    1556:	64a0      	str	r0, [r4, #72]
        SortY(0,_triangleCount-1);
        InitEdgeList();        
        
        // slight hack to only draw dirty lines
        int yy = _vertexes[_triangles[0].p0].y;
        _nextY = (int) CEIL(yy);  //
    1558:	5ce2      	ldrb	r2, [r4, r3]
    155a:	9e0b      	ldr	r6, [sp, #44]
    155c:	0053      	lsls	r3, r2, #1
    155e:	189b      	adds	r3, r3, r2
    1560:	005b      	lsls	r3, r3, #1
    1562:	228a      	movs	r2, #138
    1564:	18e3      	adds	r3, r4, r3
    1566:	0092      	lsls	r2, r2, #2
    1568:	189b      	adds	r3, r3, r2
    156a:	2408      	movs	r4, #8
    156c:	5f1a      	ldrsh	r2, [r3, r4]
    156e:	23b3      	movs	r3, #179
    1570:	3210      	adds	r2, #16
    1572:	1112      	asrs	r2, r2, #4
    1574:	009b      	lsls	r3, r3, #2
    1576:	50f2      	str	r2, [r6, r3]
		_y = _nextY;
    1578:	23b2      	movs	r3, #178
    157a:	009b      	lsls	r3, r3, #2
    157c:	50f2      	str	r2, [r6, r3]
		_triangleIndex = 0;
    157e:	23b4      	movs	r3, #180
    1580:	009b      	lsls	r3, r3, #2
    ModelState* m = (ModelState*)appBuffer;
	int i = (_model++ >> 8) & 3;
	_hackyColor = i+3;
	const Model* model = _models[i];
	m->Draw(keys,(Triangle*)model->Triangles,model->TriangleCount,(Vec3Char*)model->Vertexes,model->VertexCount);
}
    1582:	b045      	add	sp, #276
        
        // slight hack to only draw dirty lines
        int yy = _vertexes[_triangles[0].p0].y;
        _nextY = (int) CEIL(yy);  //
		_y = _nextY;
		_triangleIndex = 0;
    1584:	50f1      	str	r1, [r6, r3]
    ModelState* m = (ModelState*)appBuffer;
	int i = (_model++ >> 8) & 3;
	_hackyColor = i+3;
	const Model* model = _models[i];
	m->Draw(keys,(Triangle*)model->Triangles,model->TriangleCount,(Vec3Char*)model->Vertexes,model->VertexCount);
}
    1586:	bc3c      	pop	{r2, r3, r4, r5}
    1588:	4690      	mov	r8, r2
    158a:	4699      	mov	r9, r3
    158c:	46a2      	mov	sl, r4
    158e:	46ab      	mov	fp, r5
    1590:	bdf0      	pop	{r4, r5, r6, r7, pc}
        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
                i++;
            while (TriangleMinY(j) > pivot)
                j--;
    1592:	9a15      	ldr	r2, [sp, #84]
    1594:	ab15      	add	r3, sp, #84
    1596:	3a01      	subs	r2, #1
    1598:	9215      	str	r2, [sp, #84]
    159a:	781c      	ldrb	r4, [r3, #0]

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
                i++;
            while (TriangleMinY(j) > pivot)
    159c:	3490      	adds	r4, #144
    159e:	00a3      	lsls	r3, r4, #2
    15a0:	444b      	add	r3, r9
    15a2:	799a      	ldrb	r2, [r3, #6]
    15a4:	20fc      	movs	r0, #252
    15a6:	0053      	lsls	r3, r2, #1
    15a8:	189b      	adds	r3, r3, r2
    15aa:	005b      	lsls	r3, r3, #1
    15ac:	444b      	add	r3, r9
    15ae:	0040      	lsls	r0, r0, #1
    15b0:	181b      	adds	r3, r3, r0
    15b2:	2108      	movs	r1, #8
    15b4:	5e5b      	ldrsh	r3, [r3, r1]
    15b6:	42b3      	cmp	r3, r6
    15b8:	dceb      	bgt.n	1592 <_Z13DrawTrianglesiPhi+0x57e>
                j--;
            if (i <= j)
    15ba:	9a14      	ldr	r2, [sp, #80]
    15bc:	9b15      	ldr	r3, [sp, #84]
    15be:	429a      	cmp	r2, r3
    15c0:	dd3a      	ble.n	1638 <_Z13DrawTrianglesiPhi+0x624>
                i++;
                j--;
            }
        }

        if (left < j)
    15c2:	9b11      	ldr	r3, [sp, #68]
    15c4:	9c15      	ldr	r4, [sp, #84]
    15c6:	42a3      	cmp	r3, r4
    15c8:	db74      	blt.n	16b4 <_Z13DrawTrianglesiPhi+0x6a0>
            SortY(left, j);
        if (i < right)
    15ca:	9c14      	ldr	r4, [sp, #80]
    15cc:	9e13      	ldr	r6, [sp, #76]
    15ce:	42b4      	cmp	r4, r6
    15d0:	db00      	blt.n	15d4 <_Z13DrawTrianglesiPhi+0x5c0>
    15d2:	e724      	b.n	141e <_Z13DrawTrianglesiPhi+0x40a>
    15d4:	9411      	str	r4, [sp, #68]
        dst->z = v.z;
    }

    short TriangleMinY(byte ti)
    {
        return _vertexes[_triangles[ti].p0].y;
    15d6:	9e11      	ldr	r6, [sp, #68]
    15d8:	9813      	ldr	r0, [sp, #76]
    15da:	21fc      	movs	r1, #252
    15dc:	1833      	adds	r3, r6, r0
    15de:	105b      	asrs	r3, r3, #1
    15e0:	b2db      	uxtb	r3, r3
    15e2:	3390      	adds	r3, #144
    15e4:	009b      	lsls	r3, r3, #2
    15e6:	444b      	add	r3, r9
    15e8:	799a      	ldrb	r2, [r3, #6]
    15ea:	0049      	lsls	r1, r1, #1
    15ec:	0053      	lsls	r3, r2, #1
    15ee:	189b      	adds	r3, r3, r2
    15f0:	005b      	lsls	r3, r3, #1
    15f2:	444b      	add	r3, r9
    15f4:	185b      	adds	r3, r3, r1
    15f6:	9614      	str	r6, [sp, #80]
    15f8:	9015      	str	r0, [sp, #84]
    15fa:	2208      	movs	r2, #8
    15fc:	5e9e      	ldrsh	r6, [r3, r2]
    {
        int i = left;
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
    15fe:	9914      	ldr	r1, [sp, #80]
    1600:	9a15      	ldr	r2, [sp, #84]
    1602:	4291      	cmp	r1, r2
    1604:	dcdd      	bgt.n	15c2 <_Z13DrawTrianglesiPhi+0x5ae>
    1606:	ab15      	add	r3, sp, #84
    1608:	781c      	ldrb	r4, [r3, #0]
    160a:	e002      	b.n	1612 <_Z13DrawTrianglesiPhi+0x5fe>
        {
            while (TriangleMinY(i) < pivot)
                i++;
    160c:	9b14      	ldr	r3, [sp, #80]
    160e:	3301      	adds	r3, #1
    1610:	9314      	str	r3, [sp, #80]
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
    1612:	a814      	add	r0, sp, #80
    1614:	7803      	ldrb	r3, [r0, #0]
    1616:	21fc      	movs	r1, #252
    1618:	1c1d      	adds	r5, r3, #0
    161a:	3590      	adds	r5, #144
    161c:	00ab      	lsls	r3, r5, #2
    161e:	444b      	add	r3, r9
    1620:	799a      	ldrb	r2, [r3, #6]
    1622:	0049      	lsls	r1, r1, #1
    1624:	0053      	lsls	r3, r2, #1
    1626:	189b      	adds	r3, r3, r2
    1628:	005b      	lsls	r3, r3, #1
    162a:	444b      	add	r3, r9
    162c:	185b      	adds	r3, r3, r1
    162e:	2208      	movs	r2, #8
    1630:	5e9b      	ldrsh	r3, [r3, r2]
    1632:	42b3      	cmp	r3, r6
    1634:	dbea      	blt.n	160c <_Z13DrawTrianglesiPhi+0x5f8>
    1636:	e7b1      	b.n	159c <_Z13DrawTrianglesiPhi+0x588>
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
    1638:	00ad      	lsls	r5, r5, #2
    163a:	444d      	add	r5, r9
        t[i] = t[j];
    163c:	00a4      	lsls	r4, r4, #2
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
    163e:	3506      	adds	r5, #6
        t[i] = t[j];
    1640:	444c      	add	r4, r9
    1642:	3406      	adds	r4, #6
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
    1644:	1c29      	adds	r1, r5, #0
    1646:	2204      	movs	r2, #4
    1648:	a841      	add	r0, sp, #260
    164a:	f001 fc35 	bl	2eb8 <memcpy>
        t[i] = t[j];
    164e:	1c21      	adds	r1, r4, #0
    1650:	2204      	movs	r2, #4
    1652:	1c28      	adds	r0, r5, #0
    1654:	f001 fc30 	bl	2eb8 <memcpy>
        t[j] = tmp;
    1658:	1c20      	adds	r0, r4, #0
    165a:	a941      	add	r1, sp, #260
    165c:	2204      	movs	r2, #4
    165e:	f001 fc2b 	bl	2eb8 <memcpy>
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
    1662:	9c14      	ldr	r4, [sp, #80]
                j--;
    1664:	9815      	ldr	r0, [sp, #84]
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
    1666:	3401      	adds	r4, #1
                j--;
    1668:	3801      	subs	r0, #1
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
    166a:	9414      	str	r4, [sp, #80]
                j--;
    166c:	9015      	str	r0, [sp, #84]
    166e:	e7c6      	b.n	15fe <_Z13DrawTrianglesiPhi+0x5ea>
        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
                i++;
            while (TriangleMinY(j) > pivot)
                j--;
    1670:	9a17      	ldr	r2, [sp, #92]
    1672:	ab17      	add	r3, sp, #92
    1674:	3a01      	subs	r2, #1
    1676:	9217      	str	r2, [sp, #92]
    1678:	781c      	ldrb	r4, [r3, #0]

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
                i++;
            while (TriangleMinY(j) > pivot)
    167a:	3490      	adds	r4, #144
    167c:	00a3      	lsls	r3, r4, #2
    167e:	444b      	add	r3, r9
    1680:	799a      	ldrb	r2, [r3, #6]
    1682:	20fc      	movs	r0, #252
    1684:	0053      	lsls	r3, r2, #1
    1686:	189b      	adds	r3, r3, r2
    1688:	005b      	lsls	r3, r3, #1
    168a:	444b      	add	r3, r9
    168c:	0040      	lsls	r0, r0, #1
    168e:	181b      	adds	r3, r3, r0
    1690:	2108      	movs	r1, #8
    1692:	5e5b      	ldrsh	r3, [r3, r1]
    1694:	42b3      	cmp	r3, r6
    1696:	dceb      	bgt.n	1670 <_Z13DrawTrianglesiPhi+0x65c>
                j--;
            if (i <= j)
    1698:	9a16      	ldr	r2, [sp, #88]
    169a:	9b17      	ldr	r3, [sp, #92]
    169c:	429a      	cmp	r2, r3
    169e:	dc00      	bgt.n	16a2 <_Z13DrawTrianglesiPhi+0x68e>
    16a0:	e34e      	b.n	1d40 <_Z13DrawTrianglesiPhi+0xd2c>
                i++;
                j--;
            }
        }

        if (left < j)
    16a2:	9b11      	ldr	r3, [sp, #68]
    16a4:	9c17      	ldr	r4, [sp, #92]
    16a6:	42a3      	cmp	r3, r4
    16a8:	db6f      	blt.n	178a <_Z13DrawTrianglesiPhi+0x776>
            SortY(left, j);
        if (i < right)
    16aa:	9a16      	ldr	r2, [sp, #88]
    16ac:	9b15      	ldr	r3, [sp, #84]
    16ae:	429a      	cmp	r2, r3
    16b0:	da8b      	bge.n	15ca <_Z13DrawTrianglesiPhi+0x5b6>
    16b2:	9211      	str	r2, [sp, #68]
        dst->z = v.z;
    }

    short TriangleMinY(byte ti)
    {
        return _vertexes[_triangles[ti].p0].y;
    16b4:	9e11      	ldr	r6, [sp, #68]
    16b6:	9815      	ldr	r0, [sp, #84]
    16b8:	21fc      	movs	r1, #252
    16ba:	1833      	adds	r3, r6, r0
    16bc:	105b      	asrs	r3, r3, #1
    16be:	b2db      	uxtb	r3, r3
    16c0:	3390      	adds	r3, #144
    16c2:	009b      	lsls	r3, r3, #2
    16c4:	444b      	add	r3, r9
    16c6:	799a      	ldrb	r2, [r3, #6]
    16c8:	0049      	lsls	r1, r1, #1
    16ca:	0053      	lsls	r3, r2, #1
    16cc:	189b      	adds	r3, r3, r2
    16ce:	005b      	lsls	r3, r3, #1
    16d0:	444b      	add	r3, r9
    16d2:	185b      	adds	r3, r3, r1
    16d4:	9616      	str	r6, [sp, #88]
    16d6:	9017      	str	r0, [sp, #92]
    16d8:	2208      	movs	r2, #8
    16da:	5e9e      	ldrsh	r6, [r3, r2]
    {
        int i = left;
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
    16dc:	9916      	ldr	r1, [sp, #88]
    16de:	9a17      	ldr	r2, [sp, #92]
    16e0:	4291      	cmp	r1, r2
    16e2:	dcde      	bgt.n	16a2 <_Z13DrawTrianglesiPhi+0x68e>
    16e4:	ab17      	add	r3, sp, #92
    16e6:	781c      	ldrb	r4, [r3, #0]
    16e8:	e002      	b.n	16f0 <_Z13DrawTrianglesiPhi+0x6dc>
        {
            while (TriangleMinY(i) < pivot)
                i++;
    16ea:	9b16      	ldr	r3, [sp, #88]
    16ec:	3301      	adds	r3, #1
    16ee:	9316      	str	r3, [sp, #88]
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
    16f0:	a816      	add	r0, sp, #88
    16f2:	7803      	ldrb	r3, [r0, #0]
    16f4:	21fc      	movs	r1, #252
    16f6:	1c1d      	adds	r5, r3, #0
    16f8:	3590      	adds	r5, #144
    16fa:	00ab      	lsls	r3, r5, #2
    16fc:	444b      	add	r3, r9
    16fe:	799a      	ldrb	r2, [r3, #6]
    1700:	0049      	lsls	r1, r1, #1
    1702:	0053      	lsls	r3, r2, #1
    1704:	189b      	adds	r3, r3, r2
    1706:	005b      	lsls	r3, r3, #1
    1708:	444b      	add	r3, r9
    170a:	185b      	adds	r3, r3, r1
    170c:	2208      	movs	r2, #8
    170e:	5e9b      	ldrsh	r3, [r3, r2]
    1710:	42b3      	cmp	r3, r6
    1712:	dbea      	blt.n	16ea <_Z13DrawTrianglesiPhi+0x6d6>
    1714:	e7b1      	b.n	167a <_Z13DrawTrianglesiPhi+0x666>
                i++;
            while (TriangleMinY(j) > pivot)
    1716:	9018      	str	r0, [sp, #96]
    1718:	aa19      	add	r2, sp, #100
    171a:	7813      	ldrb	r3, [r2, #0]
    171c:	21fc      	movs	r1, #252
    171e:	1c1c      	adds	r4, r3, #0
    1720:	3490      	adds	r4, #144
    1722:	00a3      	lsls	r3, r4, #2
    1724:	444b      	add	r3, r9
    1726:	799a      	ldrb	r2, [r3, #6]
    1728:	0049      	lsls	r1, r1, #1
    172a:	0053      	lsls	r3, r2, #1
    172c:	189b      	adds	r3, r3, r2
    172e:	005b      	lsls	r3, r3, #1
    1730:	444b      	add	r3, r9
    1732:	185b      	adds	r3, r3, r1
    1734:	2208      	movs	r2, #8
    1736:	5e9b      	ldrsh	r3, [r3, r2]
    1738:	42b3      	cmp	r3, r6
    173a:	dc01      	bgt.n	1740 <_Z13DrawTrianglesiPhi+0x72c>
    173c:	e2fc      	b.n	1d38 <_Z13DrawTrianglesiPhi+0xd24>
    173e:	9119      	str	r1, [sp, #100]
                j--;
    1740:	9919      	ldr	r1, [sp, #100]
    1742:	3901      	subs	r1, #1
    1744:	b2cb      	uxtb	r3, r1

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
                i++;
            while (TriangleMinY(j) > pivot)
    1746:	1c1c      	adds	r4, r3, #0
    1748:	3490      	adds	r4, #144
    174a:	00a3      	lsls	r3, r4, #2
    174c:	444b      	add	r3, r9
    174e:	799a      	ldrb	r2, [r3, #6]
    1750:	0053      	lsls	r3, r2, #1
    1752:	189b      	adds	r3, r3, r2
    1754:	005b      	lsls	r3, r3, #1
    1756:	22fc      	movs	r2, #252
    1758:	0052      	lsls	r2, r2, #1
    175a:	444b      	add	r3, r9
    175c:	189b      	adds	r3, r3, r2
    175e:	2208      	movs	r2, #8
    1760:	5e9b      	ldrsh	r3, [r3, r2]
    1762:	42b3      	cmp	r3, r6
    1764:	dceb      	bgt.n	173e <_Z13DrawTrianglesiPhi+0x72a>
    1766:	9119      	str	r1, [sp, #100]
                j--;
            if (i <= j)
    1768:	4288      	cmp	r0, r1
    176a:	dc00      	bgt.n	176e <_Z13DrawTrianglesiPhi+0x75a>
    176c:	e2c8      	b.n	1d00 <_Z13DrawTrianglesiPhi+0xcec>
    {
        int i = left;
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
    176e:	9a19      	ldr	r2, [sp, #100]
    1770:	9b18      	ldr	r3, [sp, #96]
    1772:	429a      	cmp	r2, r3
    1774:	da21      	bge.n	17ba <_Z13DrawTrianglesiPhi+0x7a6>
                i++;
                j--;
            }
        }

        if (left < j)
    1776:	9a11      	ldr	r2, [sp, #68]
    1778:	9b19      	ldr	r3, [sp, #100]
    177a:	429a      	cmp	r2, r3
    177c:	da00      	bge.n	1780 <_Z13DrawTrianglesiPhi+0x76c>
    177e:	e07f      	b.n	1880 <_Z13DrawTrianglesiPhi+0x86c>
            SortY(left, j);
        if (i < right)
    1780:	9818      	ldr	r0, [sp, #96]
    1782:	9917      	ldr	r1, [sp, #92]
    1784:	4288      	cmp	r0, r1
    1786:	da90      	bge.n	16aa <_Z13DrawTrianglesiPhi+0x696>
    1788:	9011      	str	r0, [sp, #68]
        dst->z = v.z;
    }

    short TriangleMinY(byte ti)
    {
        return _vertexes[_triangles[ti].p0].y;
    178a:	9e11      	ldr	r6, [sp, #68]
    178c:	9817      	ldr	r0, [sp, #92]
    178e:	21fc      	movs	r1, #252
    1790:	1833      	adds	r3, r6, r0
    1792:	105b      	asrs	r3, r3, #1
    1794:	b2db      	uxtb	r3, r3
    1796:	3390      	adds	r3, #144
    1798:	009b      	lsls	r3, r3, #2
    179a:	444b      	add	r3, r9
    179c:	799a      	ldrb	r2, [r3, #6]
    179e:	0049      	lsls	r1, r1, #1
    17a0:	0053      	lsls	r3, r2, #1
    17a2:	189b      	adds	r3, r3, r2
    17a4:	005b      	lsls	r3, r3, #1
    17a6:	444b      	add	r3, r9
    17a8:	185b      	adds	r3, r3, r1
    17aa:	9618      	str	r6, [sp, #96]
    17ac:	9019      	str	r0, [sp, #100]
    17ae:	2208      	movs	r2, #8
    17b0:	5e9e      	ldrsh	r6, [r3, r2]
    {
        int i = left;
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
    17b2:	9818      	ldr	r0, [sp, #96]
    17b4:	9919      	ldr	r1, [sp, #100]
    17b6:	4288      	cmp	r0, r1
    17b8:	dcdd      	bgt.n	1776 <_Z13DrawTrianglesiPhi+0x762>
        {
            while (TriangleMinY(i) < pivot)
    17ba:	ac18      	add	r4, sp, #96
    17bc:	7823      	ldrb	r3, [r4, #0]
    17be:	20fc      	movs	r0, #252
    17c0:	1c1d      	adds	r5, r3, #0
    17c2:	3590      	adds	r5, #144
    17c4:	00ab      	lsls	r3, r5, #2
    17c6:	444b      	add	r3, r9
    17c8:	799a      	ldrb	r2, [r3, #6]
    17ca:	0040      	lsls	r0, r0, #1
    17cc:	0053      	lsls	r3, r2, #1
    17ce:	189b      	adds	r3, r3, r2
    17d0:	005b      	lsls	r3, r3, #1
    17d2:	444b      	add	r3, r9
    17d4:	181b      	adds	r3, r3, r0
    17d6:	2108      	movs	r1, #8
    17d8:	5e5b      	ldrsh	r3, [r3, r1]
    17da:	42b3      	cmp	r3, r6
    17dc:	db01      	blt.n	17e2 <_Z13DrawTrianglesiPhi+0x7ce>
    17de:	e2ad      	b.n	1d3c <_Z13DrawTrianglesiPhi+0xd28>
        dst->z = v.z;
    }

    short TriangleMinY(byte ti)
    {
        return _vertexes[_triangles[ti].p0].y;
    17e0:	9018      	str	r0, [sp, #96]
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
                i++;
    17e2:	9818      	ldr	r0, [sp, #96]
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
    17e4:	24fc      	movs	r4, #252
                i++;
    17e6:	3001      	adds	r0, #1
    17e8:	b2c3      	uxtb	r3, r0
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
    17ea:	1c1d      	adds	r5, r3, #0
    17ec:	3590      	adds	r5, #144
    17ee:	00ab      	lsls	r3, r5, #2
    17f0:	444b      	add	r3, r9
    17f2:	799a      	ldrb	r2, [r3, #6]
    17f4:	0064      	lsls	r4, r4, #1
    17f6:	0053      	lsls	r3, r2, #1
    17f8:	189b      	adds	r3, r3, r2
    17fa:	005b      	lsls	r3, r3, #1
    17fc:	444b      	add	r3, r9
    17fe:	191b      	adds	r3, r3, r4
    1800:	2108      	movs	r1, #8
    1802:	5e5b      	ldrsh	r3, [r3, r1]
    1804:	42b3      	cmp	r3, r6
    1806:	dbeb      	blt.n	17e0 <_Z13DrawTrianglesiPhi+0x7cc>
    1808:	e785      	b.n	1716 <_Z13DrawTrianglesiPhi+0x702>
    180a:	46c0      	nop			(mov r8, r8)
    180c:	00000276 	.word	0x00000276
                i++;
            while (TriangleMinY(j) > pivot)
    1810:	a81a      	add	r0, sp, #104
    1812:	7803      	ldrb	r3, [r0, #0]
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
    1814:	961b      	str	r6, [sp, #108]
                i++;
            while (TriangleMinY(j) > pivot)
    1816:	1c1c      	adds	r4, r3, #0
    1818:	3490      	adds	r4, #144
    181a:	00a3      	lsls	r3, r4, #2
    181c:	444b      	add	r3, r9
    181e:	799a      	ldrb	r2, [r3, #6]
    1820:	21fc      	movs	r1, #252
    1822:	0053      	lsls	r3, r2, #1
    1824:	189b      	adds	r3, r3, r2
    1826:	005b      	lsls	r3, r3, #1
    1828:	444b      	add	r3, r9
    182a:	0049      	lsls	r1, r1, #1
    182c:	185b      	adds	r3, r3, r1
    182e:	2208      	movs	r2, #8
    1830:	5e9b      	ldrsh	r3, [r3, r2]
    1832:	42bb      	cmp	r3, r7
    1834:	dd14      	ble.n	1860 <_Z13DrawTrianglesiPhi+0x84c>
                j--;
    1836:	9b1a      	ldr	r3, [sp, #104]
    1838:	ac1a      	add	r4, sp, #104
    183a:	3b01      	subs	r3, #1
    183c:	931a      	str	r3, [sp, #104]
    183e:	7823      	ldrb	r3, [r4, #0]

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
                i++;
            while (TriangleMinY(j) > pivot)
    1840:	20fc      	movs	r0, #252
    1842:	1c1c      	adds	r4, r3, #0
    1844:	3490      	adds	r4, #144
    1846:	00a3      	lsls	r3, r4, #2
    1848:	444b      	add	r3, r9
    184a:	799a      	ldrb	r2, [r3, #6]
    184c:	0040      	lsls	r0, r0, #1
    184e:	0053      	lsls	r3, r2, #1
    1850:	189b      	adds	r3, r3, r2
    1852:	005b      	lsls	r3, r3, #1
    1854:	444b      	add	r3, r9
    1856:	181b      	adds	r3, r3, r0
    1858:	2108      	movs	r1, #8
    185a:	5e5b      	ldrsh	r3, [r3, r1]
    185c:	42bb      	cmp	r3, r7
    185e:	dcea      	bgt.n	1836 <_Z13DrawTrianglesiPhi+0x822>
                j--;
            if (i <= j)
    1860:	9a1a      	ldr	r2, [sp, #104]
    1862:	4296      	cmp	r6, r2
    1864:	dc00      	bgt.n	1868 <_Z13DrawTrianglesiPhi+0x854>
    1866:	e230      	b.n	1cca <_Z13DrawTrianglesiPhi+0xcb6>
    {
        int i = left;
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
    1868:	42b2      	cmp	r2, r6
    186a:	da21      	bge.n	18b0 <_Z13DrawTrianglesiPhi+0x89c>
                i++;
                j--;
            }
        }

        if (left < j)
    186c:	9b11      	ldr	r3, [sp, #68]
    186e:	9c1a      	ldr	r4, [sp, #104]
    1870:	42a3      	cmp	r3, r4
    1872:	db67      	blt.n	1944 <_Z13DrawTrianglesiPhi+0x930>
            SortY(left, j);
        if (i < right)
    1874:	9c1b      	ldr	r4, [sp, #108]
    1876:	9e19      	ldr	r6, [sp, #100]
    1878:	42b4      	cmp	r4, r6
    187a:	db00      	blt.n	187e <_Z13DrawTrianglesiPhi+0x86a>
    187c:	e780      	b.n	1780 <_Z13DrawTrianglesiPhi+0x76c>
    187e:	9411      	str	r4, [sp, #68]
        dst->z = v.z;
    }

    short TriangleMinY(byte ti)
    {
        return _vertexes[_triangles[ti].p0].y;
    1880:	9c11      	ldr	r4, [sp, #68]
    1882:	9e19      	ldr	r6, [sp, #100]
    1884:	20fc      	movs	r0, #252
    1886:	19a3      	adds	r3, r4, r6
    1888:	105b      	asrs	r3, r3, #1
    188a:	b2db      	uxtb	r3, r3
    188c:	3390      	adds	r3, #144
    188e:	009b      	lsls	r3, r3, #2
    1890:	444b      	add	r3, r9
    1892:	799a      	ldrb	r2, [r3, #6]
    1894:	0040      	lsls	r0, r0, #1
    1896:	0053      	lsls	r3, r2, #1
    1898:	189b      	adds	r3, r3, r2
    189a:	005b      	lsls	r3, r3, #1
    189c:	444b      	add	r3, r9
    189e:	181b      	adds	r3, r3, r0
    18a0:	941b      	str	r4, [sp, #108]
    18a2:	961a      	str	r6, [sp, #104]
    18a4:	2108      	movs	r1, #8
    18a6:	5e5f      	ldrsh	r7, [r3, r1]
    {
        int i = left;
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
    18a8:	9c1b      	ldr	r4, [sp, #108]
    18aa:	9e1a      	ldr	r6, [sp, #104]
    18ac:	42b4      	cmp	r4, r6
    18ae:	dcdd      	bgt.n	186c <_Z13DrawTrianglesiPhi+0x858>
    18b0:	9e1b      	ldr	r6, [sp, #108]
        {
            while (TriangleMinY(i) < pivot)
    18b2:	21fc      	movs	r1, #252
    18b4:	b2f3      	uxtb	r3, r6
    18b6:	1c1d      	adds	r5, r3, #0
    18b8:	3590      	adds	r5, #144
    18ba:	00ab      	lsls	r3, r5, #2
    18bc:	444b      	add	r3, r9
    18be:	799a      	ldrb	r2, [r3, #6]
    18c0:	0049      	lsls	r1, r1, #1
    18c2:	0053      	lsls	r3, r2, #1
    18c4:	189b      	adds	r3, r3, r2
    18c6:	005b      	lsls	r3, r3, #1
    18c8:	444b      	add	r3, r9
    18ca:	185b      	adds	r3, r3, r1
    18cc:	2208      	movs	r2, #8
    18ce:	5e9b      	ldrsh	r3, [r3, r2]
    18d0:	42bb      	cmp	r3, r7
    18d2:	da9d      	bge.n	1810 <_Z13DrawTrianglesiPhi+0x7fc>
                i++;
    18d4:	3601      	adds	r6, #1
    18d6:	b2f3      	uxtb	r3, r6
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
    18d8:	1c1d      	adds	r5, r3, #0
    18da:	3590      	adds	r5, #144
    18dc:	00ab      	lsls	r3, r5, #2
    18de:	444b      	add	r3, r9
    18e0:	799a      	ldrb	r2, [r3, #6]
    18e2:	0053      	lsls	r3, r2, #1
    18e4:	189b      	adds	r3, r3, r2
    18e6:	005b      	lsls	r3, r3, #1
    18e8:	22fc      	movs	r2, #252
    18ea:	444b      	add	r3, r9
    18ec:	0052      	lsls	r2, r2, #1
    18ee:	189b      	adds	r3, r3, r2
    18f0:	2408      	movs	r4, #8
    18f2:	5f1b      	ldrsh	r3, [r3, r4]
    18f4:	42bb      	cmp	r3, r7
    18f6:	dbed      	blt.n	18d4 <_Z13DrawTrianglesiPhi+0x8c0>
    18f8:	e78a      	b.n	1810 <_Z13DrawTrianglesiPhi+0x7fc>
                i++;
            while (TriangleMinY(j) > pivot)
                j--;
    18fa:	9b0d      	ldr	r3, [sp, #52]
    18fc:	3b01      	subs	r3, #1
    18fe:	930d      	str	r3, [sp, #52]

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
                i++;
            while (TriangleMinY(j) > pivot)
    1900:	ac0d      	add	r4, sp, #52
    1902:	7823      	ldrb	r3, [r4, #0]
    1904:	20fc      	movs	r0, #252
    1906:	1c1c      	adds	r4, r3, #0
    1908:	3490      	adds	r4, #144
    190a:	00a3      	lsls	r3, r4, #2
    190c:	444b      	add	r3, r9
    190e:	799a      	ldrb	r2, [r3, #6]
    1910:	0040      	lsls	r0, r0, #1
    1912:	0053      	lsls	r3, r2, #1
    1914:	189b      	adds	r3, r3, r2
    1916:	005b      	lsls	r3, r3, #1
    1918:	444b      	add	r3, r9
    191a:	181b      	adds	r3, r3, r0
    191c:	2208      	movs	r2, #8
    191e:	5e9b      	ldrsh	r3, [r3, r2]
    1920:	42b3      	cmp	r3, r6
    1922:	dcea      	bgt.n	18fa <_Z13DrawTrianglesiPhi+0x8e6>
                j--;
            if (i <= j)
    1924:	9b0f      	ldr	r3, [sp, #60]
    1926:	980d      	ldr	r0, [sp, #52]
    1928:	4283      	cmp	r3, r0
    192a:	dc00      	bgt.n	192e <_Z13DrawTrianglesiPhi+0x91a>
    192c:	e1af      	b.n	1c8e <_Z13DrawTrianglesiPhi+0xc7a>
    {
        int i = left;
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
    192e:	4298      	cmp	r0, r3
    1930:	da22      	bge.n	1978 <_Z13DrawTrianglesiPhi+0x964>
                i++;
                j--;
            }
        }

        if (left < j)
    1932:	9911      	ldr	r1, [sp, #68]
    1934:	9a0d      	ldr	r2, [sp, #52]
    1936:	4291      	cmp	r1, r2
    1938:	db6a      	blt.n	1a10 <_Z13DrawTrianglesiPhi+0x9fc>
            SortY(left, j);
        if (i < right)
    193a:	9a1a      	ldr	r2, [sp, #104]
    193c:	9b0f      	ldr	r3, [sp, #60]
    193e:	429a      	cmp	r2, r3
    1940:	dd98      	ble.n	1874 <_Z13DrawTrianglesiPhi+0x860>
    1942:	9311      	str	r3, [sp, #68]
        dst->z = v.z;
    }

    short TriangleMinY(byte ti)
    {
        return _vertexes[_triangles[ti].p0].y;
    1944:	9e11      	ldr	r6, [sp, #68]
    1946:	981a      	ldr	r0, [sp, #104]
    1948:	21fc      	movs	r1, #252
    194a:	1833      	adds	r3, r6, r0
    194c:	105b      	asrs	r3, r3, #1
    194e:	b2db      	uxtb	r3, r3
    1950:	3390      	adds	r3, #144
    1952:	009b      	lsls	r3, r3, #2
    1954:	444b      	add	r3, r9
    1956:	799a      	ldrb	r2, [r3, #6]
    1958:	0049      	lsls	r1, r1, #1
    195a:	0053      	lsls	r3, r2, #1
    195c:	189b      	adds	r3, r3, r2
    195e:	005b      	lsls	r3, r3, #1
    1960:	444b      	add	r3, r9
    1962:	185b      	adds	r3, r3, r1
    1964:	960f      	str	r6, [sp, #60]
    1966:	900d      	str	r0, [sp, #52]
    1968:	2208      	movs	r2, #8
    196a:	5e9e      	ldrsh	r6, [r3, r2]
    196c:	9b0f      	ldr	r3, [sp, #60]
    196e:	1c04      	adds	r4, r0, #0
    {
        int i = left;
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
    1970:	42a3      	cmp	r3, r4
    1972:	dcde      	bgt.n	1932 <_Z13DrawTrianglesiPhi+0x91e>
    1974:	a80f      	add	r0, sp, #60
    1976:	7801      	ldrb	r1, [r0, #0]
        {
            while (TriangleMinY(i) < pivot)
    1978:	1c0d      	adds	r5, r1, #0
    197a:	3590      	adds	r5, #144
    197c:	00ab      	lsls	r3, r5, #2
    197e:	444b      	add	r3, r9
    1980:	799a      	ldrb	r2, [r3, #6]
    1982:	24fc      	movs	r4, #252
    1984:	0053      	lsls	r3, r2, #1
    1986:	189b      	adds	r3, r3, r2
    1988:	005b      	lsls	r3, r3, #1
    198a:	444b      	add	r3, r9
    198c:	0064      	lsls	r4, r4, #1
    198e:	191b      	adds	r3, r3, r4
    1990:	2008      	movs	r0, #8
    1992:	5e1b      	ldrsh	r3, [r3, r0]
    1994:	42b3      	cmp	r3, r6
    1996:	dab3      	bge.n	1900 <_Z13DrawTrianglesiPhi+0x8ec>
                i++;
    1998:	9b0f      	ldr	r3, [sp, #60]
    199a:	ac0f      	add	r4, sp, #60
    199c:	3301      	adds	r3, #1
    199e:	930f      	str	r3, [sp, #60]
    19a0:	7821      	ldrb	r1, [r4, #0]
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
    19a2:	20fc      	movs	r0, #252
    19a4:	1c0d      	adds	r5, r1, #0
    19a6:	3590      	adds	r5, #144
    19a8:	00ab      	lsls	r3, r5, #2
    19aa:	444b      	add	r3, r9
    19ac:	799a      	ldrb	r2, [r3, #6]
    19ae:	0040      	lsls	r0, r0, #1
    19b0:	0053      	lsls	r3, r2, #1
    19b2:	189b      	adds	r3, r3, r2
    19b4:	005b      	lsls	r3, r3, #1
    19b6:	444b      	add	r3, r9
    19b8:	181b      	adds	r3, r3, r0
    19ba:	2208      	movs	r2, #8
    19bc:	5e9b      	ldrsh	r3, [r3, r2]
    19be:	42b3      	cmp	r3, r6
    19c0:	dbea      	blt.n	1998 <_Z13DrawTrianglesiPhi+0x984>
    19c2:	e79d      	b.n	1900 <_Z13DrawTrianglesiPhi+0x8ec>
                i++;
            while (TriangleMinY(j) > pivot)
    19c4:	aa1c      	add	r2, sp, #112
    19c6:	7813      	ldrb	r3, [r2, #0]
    19c8:	e004      	b.n	19d4 <_Z13DrawTrianglesiPhi+0x9c0>
                j--;
    19ca:	9a1c      	ldr	r2, [sp, #112]
    19cc:	ac1c      	add	r4, sp, #112
    19ce:	3a01      	subs	r2, #1
    19d0:	921c      	str	r2, [sp, #112]
    19d2:	7823      	ldrb	r3, [r4, #0]

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
                i++;
            while (TriangleMinY(j) > pivot)
    19d4:	1c1c      	adds	r4, r3, #0
    19d6:	3490      	adds	r4, #144
    19d8:	00a3      	lsls	r3, r4, #2
    19da:	444b      	add	r3, r9
    19dc:	799a      	ldrb	r2, [r3, #6]
    19de:	20fc      	movs	r0, #252
    19e0:	0053      	lsls	r3, r2, #1
    19e2:	189b      	adds	r3, r3, r2
    19e4:	005b      	lsls	r3, r3, #1
    19e6:	444b      	add	r3, r9
    19e8:	0040      	lsls	r0, r0, #1
    19ea:	181b      	adds	r3, r3, r0
    19ec:	2108      	movs	r1, #8
    19ee:	5e5b      	ldrsh	r3, [r3, r1]
    19f0:	42b3      	cmp	r3, r6
    19f2:	dcea      	bgt.n	19ca <_Z13DrawTrianglesiPhi+0x9b6>
                j--;
            if (i <= j)
    19f4:	9a1d      	ldr	r2, [sp, #116]
    19f6:	9b1c      	ldr	r3, [sp, #112]
    19f8:	429a      	cmp	r2, r3
    19fa:	dc00      	bgt.n	19fe <_Z13DrawTrianglesiPhi+0x9ea>
    19fc:	e124      	b.n	1c48 <_Z13DrawTrianglesiPhi+0xc34>
                i++;
                j--;
            }
        }

        if (left < j)
    19fe:	9a11      	ldr	r2, [sp, #68]
    1a00:	9b1c      	ldr	r3, [sp, #112]
    1a02:	429a      	cmp	r2, r3
    1a04:	db58      	blt.n	1ab8 <_Z13DrawTrianglesiPhi+0xaa4>
            SortY(left, j);
        if (i < right)
    1a06:	980d      	ldr	r0, [sp, #52]
    1a08:	991d      	ldr	r1, [sp, #116]
    1a0a:	4288      	cmp	r0, r1
    1a0c:	dd95      	ble.n	193a <_Z13DrawTrianglesiPhi+0x926>
    1a0e:	9111      	str	r1, [sp, #68]
        dst->z = v.z;
    }

    short TriangleMinY(byte ti)
    {
        return _vertexes[_triangles[ti].p0].y;
    1a10:	9c11      	ldr	r4, [sp, #68]
    1a12:	9e0d      	ldr	r6, [sp, #52]
    1a14:	20fc      	movs	r0, #252
    1a16:	19a3      	adds	r3, r4, r6
    1a18:	105b      	asrs	r3, r3, #1
    1a1a:	b2db      	uxtb	r3, r3
    1a1c:	3390      	adds	r3, #144
    1a1e:	009b      	lsls	r3, r3, #2
    1a20:	444b      	add	r3, r9
    1a22:	799a      	ldrb	r2, [r3, #6]
    1a24:	0040      	lsls	r0, r0, #1
    1a26:	0053      	lsls	r3, r2, #1
    1a28:	189b      	adds	r3, r3, r2
    1a2a:	005b      	lsls	r3, r3, #1
    1a2c:	961c      	str	r6, [sp, #112]
    1a2e:	444b      	add	r3, r9
    1a30:	181b      	adds	r3, r3, r0
    1a32:	941d      	str	r4, [sp, #116]
    1a34:	9a1c      	ldr	r2, [sp, #112]
    1a36:	2108      	movs	r1, #8
    1a38:	5e5e      	ldrsh	r6, [r3, r1]
    1a3a:	1c21      	adds	r1, r4, #0
    {
        int i = left;
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
    1a3c:	4291      	cmp	r1, r2
    1a3e:	dd03      	ble.n	1a48 <_Z13DrawTrianglesiPhi+0xa34>
    1a40:	e7dd      	b.n	19fe <_Z13DrawTrianglesiPhi+0x9ea>
        {
            while (TriangleMinY(i) < pivot)
                i++;
    1a42:	9a1d      	ldr	r2, [sp, #116]
    1a44:	3201      	adds	r2, #1
    1a46:	921d      	str	r2, [sp, #116]
    1a48:	ac1d      	add	r4, sp, #116
    1a4a:	7823      	ldrb	r3, [r4, #0]
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
    1a4c:	20fc      	movs	r0, #252
    1a4e:	1c1d      	adds	r5, r3, #0
    1a50:	3590      	adds	r5, #144
    1a52:	00ab      	lsls	r3, r5, #2
    1a54:	444b      	add	r3, r9
    1a56:	799a      	ldrb	r2, [r3, #6]
    1a58:	0040      	lsls	r0, r0, #1
    1a5a:	0053      	lsls	r3, r2, #1
    1a5c:	189b      	adds	r3, r3, r2
    1a5e:	005b      	lsls	r3, r3, #1
    1a60:	444b      	add	r3, r9
    1a62:	181b      	adds	r3, r3, r0
    1a64:	2108      	movs	r1, #8
    1a66:	5e5b      	ldrsh	r3, [r3, r1]
    1a68:	42b3      	cmp	r3, r6
    1a6a:	dbea      	blt.n	1a42 <_Z13DrawTrianglesiPhi+0xa2e>
    1a6c:	e7aa      	b.n	19c4 <_Z13DrawTrianglesiPhi+0x9b0>
                i++;
            while (TriangleMinY(j) > pivot)
    1a6e:	4652      	mov	r2, sl
    1a70:	b2d3      	uxtb	r3, r2
    1a72:	e004      	b.n	1a7e <_Z13DrawTrianglesiPhi+0xa6a>
                j--;
    1a74:	2301      	movs	r3, #1
    1a76:	425b      	negs	r3, r3
    1a78:	449a      	add	sl, r3
    1a7a:	4654      	mov	r4, sl
    1a7c:	b2e3      	uxtb	r3, r4

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
                i++;
            while (TriangleMinY(j) > pivot)
    1a7e:	1c1c      	adds	r4, r3, #0
    1a80:	3490      	adds	r4, #144
    1a82:	00a3      	lsls	r3, r4, #2
    1a84:	444b      	add	r3, r9
    1a86:	799a      	ldrb	r2, [r3, #6]
    1a88:	20fc      	movs	r0, #252
    1a8a:	0053      	lsls	r3, r2, #1
    1a8c:	189b      	adds	r3, r3, r2
    1a8e:	005b      	lsls	r3, r3, #1
    1a90:	444b      	add	r3, r9
    1a92:	0040      	lsls	r0, r0, #1
    1a94:	181b      	adds	r3, r3, r0
    1a96:	2208      	movs	r2, #8
    1a98:	5e9b      	ldrsh	r3, [r3, r2]
    1a9a:	42b3      	cmp	r3, r6
    1a9c:	dcea      	bgt.n	1a74 <_Z13DrawTrianglesiPhi+0xa60>
                j--;
            if (i <= j)
    1a9e:	45d3      	cmp	fp, sl
    1aa0:	dc00      	bgt.n	1aa4 <_Z13DrawTrianglesiPhi+0xa90>
    1aa2:	e0b6      	b.n	1c12 <_Z13DrawTrianglesiPhi+0xbfe>
    {
        int i = left;
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
    1aa4:	45da      	cmp	sl, fp
    1aa6:	da1f      	bge.n	1ae8 <_Z13DrawTrianglesiPhi+0xad4>
                i++;
                j--;
            }
        }

        if (left < j)
    1aa8:	9e11      	ldr	r6, [sp, #68]
    1aaa:	4556      	cmp	r6, sl
    1aac:	db5e      	blt.n	1b6c <_Z13DrawTrianglesiPhi+0xb58>
            SortY(left, j);
        if (i < right)
    1aae:	9a1c      	ldr	r2, [sp, #112]
    1ab0:	455a      	cmp	r2, fp
    1ab2:	dda8      	ble.n	1a06 <_Z13DrawTrianglesiPhi+0x9f2>
    1ab4:	465b      	mov	r3, fp
    1ab6:	9311      	str	r3, [sp, #68]
        dst->z = v.z;
    }

    short TriangleMinY(byte ti)
    {
        return _vertexes[_triangles[ti].p0].y;
    1ab8:	9e1c      	ldr	r6, [sp, #112]
    1aba:	9c11      	ldr	r4, [sp, #68]
    1abc:	20fc      	movs	r0, #252
    1abe:	19a3      	adds	r3, r4, r6
    1ac0:	105b      	asrs	r3, r3, #1
    1ac2:	b2db      	uxtb	r3, r3
    1ac4:	3390      	adds	r3, #144
    1ac6:	009b      	lsls	r3, r3, #2
    1ac8:	444b      	add	r3, r9
    1aca:	799a      	ldrb	r2, [r3, #6]
    1acc:	0040      	lsls	r0, r0, #1
    1ace:	0053      	lsls	r3, r2, #1
    1ad0:	189b      	adds	r3, r3, r2
    1ad2:	005b      	lsls	r3, r3, #1
    1ad4:	444b      	add	r3, r9
    1ad6:	181b      	adds	r3, r3, r0
    1ad8:	46b2      	mov	sl, r6
    1ada:	2108      	movs	r1, #8
    1adc:	5e5e      	ldrsh	r6, [r3, r1]
    1ade:	46a3      	mov	fp, r4
    {
        int i = left;
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
    1ae0:	45d3      	cmp	fp, sl
    1ae2:	dce1      	bgt.n	1aa8 <_Z13DrawTrianglesiPhi+0xa94>
    1ae4:	4658      	mov	r0, fp
    1ae6:	b2c1      	uxtb	r1, r0
        {
            while (TriangleMinY(i) < pivot)
    1ae8:	1c0d      	adds	r5, r1, #0
    1aea:	3590      	adds	r5, #144
    1aec:	00ab      	lsls	r3, r5, #2
    1aee:	444b      	add	r3, r9
    1af0:	799a      	ldrb	r2, [r3, #6]
    1af2:	0053      	lsls	r3, r2, #1
    1af4:	189b      	adds	r3, r3, r2
    1af6:	005b      	lsls	r3, r3, #1
    1af8:	22fc      	movs	r2, #252
    1afa:	444b      	add	r3, r9
    1afc:	0052      	lsls	r2, r2, #1
    1afe:	189b      	adds	r3, r3, r2
    1b00:	2408      	movs	r4, #8
    1b02:	5f1b      	ldrsh	r3, [r3, r4]
    1b04:	42b3      	cmp	r3, r6
    1b06:	dab2      	bge.n	1a6e <_Z13DrawTrianglesiPhi+0xa5a>
                i++;
    1b08:	2201      	movs	r2, #1
    1b0a:	4493      	add	fp, r2
    1b0c:	465b      	mov	r3, fp
    1b0e:	b2d9      	uxtb	r1, r3
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
    1b10:	1c0d      	adds	r5, r1, #0
    1b12:	3590      	adds	r5, #144
    1b14:	00ab      	lsls	r3, r5, #2
    1b16:	444b      	add	r3, r9
    1b18:	799a      	ldrb	r2, [r3, #6]
    1b1a:	24fc      	movs	r4, #252
    1b1c:	0053      	lsls	r3, r2, #1
    1b1e:	189b      	adds	r3, r3, r2
    1b20:	005b      	lsls	r3, r3, #1
    1b22:	444b      	add	r3, r9
    1b24:	0064      	lsls	r4, r4, #1
    1b26:	191b      	adds	r3, r3, r4
    1b28:	2008      	movs	r0, #8
    1b2a:	5e1b      	ldrsh	r3, [r3, r0]
    1b2c:	42b3      	cmp	r3, r6
    1b2e:	dbeb      	blt.n	1b08 <_Z13DrawTrianglesiPhi+0xaf4>
    1b30:	e79d      	b.n	1a6e <_Z13DrawTrianglesiPhi+0xa5a>
                i++;
            while (TriangleMinY(j) > pivot)
                j--;
    1b32:	3e01      	subs	r6, #1

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
                i++;
            while (TriangleMinY(j) > pivot)
    1b34:	b2f3      	uxtb	r3, r6
    1b36:	1c1c      	adds	r4, r3, #0
    1b38:	3490      	adds	r4, #144
    1b3a:	00a3      	lsls	r3, r4, #2
    1b3c:	444b      	add	r3, r9
    1b3e:	799a      	ldrb	r2, [r3, #6]
    1b40:	20fc      	movs	r0, #252
    1b42:	0053      	lsls	r3, r2, #1
    1b44:	189b      	adds	r3, r3, r2
    1b46:	005b      	lsls	r3, r3, #1
    1b48:	444b      	add	r3, r9
    1b4a:	0040      	lsls	r0, r0, #1
    1b4c:	181b      	adds	r3, r3, r0
    1b4e:	2208      	movs	r2, #8
    1b50:	5e9b      	ldrsh	r3, [r3, r2]
    1b52:	4543      	cmp	r3, r8
    1b54:	dced      	bgt.n	1b32 <_Z13DrawTrianglesiPhi+0xb1e>
                j--;
            if (i <= j)
    1b56:	42b7      	cmp	r7, r6
    1b58:	dd43      	ble.n	1be2 <_Z13DrawTrianglesiPhi+0xbce>
    {
        int i = left;
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
    1b5a:	42be      	cmp	r6, r7
    1b5c:	da1e      	bge.n	1b9c <_Z13DrawTrianglesiPhi+0xb88>
                i++;
                j--;
            }
        }

        if (left < j)
    1b5e:	9911      	ldr	r1, [sp, #68]
    1b60:	42b1      	cmp	r1, r6
    1b62:	da00      	bge.n	1b66 <_Z13DrawTrianglesiPhi+0xb52>
    1b64:	e08e      	b.n	1c84 <_Z13DrawTrianglesiPhi+0xc70>
            SortY(left, j);
        if (i < right)
    1b66:	45ba      	cmp	sl, r7
    1b68:	dda1      	ble.n	1aae <_Z13DrawTrianglesiPhi+0xa9a>
    1b6a:	9711      	str	r7, [sp, #68]
        dst->z = v.z;
    }

    short TriangleMinY(byte ti)
    {
        return _vertexes[_triangles[ti].p0].y;
    1b6c:	9811      	ldr	r0, [sp, #68]
    1b6e:	21fc      	movs	r1, #252
    1b70:	1c03      	adds	r3, r0, #0
    1b72:	4453      	add	r3, sl
    1b74:	105b      	asrs	r3, r3, #1
    1b76:	b2db      	uxtb	r3, r3
    1b78:	3390      	adds	r3, #144
    1b7a:	009b      	lsls	r3, r3, #2
    1b7c:	444b      	add	r3, r9
    1b7e:	799a      	ldrb	r2, [r3, #6]
    1b80:	0049      	lsls	r1, r1, #1
    1b82:	0053      	lsls	r3, r2, #1
    1b84:	189b      	adds	r3, r3, r2
    1b86:	005b      	lsls	r3, r3, #1
    1b88:	444b      	add	r3, r9
    1b8a:	185b      	adds	r3, r3, r1
    1b8c:	2408      	movs	r4, #8
    1b8e:	5f1a      	ldrsh	r2, [r3, r4]
    1b90:	1c07      	adds	r7, r0, #0
    1b92:	4656      	mov	r6, sl
    1b94:	4690      	mov	r8, r2
    {
        int i = left;
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
    1b96:	42b7      	cmp	r7, r6
    1b98:	dce1      	bgt.n	1b5e <_Z13DrawTrianglesiPhi+0xb4a>
    1b9a:	b2f9      	uxtb	r1, r7
        {
            while (TriangleMinY(i) < pivot)
    1b9c:	1c0d      	adds	r5, r1, #0
    1b9e:	3590      	adds	r5, #144
    1ba0:	00ab      	lsls	r3, r5, #2
    1ba2:	444b      	add	r3, r9
    1ba4:	799a      	ldrb	r2, [r3, #6]
    1ba6:	24fc      	movs	r4, #252
    1ba8:	0053      	lsls	r3, r2, #1
    1baa:	189b      	adds	r3, r3, r2
    1bac:	005b      	lsls	r3, r3, #1
    1bae:	444b      	add	r3, r9
    1bb0:	0064      	lsls	r4, r4, #1
    1bb2:	191b      	adds	r3, r3, r4
    1bb4:	2008      	movs	r0, #8
    1bb6:	5e1b      	ldrsh	r3, [r3, r0]
    1bb8:	4543      	cmp	r3, r8
    1bba:	dabb      	bge.n	1b34 <_Z13DrawTrianglesiPhi+0xb20>
                i++;
    1bbc:	3701      	adds	r7, #1
    1bbe:	b2f9      	uxtb	r1, r7
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
    1bc0:	1c0d      	adds	r5, r1, #0
    1bc2:	3590      	adds	r5, #144
    1bc4:	00ab      	lsls	r3, r5, #2
    1bc6:	444b      	add	r3, r9
    1bc8:	799a      	ldrb	r2, [r3, #6]
    1bca:	20fc      	movs	r0, #252
    1bcc:	0053      	lsls	r3, r2, #1
    1bce:	189b      	adds	r3, r3, r2
    1bd0:	005b      	lsls	r3, r3, #1
    1bd2:	444b      	add	r3, r9
    1bd4:	0040      	lsls	r0, r0, #1
    1bd6:	181b      	adds	r3, r3, r0
    1bd8:	2208      	movs	r2, #8
    1bda:	5e9b      	ldrsh	r3, [r3, r2]
    1bdc:	4543      	cmp	r3, r8
    1bde:	dbed      	blt.n	1bbc <_Z13DrawTrianglesiPhi+0xba8>
    1be0:	e7a8      	b.n	1b34 <_Z13DrawTrianglesiPhi+0xb20>
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
    1be2:	00ad      	lsls	r5, r5, #2
    1be4:	444d      	add	r5, r9
        t[i] = t[j];
    1be6:	00a4      	lsls	r4, r4, #2
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
    1be8:	3506      	adds	r5, #6
        t[i] = t[j];
    1bea:	444c      	add	r4, r9
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
    1bec:	1c29      	adds	r1, r5, #0
    1bee:	2204      	movs	r2, #4
        t[i] = t[j];
    1bf0:	3406      	adds	r4, #6
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
    1bf2:	a841      	add	r0, sp, #260
    1bf4:	f001 f960 	bl	2eb8 <memcpy>
        t[i] = t[j];
    1bf8:	1c21      	adds	r1, r4, #0
    1bfa:	2204      	movs	r2, #4
    1bfc:	1c28      	adds	r0, r5, #0
    1bfe:	f001 f95b 	bl	2eb8 <memcpy>
        t[j] = tmp;
    1c02:	1c20      	adds	r0, r4, #0
    1c04:	a941      	add	r1, sp, #260
    1c06:	2204      	movs	r2, #4
    1c08:	f001 f956 	bl	2eb8 <memcpy>
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
    1c0c:	3701      	adds	r7, #1
                j--;
    1c0e:	3e01      	subs	r6, #1
    1c10:	e7c1      	b.n	1b96 <_Z13DrawTrianglesiPhi+0xb82>
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
    1c12:	00ad      	lsls	r5, r5, #2
    1c14:	444d      	add	r5, r9
        t[i] = t[j];
    1c16:	00a4      	lsls	r4, r4, #2
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
    1c18:	3506      	adds	r5, #6
        t[i] = t[j];
    1c1a:	444c      	add	r4, r9
    1c1c:	3406      	adds	r4, #6
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
    1c1e:	1c29      	adds	r1, r5, #0
    1c20:	2204      	movs	r2, #4
    1c22:	a841      	add	r0, sp, #260
    1c24:	f001 f948 	bl	2eb8 <memcpy>
        t[i] = t[j];
    1c28:	1c21      	adds	r1, r4, #0
    1c2a:	2204      	movs	r2, #4
    1c2c:	1c28      	adds	r0, r5, #0
    1c2e:	f001 f943 	bl	2eb8 <memcpy>
        t[j] = tmp;
    1c32:	1c20      	adds	r0, r4, #0
    1c34:	a941      	add	r1, sp, #260
    1c36:	2204      	movs	r2, #4
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
                j--;
    1c38:	2401      	movs	r4, #1
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
        t[i] = t[j];
        t[j] = tmp;
    1c3a:	f001 f93d 	bl	2eb8 <memcpy>
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
                j--;
    1c3e:	4264      	negs	r4, r4
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
    1c40:	2301      	movs	r3, #1
    1c42:	449b      	add	fp, r3
                j--;
    1c44:	44a2      	add	sl, r4
    1c46:	e74b      	b.n	1ae0 <_Z13DrawTrianglesiPhi+0xacc>
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
    1c48:	00ad      	lsls	r5, r5, #2
    1c4a:	444d      	add	r5, r9
        t[i] = t[j];
    1c4c:	00a4      	lsls	r4, r4, #2
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
    1c4e:	3506      	adds	r5, #6
        t[i] = t[j];
    1c50:	444c      	add	r4, r9
    1c52:	3406      	adds	r4, #6
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
    1c54:	1c29      	adds	r1, r5, #0
    1c56:	2204      	movs	r2, #4
    1c58:	a841      	add	r0, sp, #260
    1c5a:	f001 f92d 	bl	2eb8 <memcpy>
        t[i] = t[j];
    1c5e:	1c21      	adds	r1, r4, #0
    1c60:	2204      	movs	r2, #4
    1c62:	1c28      	adds	r0, r5, #0
    1c64:	f001 f928 	bl	2eb8 <memcpy>
        t[j] = tmp;
    1c68:	1c20      	adds	r0, r4, #0
    1c6a:	a941      	add	r1, sp, #260
    1c6c:	2204      	movs	r2, #4
    1c6e:	f001 f923 	bl	2eb8 <memcpy>
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
    1c72:	9c1d      	ldr	r4, [sp, #116]
                j--;
    1c74:	981c      	ldr	r0, [sp, #112]
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
    1c76:	3401      	adds	r4, #1
                j--;
    1c78:	3801      	subs	r0, #1
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
    1c7a:	941d      	str	r4, [sp, #116]
                j--;
    1c7c:	901c      	str	r0, [sp, #112]
    1c7e:	1c21      	adds	r1, r4, #0
    1c80:	1c02      	adds	r2, r0, #0
    1c82:	e6db      	b.n	1a3c <_Z13DrawTrianglesiPhi+0xa28>
            }
        }

        if (left < j)
            SortY(left, j);
    1c84:	4648      	mov	r0, r9
    1c86:	1c32      	adds	r2, r6, #0
    1c88:	f7fe fd46 	bl	718 <_ZN8Renderer5SortYEii>
    1c8c:	e76b      	b.n	1b66 <_Z13DrawTrianglesiPhi+0xb52>
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
    1c8e:	00ad      	lsls	r5, r5, #2
    1c90:	444d      	add	r5, r9
        t[i] = t[j];
    1c92:	00a4      	lsls	r4, r4, #2
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
    1c94:	3506      	adds	r5, #6
        t[i] = t[j];
    1c96:	444c      	add	r4, r9
    1c98:	3406      	adds	r4, #6
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
    1c9a:	1c29      	adds	r1, r5, #0
    1c9c:	2204      	movs	r2, #4
    1c9e:	a841      	add	r0, sp, #260
    1ca0:	f001 f90a 	bl	2eb8 <memcpy>
        t[i] = t[j];
    1ca4:	1c21      	adds	r1, r4, #0
    1ca6:	2204      	movs	r2, #4
    1ca8:	1c28      	adds	r0, r5, #0
    1caa:	f001 f905 	bl	2eb8 <memcpy>
        t[j] = tmp;
    1cae:	1c20      	adds	r0, r4, #0
    1cb0:	a941      	add	r1, sp, #260
    1cb2:	2204      	movs	r2, #4
    1cb4:	f001 f900 	bl	2eb8 <memcpy>
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
    1cb8:	990f      	ldr	r1, [sp, #60]
                j--;
    1cba:	9a0d      	ldr	r2, [sp, #52]
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
    1cbc:	3101      	adds	r1, #1
                j--;
    1cbe:	3a01      	subs	r2, #1
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
    1cc0:	910f      	str	r1, [sp, #60]
                j--;
    1cc2:	920d      	str	r2, [sp, #52]
    1cc4:	1c0b      	adds	r3, r1, #0
    1cc6:	1c14      	adds	r4, r2, #0
    1cc8:	e652      	b.n	1970 <_Z13DrawTrianglesiPhi+0x95c>
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
    1cca:	00ad      	lsls	r5, r5, #2
    1ccc:	444d      	add	r5, r9
        t[i] = t[j];
    1cce:	00a4      	lsls	r4, r4, #2
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
    1cd0:	3506      	adds	r5, #6
        t[i] = t[j];
    1cd2:	444c      	add	r4, r9
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
    1cd4:	1c29      	adds	r1, r5, #0
    1cd6:	2204      	movs	r2, #4
        t[i] = t[j];
    1cd8:	3406      	adds	r4, #6
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
    1cda:	a841      	add	r0, sp, #260
    1cdc:	f001 f8ec 	bl	2eb8 <memcpy>
        t[i] = t[j];
    1ce0:	1c21      	adds	r1, r4, #0
    1ce2:	2204      	movs	r2, #4
    1ce4:	1c28      	adds	r0, r5, #0
    1ce6:	f001 f8e7 	bl	2eb8 <memcpy>
        t[j] = tmp;
    1cea:	1c20      	adds	r0, r4, #0
    1cec:	a941      	add	r1, sp, #260
    1cee:	2204      	movs	r2, #4
    1cf0:	f001 f8e2 	bl	2eb8 <memcpy>
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
                j--;
    1cf4:	9b1a      	ldr	r3, [sp, #104]
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
    1cf6:	3601      	adds	r6, #1
                j--;
    1cf8:	3b01      	subs	r3, #1
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
    1cfa:	961b      	str	r6, [sp, #108]
                j--;
    1cfc:	931a      	str	r3, [sp, #104]
    1cfe:	e5d3      	b.n	18a8 <_Z13DrawTrianglesiPhi+0x894>
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
    1d00:	00ad      	lsls	r5, r5, #2
    1d02:	444d      	add	r5, r9
        t[i] = t[j];
    1d04:	00a4      	lsls	r4, r4, #2
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
    1d06:	3506      	adds	r5, #6
        t[i] = t[j];
    1d08:	444c      	add	r4, r9
    1d0a:	3406      	adds	r4, #6
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
    1d0c:	1c29      	adds	r1, r5, #0
    1d0e:	2204      	movs	r2, #4
    1d10:	a841      	add	r0, sp, #260
    1d12:	f001 f8d1 	bl	2eb8 <memcpy>
        t[i] = t[j];
    1d16:	1c21      	adds	r1, r4, #0
    1d18:	2204      	movs	r2, #4
    1d1a:	1c28      	adds	r0, r5, #0
    1d1c:	f001 f8cc 	bl	2eb8 <memcpy>
        t[j] = tmp;
    1d20:	1c20      	adds	r0, r4, #0
    1d22:	a941      	add	r1, sp, #260
    1d24:	2204      	movs	r2, #4
    1d26:	f001 f8c7 	bl	2eb8 <memcpy>
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
    1d2a:	9b18      	ldr	r3, [sp, #96]
                j--;
    1d2c:	9c19      	ldr	r4, [sp, #100]
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
    1d2e:	3301      	adds	r3, #1
                j--;
    1d30:	3c01      	subs	r4, #1
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
    1d32:	9318      	str	r3, [sp, #96]
                j--;
    1d34:	9419      	str	r4, [sp, #100]
    1d36:	e53c      	b.n	17b2 <_Z13DrawTrianglesiPhi+0x79e>

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
                i++;
            while (TriangleMinY(j) > pivot)
    1d38:	9919      	ldr	r1, [sp, #100]
    1d3a:	e515      	b.n	1768 <_Z13DrawTrianglesiPhi+0x754>
        int j = right;
        short pivot = TriangleMinY((left + right) >> 1);

        while (i <= j)
        {
            while (TriangleMinY(i) < pivot)
    1d3c:	9818      	ldr	r0, [sp, #96]
    1d3e:	e4eb      	b.n	1718 <_Z13DrawTrianglesiPhi+0x704>
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
    1d40:	00ad      	lsls	r5, r5, #2
    1d42:	444d      	add	r5, r9
        t[i] = t[j];
    1d44:	00a4      	lsls	r4, r4, #2
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
    1d46:	3506      	adds	r5, #6
        t[i] = t[j];
    1d48:	444c      	add	r4, r9
    1d4a:	3406      	adds	r4, #6
    }
    
    void TriangleSwap(byte i, byte j)
    {
        Triangle* t = _triangles;
        Triangle tmp = t[i];
    1d4c:	1c29      	adds	r1, r5, #0
    1d4e:	2204      	movs	r2, #4
    1d50:	a841      	add	r0, sp, #260
    1d52:	f001 f8b1 	bl	2eb8 <memcpy>
        t[i] = t[j];
    1d56:	1c21      	adds	r1, r4, #0
    1d58:	2204      	movs	r2, #4
    1d5a:	1c28      	adds	r0, r5, #0
    1d5c:	f001 f8ac 	bl	2eb8 <memcpy>
        t[j] = tmp;
    1d60:	1c20      	adds	r0, r4, #0
    1d62:	a941      	add	r1, sp, #260
    1d64:	2204      	movs	r2, #4
    1d66:	f001 f8a7 	bl	2eb8 <memcpy>
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
    1d6a:	9c16      	ldr	r4, [sp, #88]
                j--;
    1d6c:	9817      	ldr	r0, [sp, #92]
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
    1d6e:	3401      	adds	r4, #1
                j--;
    1d70:	3801      	subs	r0, #1
            while (TriangleMinY(j) > pivot)
                j--;
            if (i <= j)
            {
                TriangleSwap(i,j);
                i++;
    1d72:	9416      	str	r4, [sp, #88]
                j--;
    1d74:	9017      	str	r0, [sp, #92]
    1d76:	e4b1      	b.n	16dc <_Z13DrawTrianglesiPhi+0x6c8>

00001d78 <_Z17DrawTrianglesLoopPhS_>:
	_hackyColor = i+3;
	const Model* model = _models[i];
	m->Draw(keys,(Triangle*)model->Triangles,model->TriangleCount,(Vec3Char*)model->Vertexes,model->VertexCount);
}

u8* DrawTrianglesLoop(u8* appBuffer, u8* runs)
    1d78:	b5f0      	push	{r4, r5, r6, r7, lr}
    1d7a:	465f      	mov	r7, fp
    1d7c:	4656      	mov	r6, sl
    1d7e:	464d      	mov	r5, r9
    1d80:	4644      	mov	r4, r8
    1d82:	b4f0      	push	{r4, r5, r6, r7}
    1d84:	b0ad      	sub	sp, #180
    1d86:	4681      	mov	r9, r0
    1d88:	910d      	str	r1, [sp, #52]
		//_hacky = _y;
	}

	u8* DrawLoop(u8* runs)
	{
		if (_head.Next == &_tail && _newEdgeList == 0)
    1d8a:	4649      	mov	r1, r9
    1d8c:	6b4b      	ldr	r3, [r1, #52]
    1d8e:	3048      	adds	r0, #72
    1d90:	9015      	str	r0, [sp, #84]
    1d92:	4283      	cmp	r3, r0
    1d94:	d101      	bne.n	1d9a <_Z17DrawTrianglesLoopPhS_+0x22>
    1d96:	f000 fc0b 	bl	25b0 <_Z17DrawTrianglesLoopPhS_+0x838>
            else
                return 0;
        }
        
        // Activate triangles, insert edges into new edge list
        if (_nextY <= _y)
    1d9a:	21b3      	movs	r1, #179
    1d9c:	23b2      	movs	r3, #178
    1d9e:	4648      	mov	r0, r9
    1da0:	0089      	lsls	r1, r1, #2
    1da2:	009b      	lsls	r3, r3, #2
}

u8* DrawTrianglesLoop(u8* appBuffer, u8* runs)
{    
    ModelState* m = (ModelState*)appBuffer;
	return m->_r.DrawLoop(runs);
    1da4:	2730      	movs	r7, #48
            else
                return 0;
        }
        
        // Activate triangles, insert edges into new edge list
        if (_nextY <= _y)
    1da6:	5842      	ldr	r2, [r0, r1]
    1da8:	58c5      	ldr	r5, [r0, r3]
}

u8* DrawTrianglesLoop(u8* appBuffer, u8* runs)
{    
    ModelState* m = (ModelState*)appBuffer;
	return m->_r.DrawLoop(runs);
    1daa:	46ba      	mov	sl, r7
    1dac:	44ca      	add	sl, r9
            else
                return 0;
        }
        
        // Activate triangles, insert edges into new edge list
        if (_nextY <= _y)
    1dae:	42aa      	cmp	r2, r5
    1db0:	dd00      	ble.n	1db4 <_Z17DrawTrianglesLoopPhS_+0x3c>
    1db2:	e097      	b.n	1ee4 <_Z17DrawTrianglesLoopPhS_+0x16c>
        {
            while (_triangleIndex < _triangleCount)
    1db4:	24b4      	movs	r4, #180
    1db6:	4ec5      	ldr	r6, [pc, #788]	(20cc <_Z17DrawTrianglesLoopPhS_+0x354>)
    1db8:	00a4      	lsls	r4, r4, #2
    1dba:	464a      	mov	r2, r9
    1dbc:	5900      	ldr	r0, [r0, r4]
    1dbe:	5d93      	ldrb	r3, [r2, r6]
    1dc0:	4298      	cmp	r0, r3
    1dc2:	db00      	blt.n	1dc6 <_Z17DrawTrianglesLoopPhS_+0x4e>
    1dc4:	e08e      	b.n	1ee4 <_Z17DrawTrianglesLoopPhS_+0x16c>
            {
				int ti = _triangleIndex;
                Triangle& t = _triangles[ti];
                _nextY = CEIL(_vertexes[t.p0].y);
    1dc6:	239c      	movs	r3, #156
    1dc8:	181b      	adds	r3, r3, r0
    1dca:	469b      	mov	fp, r3
    1dcc:	009b      	lsls	r3, r3, #2
    1dce:	444b      	add	r3, r9
    1dd0:	799a      	ldrb	r2, [r3, #6]
    1dd2:	278a      	movs	r7, #138
    1dd4:	0053      	lsls	r3, r2, #1
    1dd6:	189b      	adds	r3, r3, r2
    1dd8:	005b      	lsls	r3, r3, #1
    1dda:	00bf      	lsls	r7, r7, #2
    1ddc:	444b      	add	r3, r9
    1dde:	19db      	adds	r3, r3, r7
    1de0:	2208      	movs	r2, #8
    1de2:	5e9b      	ldrsh	r3, [r3, r2]
    1de4:	464f      	mov	r7, r9
    1de6:	3310      	adds	r3, #16
    1de8:	111b      	asrs	r3, r3, #4
    1dea:	507b      	str	r3, [r7, r1]
                if (_nextY > _y)
    1dec:	42ab      	cmp	r3, r5
    1dee:	dc79      	bgt.n	1ee4 <_Z17DrawTrianglesLoopPhS_+0x16c>
    //  Activate edge
    bool Setup(byte p0, byte p1, byte ti, bool left)
    {
        //  Does the edge already exist?
        //  Only need to search the new Edge list, can only match newly created edges
        Edge* e = _newEdgeList;
    1df0:	27da      	movs	r7, #218
        _tail.Prev = &_head;
    }
    
    Edge* NewEdge()
    {
        if (_freeList == 0)
    1df2:	22d8      	movs	r2, #216
            e->leftTriangle = 0xFF;
        }
        else
        {
            e->leftTriangle = ti;
            e->rightTriangle = 0xFF;
    1df4:	2301      	movs	r3, #1
    //  Activate edge
    bool Setup(byte p0, byte p1, byte ti, bool left)
    {
        //  Does the edge already exist?
        //  Only need to search the new Edge list, can only match newly created edges
        Edge* e = _newEdgeList;
    1df6:	007f      	lsls	r7, r7, #1
        _tail.Prev = &_head;
    }
    
    Edge* NewEdge()
    {
        if (_freeList == 0)
    1df8:	0052      	lsls	r2, r2, #1
            e->leftTriangle = 0xFF;
        }
        else
        {
            e->leftTriangle = ti;
            e->rightTriangle = 0xFF;
    1dfa:	425b      	negs	r3, r3
    //  Activate edge
    bool Setup(byte p0, byte p1, byte ti, bool left)
    {
        //  Does the edge already exist?
        //  Only need to search the new Edge list, can only match newly created edges
        Edge* e = _newEdgeList;
    1dfc:	9706      	str	r7, [sp, #24]
        _tail.Prev = &_head;
    }
    
    Edge* NewEdge()
    {
        if (_freeList == 0)
    1dfe:	9205      	str	r2, [sp, #20]
            e->leftTriangle = 0xFF;
        }
        else
        {
            e->leftTriangle = ti;
            e->rightTriangle = 0xFF;
    1e00:	9304      	str	r3, [sp, #16]
                _nextY = CEIL(_vertexes[t.p0].y);
                if (_nextY > _y)
                    break;
                    
                //  Activate first 2 triangle edges
                bool dem = t.fill & 0x80;
    1e02:	465c      	mov	r4, fp
    1e04:	00a3      	lsls	r3, r4, #2
    1e06:	444b      	add	r3, r9
    1e08:	7a5a      	ldrb	r2, [r3, #9]
                Setup(t.p0,t.p2,ti,dem);
    1e0a:	b2c0      	uxtb	r0, r0
                _nextY = CEIL(_vertexes[t.p0].y);
                if (_nextY > _y)
                    break;
                    
                //  Activate first 2 triangle edges
                bool dem = t.fill & 0x80;
    1e0c:	09d2      	lsrs	r2, r2, #7
    1e0e:	9212      	str	r2, [sp, #72]
                Setup(t.p0,t.p2,ti,dem);
    1e10:	799e      	ldrb	r6, [r3, #6]
    1e12:	7a1b      	ldrb	r3, [r3, #8]
    1e14:	9014      	str	r0, [sp, #80]
    //  Activate edge
    bool Setup(byte p0, byte p1, byte ti, bool left)
    {
        //  Does the edge already exist?
        //  Only need to search the new Edge list, can only match newly created edges
        Edge* e = _newEdgeList;
    1e16:	9806      	ldr	r0, [sp, #24]
    1e18:	4657      	mov	r7, sl
    1e1a:	5839      	ldr	r1, [r7, r0]
                if (_nextY > _y)
                    break;
                    
                //  Activate first 2 triangle edges
                bool dem = t.fill & 0x80;
                Setup(t.p0,t.p2,ti,dem);
    1e1c:	4698      	mov	r8, r3
    bool Setup(byte p0, byte p1, byte ti, bool left)
    {
        //  Does the edge already exist?
        //  Only need to search the new Edge list, can only match newly created edges
        Edge* e = _newEdgeList;
        while (e)
    1e1e:	2900      	cmp	r1, #0
    1e20:	d100      	bne.n	1e24 <_Z17DrawTrianglesLoopPhS_+0xac>
    1e22:	e269      	b.n	22f8 <_Z17DrawTrianglesLoopPhS_+0x580>
    1e24:	1c0a      	adds	r2, r1, #0
    1e26:	e003      	b.n	1e30 <_Z17DrawTrianglesLoopPhS_+0xb8>
                    e->rightTriangle = ti;
                else
                    e->leftTriangle = ti;
                return true;
            }
            e = e->Next;
    1e28:	6852      	ldr	r2, [r2, #4]
    bool Setup(byte p0, byte p1, byte ti, bool left)
    {
        //  Does the edge already exist?
        //  Only need to search the new Edge list, can only match newly created edges
        Edge* e = _newEdgeList;
        while (e)
    1e2a:	2a00      	cmp	r2, #0
    1e2c:	d100      	bne.n	1e30 <_Z17DrawTrianglesLoopPhS_+0xb8>
    1e2e:	e263      	b.n	22f8 <_Z17DrawTrianglesLoopPhS_+0x580>
        {
            if (e->p0 == p0 && e->p1 == p1) // Share existing edge
    1e30:	7d13      	ldrb	r3, [r2, #20]
    1e32:	42b3      	cmp	r3, r6
    1e34:	d1f8      	bne.n	1e28 <_Z17DrawTrianglesLoopPhS_+0xb0>
    1e36:	7d53      	ldrb	r3, [r2, #21]
    1e38:	4543      	cmp	r3, r8
    1e3a:	d1f5      	bne.n	1e28 <_Z17DrawTrianglesLoopPhS_+0xb0>
            {
                if (left)
    1e3c:	9912      	ldr	r1, [sp, #72]
    1e3e:	2900      	cmp	r1, #0
    1e40:	d100      	bne.n	1e44 <_Z17DrawTrianglesLoopPhS_+0xcc>
    1e42:	e387      	b.n	2554 <_Z17DrawTrianglesLoopPhS_+0x7dc>
                    e->rightTriangle = ti;
    1e44:	ab14      	add	r3, sp, #80
    1e46:	781b      	ldrb	r3, [r3, #0]
    1e48:	465c      	mov	r4, fp
    1e4a:	75d3      	strb	r3, [r2, #23]
    1e4c:	9806      	ldr	r0, [sp, #24]
    1e4e:	00a3      	lsls	r3, r4, #2
    1e50:	444b      	add	r3, r9
    1e52:	4657      	mov	r7, sl
    1e54:	799e      	ldrb	r6, [r3, #6]
    1e56:	5839      	ldr	r1, [r7, r0]
                    break;
                    
                //  Activate first 2 triangle edges
                bool dem = t.fill & 0x80;
                Setup(t.p0,t.p2,ti,dem);
                if (!Setup(t.p0,t.p1,ti,!dem))	// if p0.y == p1.y edge won't be inserted so ...
    1e58:	465f      	mov	r7, fp
    1e5a:	00bb      	lsls	r3, r7, #2
    1e5c:	444b      	add	r3, r9
    1e5e:	79db      	ldrb	r3, [r3, #7]
    1e60:	2001      	movs	r0, #1
    1e62:	4698      	mov	r8, r3
    1e64:	9b12      	ldr	r3, [sp, #72]
    1e66:	4043      	eors	r3, r0
    1e68:	b2db      	uxtb	r3, r3
    1e6a:	9313      	str	r3, [sp, #76]
    bool Setup(byte p0, byte p1, byte ti, bool left)
    {
        //  Does the edge already exist?
        //  Only need to search the new Edge list, can only match newly created edges
        Edge* e = _newEdgeList;
        while (e)
    1e6c:	2900      	cmp	r1, #0
    1e6e:	d100      	bne.n	1e72 <_Z17DrawTrianglesLoopPhS_+0xfa>
    1e70:	e2a5      	b.n	23be <_Z17DrawTrianglesLoopPhS_+0x646>
    1e72:	1c0f      	adds	r7, r1, #0
    1e74:	e003      	b.n	1e7e <_Z17DrawTrianglesLoopPhS_+0x106>
                    e->rightTriangle = ti;
                else
                    e->leftTriangle = ti;
                return true;
            }
            e = e->Next;
    1e76:	6849      	ldr	r1, [r1, #4]
    bool Setup(byte p0, byte p1, byte ti, bool left)
    {
        //  Does the edge already exist?
        //  Only need to search the new Edge list, can only match newly created edges
        Edge* e = _newEdgeList;
        while (e)
    1e78:	2900      	cmp	r1, #0
    1e7a:	d100      	bne.n	1e7e <_Z17DrawTrianglesLoopPhS_+0x106>
    1e7c:	e29e      	b.n	23bc <_Z17DrawTrianglesLoopPhS_+0x644>
        {
            if (e->p0 == p0 && e->p1 == p1) // Share existing edge
    1e7e:	7d0b      	ldrb	r3, [r1, #20]
    1e80:	42b3      	cmp	r3, r6
    1e82:	d1f8      	bne.n	1e76 <_Z17DrawTrianglesLoopPhS_+0xfe>
    1e84:	7d4b      	ldrb	r3, [r1, #21]
    1e86:	4543      	cmp	r3, r8
    1e88:	d1f5      	bne.n	1e76 <_Z17DrawTrianglesLoopPhS_+0xfe>
            {
                if (left)
    1e8a:	9a13      	ldr	r2, [sp, #76]
    1e8c:	2a00      	cmp	r2, #0
    1e8e:	d100      	bne.n	1e92 <_Z17DrawTrianglesLoopPhS_+0x11a>
    1e90:	e34c      	b.n	252c <_Z17DrawTrianglesLoopPhS_+0x7b4>
                    e->rightTriangle = ti;
    1e92:	ab14      	add	r3, sp, #80
    1e94:	781b      	ldrb	r3, [r3, #0]
    1e96:	75cb      	strb	r3, [r1, #23]
                //  Activate first 2 triangle edges
                bool dem = t.fill & 0x80;
                Setup(t.p0,t.p2,ti,dem);
                if (!Setup(t.p0,t.p1,ti,!dem))	// if p0.y == p1.y edge won't be inserted so ...
                    Setup(t.p1,t.p2,ti,!dem);	//  ... setup thrid immediately
                _triangleIndex++;
    1e98:	23b4      	movs	r3, #180
    1e9a:	464a      	mov	r2, r9
    1e9c:	009b      	lsls	r3, r3, #2
    1e9e:	58d1      	ldr	r1, [r2, r3]
        }
        
        // Activate triangles, insert edges into new edge list
        if (_nextY <= _y)
        {
            while (_triangleIndex < _triangleCount)
    1ea0:	4c8a      	ldr	r4, [pc, #552]	(20cc <_Z17DrawTrianglesLoopPhS_+0x354>)
                //  Activate first 2 triangle edges
                bool dem = t.fill & 0x80;
                Setup(t.p0,t.p2,ti,dem);
                if (!Setup(t.p0,t.p1,ti,!dem))	// if p0.y == p1.y edge won't be inserted so ...
                    Setup(t.p1,t.p2,ti,!dem);	//  ... setup thrid immediately
                _triangleIndex++;
    1ea2:	1c48      	adds	r0, r1, #1
    1ea4:	50d0      	str	r0, [r2, r3]
        }
        
        // Activate triangles, insert edges into new edge list
        if (_nextY <= _y)
        {
            while (_triangleIndex < _triangleCount)
    1ea6:	5d13      	ldrb	r3, [r2, r4]
    1ea8:	4298      	cmp	r0, r3
    1eaa:	da1b      	bge.n	1ee4 <_Z17DrawTrianglesLoopPhS_+0x16c>
            {
				int ti = _triangleIndex;
                Triangle& t = _triangles[ti];
                _nextY = CEIL(_vertexes[t.p0].y);
    1eac:	1c0b      	adds	r3, r1, #0
    1eae:	339d      	adds	r3, #157
    1eb0:	009b      	lsls	r3, r3, #2
    1eb2:	444b      	add	r3, r9
    1eb4:	799a      	ldrb	r2, [r3, #6]
    1eb6:	464f      	mov	r7, r9
    1eb8:	0053      	lsls	r3, r2, #1
    1eba:	189b      	adds	r3, r3, r2
    1ebc:	005b      	lsls	r3, r3, #1
    1ebe:	228a      	movs	r2, #138
    1ec0:	0092      	lsls	r2, r2, #2
    1ec2:	444b      	add	r3, r9
    1ec4:	189b      	adds	r3, r3, r2
    1ec6:	2408      	movs	r4, #8
    1ec8:	5f1a      	ldrsh	r2, [r3, r4]
    1eca:	23b3      	movs	r3, #179
    1ecc:	3210      	adds	r2, #16
    1ece:	009b      	lsls	r3, r3, #2
    1ed0:	1112      	asrs	r2, r2, #4
    1ed2:	50fa      	str	r2, [r7, r3]
                if (_nextY > _y)
    1ed4:	23b2      	movs	r3, #178
    1ed6:	009b      	lsls	r3, r3, #2
    1ed8:	58fb      	ldr	r3, [r7, r3]
    1eda:	429a      	cmp	r2, r3
    1edc:	dc02      	bgt.n	1ee4 <_Z17DrawTrianglesLoopPhS_+0x16c>
    1ede:	319d      	adds	r1, #157
    1ee0:	468b      	mov	fp, r1
    1ee2:	e78e      	b.n	1e02 <_Z17DrawTrianglesLoopPhS_+0x8a>
                _triangleIndex++;
            }
        }
        
        //  Merge new edge list into edge list
        while (_newEdgeList)
    1ee4:	23f2      	movs	r3, #242
    1ee6:	005b      	lsls	r3, r3, #1
    1ee8:	464f      	mov	r7, r9
    1eea:	58fc      	ldr	r4, [r7, r3]
    1eec:	2c00      	cmp	r4, #0
    1eee:	d014      	beq.n	1f1a <_Z17DrawTrianglesLoopPhS_+0x1a2>
        {
            Edge* e = _newEdgeList;
            _newEdgeList = _newEdgeList->Next;
    1ef0:	1c1d      	adds	r5, r3, #0
    1ef2:	6863      	ldr	r3, [r4, #4]
    1ef4:	4648      	mov	r0, r9
    1ef6:	5143      	str	r3, [r0, r5]
            Edge* a = &_head;
            long x = e->X;
    1ef8:	68e0      	ldr	r0, [r4, #12]
    1efa:	4652      	mov	r2, sl
	        while (a->Next->X < x)
    1efc:	6853      	ldr	r3, [r2, #4]
    1efe:	1c11      	adds	r1, r2, #0
    1f00:	1c1a      	adds	r2, r3, #0
    1f02:	68db      	ldr	r3, [r3, #12]
    1f04:	4298      	cmp	r0, r3
    1f06:	dcf9      	bgt.n	1efc <_Z17DrawTrianglesLoopPhS_+0x184>
    byte    leftTriangle;
    byte    rightTriangle;
    
    void InsertAfter(Edge* a)
    {
	    Next = a->Next;
    1f08:	6062      	str	r2, [r4, #4]
	    Prev = a;
	    a->Next->Prev = this;
    1f0a:	684b      	ldr	r3, [r1, #4]
    byte    rightTriangle;
    
    void InsertAfter(Edge* a)
    {
	    Next = a->Next;
	    Prev = a;
    1f0c:	6021      	str	r1, [r4, #0]
	    a->Next->Prev = this;
	    a->Next = this;
    1f0e:	604c      	str	r4, [r1, #4]
    
    void InsertAfter(Edge* a)
    {
	    Next = a->Next;
	    Prev = a;
	    a->Next->Prev = this;
    1f10:	601c      	str	r4, [r3, #0]
                _triangleIndex++;
            }
        }
        
        //  Merge new edge list into edge list
        while (_newEdgeList)
    1f12:	4649      	mov	r1, r9
    1f14:	594c      	ldr	r4, [r1, r5]
    1f16:	2c00      	cmp	r4, #0
    1f18:	d1eb      	bne.n	1ef2 <_Z17DrawTrianglesLoopPhS_+0x17a>
	        while (a->Next->X < x)
		        a = a->Next;
	        e->InsertAfter(a);  //  Insert into sorted active edgelist
        }
        
        _x = 0;
    1f1a:	464c      	mov	r4, r9
    1f1c:	22f4      	movs	r2, #244
        if (_head.Next != &_tail)
    1f1e:	6b67      	ldr	r7, [r4, #52]
    1f20:	9815      	ldr	r0, [sp, #84]
	        while (a->Next->X < x)
		        a = a->Next;
	        e->InsertAfter(a);  //  Insert into sorted active edgelist
        }
        
        _x = 0;
    1f22:	0052      	lsls	r2, r2, #1
    1f24:	2300      	movs	r3, #0
    1f26:	52a3      	strh	r3, [r4, r2]
        if (_head.Next != &_tail)
    1f28:	42b8      	cmp	r0, r7
    1f2a:	d100      	bne.n	1f2e <_Z17DrawTrianglesLoopPhS_+0x1b6>
    1f2c:	e357      	b.n	25de <_Z17DrawTrianglesLoopPhS_+0x866>
        {
            runs = DrawActive(_y,runs);
    1f2e:	23b2      	movs	r3, #178
    1f30:	009b      	lsls	r3, r3, #2
    1f32:	4649      	mov	r1, r9
    1f34:	58cb      	ldr	r3, [r1, r3]
								int run = x1-x0;
								if (run > 0)
								{
									 byte color = _triangles[triangleIndex].fill & 0x0f;
									 *dst++ = run;
									 *dst++ = (color << 4) | _hackyColor;
    1f36:	4c66      	ldr	r4, [pc, #408]	(20d0 <_Z17DrawTrianglesLoopPhS_+0x358>)
        }
        
        _x = 0;
        if (_head.Next != &_tail)
        {
            runs = DrawActive(_y,runs);
    1f38:	4698      	mov	r8, r3
    1f3a:	9b0d      	ldr	r3, [sp, #52]
    1f3c:	2500      	movs	r5, #0
                            if (x1 > x0)
							{
                                //DrawSpan(x0,x1,y,triangleIndex);
								if (start == dst)
								{
									dst++;			// count
    1f3e:	1c18      	adds	r0, r3, #0
    1f40:	3001      	adds	r0, #1
    1f42:	9008      	str	r0, [sp, #32]
									*dst++ = x0;	// left
    1f44:	3001      	adds	r0, #1
        }
        
        _x = 0;
        if (_head.Next != &_tail)
        {
            runs = DrawActive(_y,runs);
    1f46:	931b      	str	r3, [sp, #108]
                
                // Left edge
                if (curr->rightTriangle != 0xFF)
                {
                    //ASSERT(_depth < 16);
                    _stack[_depth++] = curr;
    1f48:	ae1c      	add	r6, sp, #112
								int run = x1-x0;
								if (run > 0)
								{
									 byte color = _triangles[triangleIndex].fill & 0x0f;
									 *dst++ = run;
									 *dst++ = (color << 4) | _hackyColor;
    1f4a:	46a3      	mov	fp, r4
							{
                                //DrawSpan(x0,x1,y,triangleIndex);
								if (start == dst)
								{
									dst++;			// count
									*dst++ = x0;	// left
    1f4c:	9007      	str	r0, [sp, #28]
        int _depth = 0;
        u8* start = dst;
        Edge* curr = _head.Next;
	    while (curr != &_tail)
	    {
	        if (y <= curr->YEnd)
    1f4e:	2108      	movs	r1, #8
    1f50:	5e7b      	ldrsh	r3, [r7, r1]
    1f52:	4598      	cmp	r8, r3
    1f54:	dc1f      	bgt.n	1f96 <_Z17DrawTrianglesLoopPhS_+0x21e>
	        {
                // Right edge
                if (curr->leftTriangle != 0xFF)
    1f56:	7dba      	ldrb	r2, [r7, #22]
    1f58:	9201      	str	r2, [sp, #4]
    1f5a:	2aff      	cmp	r2, #255
    1f5c:	d015      	beq.n	1f8a <_Z17DrawTrianglesLoopPhS_+0x212>
                {
                    byte triangleIndex = curr->leftTriangle;
                    for (byte i = 0; i < _depth; i++)
    1f5e:	2d00      	cmp	r5, #0
    1f60:	dd13      	ble.n	1f8a <_Z17DrawTrianglesLoopPhS_+0x212>
                    {
                        if (_stack[i]->rightTriangle == triangleIndex)
    1f62:	6832      	ldr	r2, [r6, #0]
    1f64:	9c01      	ldr	r4, [sp, #4]
    1f66:	7dd3      	ldrb	r3, [r2, #23]
    1f68:	42a3      	cmp	r3, r4
    1f6a:	d100      	bne.n	1f6e <_Z17DrawTrianglesLoopPhS_+0x1f6>
    1f6c:	e0d7      	b.n	211e <_Z17DrawTrianglesLoopPhS_+0x3a6>
								}
							}
                             
                            // Remove
                            _depth--;
                            for (;i < _depth;i++)
    1f6e:	2100      	movs	r1, #0
    1f70:	e006      	b.n	1f80 <_Z17DrawTrianglesLoopPhS_+0x208>
                if (curr->leftTriangle != 0xFF)
                {
                    byte triangleIndex = curr->leftTriangle;
                    for (byte i = 0; i < _depth; i++)
                    {
                        if (_stack[i]->rightTriangle == triangleIndex)
    1f72:	008b      	lsls	r3, r1, #2
    1f74:	58f2      	ldr	r2, [r6, r3]
    1f76:	9c01      	ldr	r4, [sp, #4]
    1f78:	7dd3      	ldrb	r3, [r2, #23]
    1f7a:	42a3      	cmp	r3, r4
    1f7c:	d100      	bne.n	1f80 <_Z17DrawTrianglesLoopPhS_+0x208>
    1f7e:	e0d0      	b.n	2122 <_Z17DrawTrianglesLoopPhS_+0x3aa>
	        {
                // Right edge
                if (curr->leftTriangle != 0xFF)
                {
                    byte triangleIndex = curr->leftTriangle;
                    for (byte i = 0; i < _depth; i++)
    1f80:	1c4b      	adds	r3, r1, #1
    1f82:	b2d9      	uxtb	r1, r3
    1f84:	1c08      	adds	r0, r1, #0
    1f86:	428d      	cmp	r5, r1
    1f88:	dcf3      	bgt.n	1f72 <_Z17DrawTrianglesLoopPhS_+0x1fa>
                        }
                    }
                }
                
                // Left edge
                if (curr->rightTriangle != 0xFF)
    1f8a:	7dfb      	ldrb	r3, [r7, #23]
    1f8c:	2bff      	cmp	r3, #255
    1f8e:	d002      	beq.n	1f96 <_Z17DrawTrianglesLoopPhS_+0x21e>
                {
                    //ASSERT(_depth < 16);
                    _stack[_depth++] = curr;
    1f90:	00ab      	lsls	r3, r5, #2
    1f92:	519f      	str	r7, [r3, r6]
    1f94:	3501      	adds	r5, #1
                }
	        }
            curr = curr->Next;
    1f96:	687f      	ldr	r7, [r7, #4]
    {
        Edge* _stack[16];
        int _depth = 0;
        u8* start = dst;
        Edge* curr = _head.Next;
	    while (curr != &_tail)
    1f98:	9c15      	ldr	r4, [sp, #84]
    1f9a:	42bc      	cmp	r4, r7
    1f9c:	d1d7      	bne.n	1f4e <_Z17DrawTrianglesLoopPhS_+0x1d6>
                    _stack[_depth++] = curr;
                }
	        }
            curr = curr->Next;
	    }
		if (start == dst)
    1f9e:	980d      	ldr	r0, [sp, #52]
    1fa0:	991b      	ldr	r1, [sp, #108]
    1fa2:	4288      	cmp	r0, r1
    1fa4:	d100      	bne.n	1fa8 <_Z17DrawTrianglesLoopPhS_+0x230>
    1fa6:	e320      	b.n	25ea <_Z17DrawTrianglesLoopPhS_+0x872>
    1fa8:	1c03      	adds	r3, r0, #0
			start[0] = 0;
		else
			start[0] = (dst - (start+2))>>1;	// # of runs
    1faa:	3302      	adds	r3, #2
    1fac:	1acb      	subs	r3, r1, r3
    1fae:	105b      	asrs	r3, r3, #1
    1fb0:	7003      	strb	r3, [r0, #0]
        
        _x = 0;
        if (_head.Next != &_tail)
        {
            runs = DrawActive(_y,runs);
            StepActive(_y);
    1fb2:	23b2      	movs	r3, #178
    1fb4:	4648      	mov	r0, r9
    1fb6:	009b      	lsls	r3, r3, #2
    1fb8:	58c3      	ldr	r3, [r0, r3]
    
    //	Step and resort (good candidate for asm)
    void StepActive(int y)
    {
	    Edge* e,*e2,*next;
	    for (e = _head.Next; e != &_tail;)
    1fba:	6b46      	ldr	r6, [r0, #52]
        
        _x = 0;
        if (_head.Next != &_tail)
        {
            runs = DrawActive(_y,runs);
            StepActive(_y);
    1fbc:	931a      	str	r3, [sp, #104]
    
    //	Step and resort (good candidate for asm)
    void StepActive(int y)
    {
	    Edge* e,*e2,*next;
	    for (e = _head.Next; e != &_tail;)
    1fbe:	42b7      	cmp	r7, r6
    1fc0:	d100      	bne.n	1fc4 <_Z17DrawTrianglesLoopPhS_+0x24c>
    1fc2:	e324      	b.n	260e <_Z17DrawTrianglesLoopPhS_+0x896>
    Edge* Release(Edge* e)
    {
        Edge* next = e->Next;
        e->Next->Prev = e->Prev;
        e->Prev->Next = e->Next;
        e->Next = _freeList;
    1fc4:	22f0      	movs	r2, #240
    //  Activate edge
    bool Setup(byte p0, byte p1, byte ti, bool left)
    {
        //  Does the edge already exist?
        //  Only need to search the new Edge list, can only match newly created edges
        Edge* e = _newEdgeList;
    1fc6:	23da      	movs	r3, #218
        _tail.Prev = &_head;
    }
    
    Edge* NewEdge()
    {
        if (_freeList == 0)
    1fc8:	24d8      	movs	r4, #216
            e->leftTriangle = 0xFF;
        }
        else
        {
            e->leftTriangle = ti;
            e->rightTriangle = 0xFF;
    1fca:	2701      	movs	r7, #1
    //  Activate edge
    bool Setup(byte p0, byte p1, byte ti, bool left)
    {
        //  Does the edge already exist?
        //  Only need to search the new Edge list, can only match newly created edges
        Edge* e = _newEdgeList;
    1fcc:	005b      	lsls	r3, r3, #1
    Edge* Release(Edge* e)
    {
        Edge* next = e->Next;
        e->Next->Prev = e->Prev;
        e->Prev->Next = e->Next;
        e->Next = _freeList;
    1fce:	0052      	lsls	r2, r2, #1
        _tail.Prev = &_head;
    }
    
    Edge* NewEdge()
    {
        if (_freeList == 0)
    1fd0:	0064      	lsls	r4, r4, #1
            e->leftTriangle = 0xFF;
        }
        else
        {
            e->leftTriangle = ti;
            e->rightTriangle = 0xFF;
    1fd2:	427f      	negs	r7, r7
    Edge* Release(Edge* e)
    {
        Edge* next = e->Next;
        e->Next->Prev = e->Prev;
        e->Prev->Next = e->Next;
        e->Next = _freeList;
    1fd4:	920c      	str	r2, [sp, #48]
    //  Activate edge
    bool Setup(byte p0, byte p1, byte ti, bool left)
    {
        //  Does the edge already exist?
        //  Only need to search the new Edge list, can only match newly created edges
        Edge* e = _newEdgeList;
    1fd6:	930b      	str	r3, [sp, #44]
        _tail.Prev = &_head;
    }
    
    Edge* NewEdge()
    {
        if (_freeList == 0)
    1fd8:	940a      	str	r4, [sp, #40]
            e->leftTriangle = 0xFF;
        }
        else
        {
            e->leftTriangle = ti;
            e->rightTriangle = 0xFF;
    1fda:	9709      	str	r7, [sp, #36]
    void StepActive(int y)
    {
	    Edge* e,*e2,*next;
	    for (e = _head.Next; e != &_tail;)
	    {
		    if (y >= e->YEnd)
    1fdc:	2008      	movs	r0, #8
    1fde:	5e33      	ldrsh	r3, [r6, r0]
    1fe0:	991a      	ldr	r1, [sp, #104]
    1fe2:	4299      	cmp	r1, r3
    1fe4:	db67      	blt.n	20b6 <_Z17DrawTrianglesLoopPhS_+0x33e>
		    {
                //  Activate 2nd part of part of triangle if required
                if (e->rightTriangle != 0xFF)
    1fe6:	7df2      	ldrb	r2, [r6, #23]
    1fe8:	920e      	str	r2, [sp, #56]
    1fea:	2aff      	cmp	r2, #255
    1fec:	d026      	beq.n	203c <_Z17DrawTrianglesLoopPhS_+0x2c4>
    
    //  Activate the bottom edge of a triangle if required
    void Activte2ndPart(Edge* e, byte triangleIndex)
    {
        Triangle& t = _triangles[triangleIndex];
        if (e->p0 == t.p1)
    1fee:	1c13      	adds	r3, r2, #0
    1ff0:	339c      	adds	r3, #156
    1ff2:	009b      	lsls	r3, r3, #2
    1ff4:	464c      	mov	r4, r9
    1ff6:	18e2      	adds	r2, r4, r3
    1ff8:	79d7      	ldrb	r7, [r2, #7]
    1ffa:	7d33      	ldrb	r3, [r6, #20]
    1ffc:	42bb      	cmp	r3, r7
    1ffe:	d01d      	beq.n	203c <_Z17DrawTrianglesLoopPhS_+0x2c4>
            return; // Was 2nd part already
            
        //  Now setup bottom bit, add to list
        Setup(t.p1,t.p2,triangleIndex,!(t.fill & 0x80));
    2000:	7a53      	ldrb	r3, [r2, #9]
    2002:	7a10      	ldrb	r0, [r2, #8]
    2004:	43db      	mvns	r3, r3
    2006:	b2db      	uxtb	r3, r3
    2008:	09db      	lsrs	r3, r3, #7
    200a:	9310      	str	r3, [sp, #64]
    //  Activate edge
    bool Setup(byte p0, byte p1, byte ti, bool left)
    {
        //  Does the edge already exist?
        //  Only need to search the new Edge list, can only match newly created edges
        Edge* e = _newEdgeList;
    200c:	9b0b      	ldr	r3, [sp, #44]
    200e:	4651      	mov	r1, sl
    2010:	58ca      	ldr	r2, [r1, r3]
        Triangle& t = _triangles[triangleIndex];
        if (e->p0 == t.p1)
            return; // Was 2nd part already
            
        //  Now setup bottom bit, add to list
        Setup(t.p1,t.p2,triangleIndex,!(t.fill & 0x80));
    2012:	4680      	mov	r8, r0
    bool Setup(byte p0, byte p1, byte ti, bool left)
    {
        //  Does the edge already exist?
        //  Only need to search the new Edge list, can only match newly created edges
        Edge* e = _newEdgeList;
        while (e)
    2014:	2a00      	cmp	r2, #0
    2016:	d104      	bne.n	2022 <_Z17DrawTrianglesLoopPhS_+0x2aa>
    2018:	e116      	b.n	2248 <_Z17DrawTrianglesLoopPhS_+0x4d0>
                    e->rightTriangle = ti;
                else
                    e->leftTriangle = ti;
                return true;
            }
            e = e->Next;
    201a:	6852      	ldr	r2, [r2, #4]
    bool Setup(byte p0, byte p1, byte ti, bool left)
    {
        //  Does the edge already exist?
        //  Only need to search the new Edge list, can only match newly created edges
        Edge* e = _newEdgeList;
        while (e)
    201c:	2a00      	cmp	r2, #0
    201e:	d100      	bne.n	2022 <_Z17DrawTrianglesLoopPhS_+0x2aa>
    2020:	e112      	b.n	2248 <_Z17DrawTrianglesLoopPhS_+0x4d0>
        {
            if (e->p0 == p0 && e->p1 == p1) // Share existing edge
    2022:	7d13      	ldrb	r3, [r2, #20]
    2024:	42bb      	cmp	r3, r7
    2026:	d1f8      	bne.n	201a <_Z17DrawTrianglesLoopPhS_+0x2a2>
    2028:	7d53      	ldrb	r3, [r2, #21]
    202a:	4543      	cmp	r3, r8
    202c:	d1f5      	bne.n	201a <_Z17DrawTrianglesLoopPhS_+0x2a2>
            {
                if (left)
    202e:	9c10      	ldr	r4, [sp, #64]
    2030:	2c00      	cmp	r4, #0
    2032:	d100      	bne.n	2036 <_Z17DrawTrianglesLoopPhS_+0x2be>
    2034:	e2b1      	b.n	259a <_Z17DrawTrianglesLoopPhS_+0x822>
                    e->rightTriangle = ti;
    2036:	af0e      	add	r7, sp, #56
    2038:	783f      	ldrb	r7, [r7, #0]
    203a:	75d7      	strb	r7, [r2, #23]
		    if (y >= e->YEnd)
		    {
                //  Activate 2nd part of part of triangle if required
                if (e->rightTriangle != 0xFF)
                    Activte2ndPart(e,e->rightTriangle);
                if (e->leftTriangle != 0xFF)
    203c:	7db3      	ldrb	r3, [r6, #22]
    203e:	930f      	str	r3, [sp, #60]
    2040:	2bff      	cmp	r3, #255
    2042:	d025      	beq.n	2090 <_Z17DrawTrianglesLoopPhS_+0x318>
    
    //  Activate the bottom edge of a triangle if required
    void Activte2ndPart(Edge* e, byte triangleIndex)
    {
        Triangle& t = _triangles[triangleIndex];
        if (e->p0 == t.p1)
    2044:	339c      	adds	r3, #156
    2046:	009b      	lsls	r3, r3, #2
    2048:	464c      	mov	r4, r9
    204a:	18e2      	adds	r2, r4, r3
    204c:	79d7      	ldrb	r7, [r2, #7]
    204e:	7d33      	ldrb	r3, [r6, #20]
    2050:	42bb      	cmp	r3, r7
    2052:	d01d      	beq.n	2090 <_Z17DrawTrianglesLoopPhS_+0x318>
            return; // Was 2nd part already
            
        //  Now setup bottom bit, add to list
        Setup(t.p1,t.p2,triangleIndex,!(t.fill & 0x80));
    2054:	7a53      	ldrb	r3, [r2, #9]
    2056:	7a10      	ldrb	r0, [r2, #8]
    2058:	43db      	mvns	r3, r3
    205a:	b2db      	uxtb	r3, r3
    205c:	09db      	lsrs	r3, r3, #7
    205e:	9311      	str	r3, [sp, #68]
    //  Activate edge
    bool Setup(byte p0, byte p1, byte ti, bool left)
    {
        //  Does the edge already exist?
        //  Only need to search the new Edge list, can only match newly created edges
        Edge* e = _newEdgeList;
    2060:	9b0b      	ldr	r3, [sp, #44]
    2062:	4651      	mov	r1, sl
    2064:	58ca      	ldr	r2, [r1, r3]
        Triangle& t = _triangles[triangleIndex];
        if (e->p0 == t.p1)
            return; // Was 2nd part already
            
        //  Now setup bottom bit, add to list
        Setup(t.p1,t.p2,triangleIndex,!(t.fill & 0x80));
    2066:	4680      	mov	r8, r0
    bool Setup(byte p0, byte p1, byte ti, bool left)
    {
        //  Does the edge already exist?
        //  Only need to search the new Edge list, can only match newly created edges
        Edge* e = _newEdgeList;
        while (e)
    2068:	2a00      	cmp	r2, #0
    206a:	d104      	bne.n	2076 <_Z17DrawTrianglesLoopPhS_+0x2fe>
    206c:	e094      	b.n	2198 <_Z17DrawTrianglesLoopPhS_+0x420>
                    e->rightTriangle = ti;
                else
                    e->leftTriangle = ti;
                return true;
            }
            e = e->Next;
    206e:	6852      	ldr	r2, [r2, #4]
    bool Setup(byte p0, byte p1, byte ti, bool left)
    {
        //  Does the edge already exist?
        //  Only need to search the new Edge list, can only match newly created edges
        Edge* e = _newEdgeList;
        while (e)
    2070:	2a00      	cmp	r2, #0
    2072:	d100      	bne.n	2076 <_Z17DrawTrianglesLoopPhS_+0x2fe>
    2074:	e090      	b.n	2198 <_Z17DrawTrianglesLoopPhS_+0x420>
        {
            if (e->p0 == p0 && e->p1 == p1) // Share existing edge
    2076:	7d13      	ldrb	r3, [r2, #20]
    2078:	42bb      	cmp	r3, r7
    207a:	d1f8      	bne.n	206e <_Z17DrawTrianglesLoopPhS_+0x2f6>
    207c:	7d53      	ldrb	r3, [r2, #21]
    207e:	4543      	cmp	r3, r8
    2080:	d1f5      	bne.n	206e <_Z17DrawTrianglesLoopPhS_+0x2f6>
            {
                if (left)
    2082:	9c11      	ldr	r4, [sp, #68]
    2084:	2c00      	cmp	r4, #0
    2086:	d100      	bne.n	208a <_Z17DrawTrianglesLoopPhS_+0x312>
    2088:	e28b      	b.n	25a2 <_Z17DrawTrianglesLoopPhS_+0x82a>
                    e->rightTriangle = ti;
    208a:	af0f      	add	r7, sp, #60
    208c:	783f      	ldrb	r7, [r7, #0]
    208e:	75d7      	strb	r7, [r2, #23]
        return e;
    }
    
    Edge* Release(Edge* e)
    {
        Edge* next = e->Next;
    2090:	6870      	ldr	r0, [r6, #4]
        e->Next->Prev = e->Prev;
    2092:	6833      	ldr	r3, [r6, #0]
        e->Prev->Next = e->Next;
        e->Next = _freeList;
    2094:	9f0c      	ldr	r7, [sp, #48]
    }
    
    Edge* Release(Edge* e)
    {
        Edge* next = e->Next;
        e->Next->Prev = e->Prev;
    2096:	6003      	str	r3, [r0, #0]
        e->Prev->Next = e->Next;
    2098:	6833      	ldr	r3, [r6, #0]
        e->Next = _freeList;
    209a:	464c      	mov	r4, r9
    
    Edge* Release(Edge* e)
    {
        Edge* next = e->Next;
        e->Next->Prev = e->Prev;
        e->Prev->Next = e->Next;
    209c:	6058      	str	r0, [r3, #4]
        e->Next = _freeList;
    209e:	59e3      	ldr	r3, [r4, r7]
    20a0:	6073      	str	r3, [r6, #4]
        _freeList = e;  // Free list is singly linked
    20a2:	51e6      	str	r6, [r4, r7]
    
    //	Step and resort (good candidate for asm)
    void StepActive(int y)
    {
	    Edge* e,*e2,*next;
	    for (e = _head.Next; e != &_tail;)
    20a4:	9915      	ldr	r1, [sp, #84]
    20a6:	4281      	cmp	r1, r0
    20a8:	d024      	beq.n	20f4 <_Z17DrawTrianglesLoopPhS_+0x37c>
    20aa:	1c06      	adds	r6, r0, #0
	    {
		    if (y >= e->YEnd)
    20ac:	2008      	movs	r0, #8
    20ae:	5e33      	ldrsh	r3, [r6, r0]
    20b0:	991a      	ldr	r1, [sp, #104]
    20b2:	4299      	cmp	r1, r3
    20b4:	da97      	bge.n	1fe6 <_Z17DrawTrianglesLoopPhS_+0x26e>
        XStep = gradient;
    }
    
    inline void Step()
    {
	    X += XStep;
    20b6:	68f2      	ldr	r2, [r6, #12]
    20b8:	6933      	ldr	r3, [r6, #16]
                //  Release this edge
                e = Release(e);
			    continue;
		    }
    		e->Step();
		    next = e->Next;
    20ba:	6870      	ldr	r0, [r6, #4]
        XStep = gradient;
    }
    
    inline void Step()
    {
	    X += XStep;
    20bc:	1899      	adds	r1, r3, r2
                e = Release(e);
			    continue;
		    }
    		e->Step();
		    next = e->Next;
		    while (e->X < e->Prev->X)  // Reorder in x if required
    20be:	6832      	ldr	r2, [r6, #0]
        XStep = gradient;
    }
    
    inline void Step()
    {
	    X += XStep;
    20c0:	60f1      	str	r1, [r6, #12]
                e = Release(e);
			    continue;
		    }
    		e->Step();
		    next = e->Next;
		    while (e->X < e->Prev->X)  // Reorder in x if required
    20c2:	68d3      	ldr	r3, [r2, #12]
    20c4:	4299      	cmp	r1, r3
    20c6:	daed      	bge.n	20a4 <_Z17DrawTrianglesLoopPhS_+0x32c>
    20c8:	1c03      	adds	r3, r0, #0
    20ca:	e004      	b.n	20d6 <_Z17DrawTrianglesLoopPhS_+0x35e>
    20cc:	0000022d 	.word	0x0000022d
    20d0:	1000047c 	.word	0x1000047c
    20d4:	6873      	ldr	r3, [r6, #4]
		    {
			    e2 = e->Prev;
			    e2->Next = e->Next;		// Move it earlier, does not happen very often
    20d6:	6053      	str	r3, [r2, #4]
			    e->Next->Prev = e2;
    20d8:	6873      	ldr	r3, [r6, #4]
    20da:	601a      	str	r2, [r3, #0]
			    e2->Prev->Next = e;
    20dc:	6813      	ldr	r3, [r2, #0]
			    e->Prev = e2->Prev;
    20de:	6033      	str	r3, [r6, #0]
			    e->Next = e2;
			    e2->Prev = e;
    20e0:	6016      	str	r6, [r2, #0]
		    while (e->X < e->Prev->X)  // Reorder in x if required
		    {
			    e2 = e->Prev;
			    e2->Next = e->Next;		// Move it earlier, does not happen very often
			    e->Next->Prev = e2;
			    e2->Prev->Next = e;
    20e2:	605e      	str	r6, [r3, #4]
			    e->Prev = e2->Prev;
			    e->Next = e2;
    20e4:	6072      	str	r2, [r6, #4]
                e = Release(e);
			    continue;
		    }
    		e->Step();
		    next = e->Next;
		    while (e->X < e->Prev->X)  // Reorder in x if required
    20e6:	6832      	ldr	r2, [r6, #0]
    20e8:	68d3      	ldr	r3, [r2, #12]
    20ea:	4299      	cmp	r1, r3
    20ec:	dbf2      	blt.n	20d4 <_Z17DrawTrianglesLoopPhS_+0x35c>
    
    //	Step and resort (good candidate for asm)
    void StepActive(int y)
    {
	    Edge* e,*e2,*next;
	    for (e = _head.Next; e != &_tail;)
    20ee:	9915      	ldr	r1, [sp, #84]
    20f0:	4281      	cmp	r1, r0
    20f2:	d1da      	bne.n	20aa <_Z17DrawTrianglesLoopPhS_+0x332>
    20f4:	23b2      	movs	r3, #178
    20f6:	464a      	mov	r2, r9
    20f8:	009b      	lsls	r3, r3, #2
    20fa:	58d3      	ldr	r3, [r2, r3]
    20fc:	931a      	str	r3, [sp, #104]
    20fe:	9b1b      	ldr	r3, [sp, #108]
    2100:	9a1a      	ldr	r2, [sp, #104]
    2102:	930d      	str	r3, [sp, #52]
        if (_head.Next != &_tail)
        {
            runs = DrawActive(_y,runs);
            StepActive(_y);
        }
		_y++;
    2104:	23b2      	movs	r3, #178
    2106:	009b      	lsls	r3, r3, #2
    2108:	3201      	adds	r2, #1
    210a:	464c      	mov	r4, r9
    210c:	980d      	ldr	r0, [sp, #52]
    210e:	50e2      	str	r2, [r4, r3]

u8* DrawTrianglesLoop(u8* appBuffer, u8* runs)
{    
    ModelState* m = (ModelState*)appBuffer;
	return m->_r.DrawLoop(runs);
}
    2110:	b02d      	add	sp, #180
    2112:	bc3c      	pop	{r2, r3, r4, r5}
    2114:	4690      	mov	r8, r2
    2116:	4699      	mov	r9, r3
    2118:	46a2      	mov	sl, r4
    211a:	46ab      	mov	fp, r5
    211c:	bdf0      	pop	{r4, r5, r6, r7, pc}
                if (curr->leftTriangle != 0xFF)
                {
                    byte triangleIndex = curr->leftTriangle;
                    for (byte i = 0; i < _depth; i++)
                    {
                        if (_stack[i]->rightTriangle == triangleIndex)
    211e:	2100      	movs	r1, #0
    2120:	2000      	movs	r0, #0
	    X += XStep;
	}
	
	inline int GetX()
	{
	    return ((short*)&X)[1];
    2122:	89d2      	ldrh	r2, [r2, #14]
                    {
                        if (_stack[i]->rightTriangle == triangleIndex)
                        {
                            short x0 = _stack[i]->GetX();
                            short x1 = curr->GetX();
                            if (x1 > x0)
    2124:	230c      	movs	r3, #12
	    X += XStep;
	}
	
	inline int GetX()
	{
	    return ((short*)&X)[1];
    2126:	9203      	str	r2, [sp, #12]
                    {
                        if (_stack[i]->rightTriangle == triangleIndex)
                        {
                            short x0 = _stack[i]->GetX();
                            short x1 = curr->GetX();
                            if (x1 > x0)
    2128:	466a      	mov	r2, sp
    212a:	189b      	adds	r3, r3, r2
    212c:	2200      	movs	r2, #0
    212e:	5e9a      	ldrsh	r2, [r3, r2]
    2130:	4694      	mov	ip, r2
    2132:	220e      	movs	r2, #14
    2134:	5ebc      	ldrsh	r4, [r7, r2]
    2136:	9402      	str	r4, [sp, #8]
    2138:	45a4      	cmp	ip, r4
    213a:	da1e      	bge.n	217a <_Z17DrawTrianglesLoopPhS_+0x402>
							{
                                //DrawSpan(x0,x1,y,triangleIndex);
								if (start == dst)
    213c:	9b0d      	ldr	r3, [sp, #52]
    213e:	9c1b      	ldr	r4, [sp, #108]
    2140:	42a3      	cmp	r3, r4
    2142:	d100      	bne.n	2146 <_Z17DrawTrianglesLoopPhS_+0x3ce>
    2144:	e254      	b.n	25f0 <_Z17DrawTrianglesLoopPhS_+0x878>
								{
									dst++;			// count
									*dst++ = x0;	// left
									_x = x0;
								}
								int run = x1-x0;
    2146:	9b02      	ldr	r3, [sp, #8]
    2148:	4664      	mov	r4, ip
    214a:	1b1a      	subs	r2, r3, r4
								if (run > 0)
    214c:	2a00      	cmp	r2, #0
    214e:	dd14      	ble.n	217a <_Z17DrawTrianglesLoopPhS_+0x402>
								{
									 byte color = _triangles[triangleIndex].fill & 0x0f;
    2150:	9b01      	ldr	r3, [sp, #4]
    2152:	240f      	movs	r4, #15
    2154:	339c      	adds	r3, #156
    2156:	009b      	lsls	r3, r3, #2
    2158:	444b      	add	r3, r9
    215a:	7a5b      	ldrb	r3, [r3, #9]
    215c:	4023      	ands	r3, r4
									 *dst++ = run;
    215e:	9c1b      	ldr	r4, [sp, #108]
									 *dst++ = (color << 4) | _hackyColor;
    2160:	011b      	lsls	r3, r3, #4
								}
								int run = x1-x0;
								if (run > 0)
								{
									 byte color = _triangles[triangleIndex].fill & 0x0f;
									 *dst++ = run;
    2162:	7022      	strb	r2, [r4, #0]
									 *dst++ = (color << 4) | _hackyColor;
    2164:	465c      	mov	r4, fp
    2166:	6862      	ldr	r2, [r4, #4]
    2168:	4313      	orrs	r3, r2
    216a:	9a1b      	ldr	r2, [sp, #108]
    216c:	7053      	strb	r3, [r2, #1]
									 if (_hacky == -1)
    216e:	68a3      	ldr	r3, [r4, #8]
								int run = x1-x0;
								if (run > 0)
								{
									 byte color = _triangles[triangleIndex].fill & 0x0f;
									 *dst++ = run;
									 *dst++ = (color << 4) | _hackyColor;
    2170:	3202      	adds	r2, #2
    2172:	921b      	str	r2, [sp, #108]
									 if (_hacky == -1)
    2174:	3301      	adds	r3, #1
    2176:	d100      	bne.n	217a <_Z17DrawTrianglesLoopPhS_+0x402>
    2178:	e217      	b.n	25aa <_Z17DrawTrianglesLoopPhS_+0x832>
										 _hacky = y;
								}
							}
                             
                            // Remove
                            _depth--;
    217a:	3d01      	subs	r5, #1
                            for (;i < _depth;i++)
    217c:	4285      	cmp	r5, r0
    217e:	dc00      	bgt.n	2182 <_Z17DrawTrianglesLoopPhS_+0x40a>
    2180:	e703      	b.n	1f8a <_Z17DrawTrianglesLoopPhS_+0x212>
                                _stack[i] = _stack[i+1];   // remove
    2182:	1c43      	adds	r3, r0, #1
    2184:	009b      	lsls	r3, r3, #2
    2186:	58f3      	ldr	r3, [r6, r3]
    2188:	0082      	lsls	r2, r0, #2
    218a:	50b3      	str	r3, [r6, r2]
								}
							}
                             
                            // Remove
                            _depth--;
                            for (;i < _depth;i++)
    218c:	1c4b      	adds	r3, r1, #1
    218e:	b2d9      	uxtb	r1, r3
    2190:	1c08      	adds	r0, r1, #0
    2192:	428d      	cmp	r5, r1
    2194:	dcf5      	bgt.n	2182 <_Z17DrawTrianglesLoopPhS_+0x40a>
    2196:	e6f8      	b.n	1f8a <_Z17DrawTrianglesLoopPhS_+0x212>
        }
        
        //  New edge
        Vec3& v0 = _vertexes[p0];
        Vec3& v1 = _vertexes[p1];
        if (v0.y == v1.y)
    2198:	007b      	lsls	r3, r7, #1
    219a:	19db      	adds	r3, r3, r7
    219c:	005b      	lsls	r3, r3, #1
    219e:	21fc      	movs	r1, #252
    21a0:	4453      	add	r3, sl
    21a2:	0049      	lsls	r1, r1, #1
    21a4:	4642      	mov	r2, r8
    21a6:	1858      	adds	r0, r3, r1
    21a8:	0053      	lsls	r3, r2, #1
    21aa:	4443      	add	r3, r8
    21ac:	005b      	lsls	r3, r3, #1
    21ae:	4453      	add	r3, sl
    21b0:	1859      	adds	r1, r3, r1
    21b2:	2408      	movs	r4, #8
    21b4:	5f0a      	ldrsh	r2, [r1, r4]
    21b6:	2408      	movs	r4, #8
    21b8:	5f03      	ldrsh	r3, [r0, r4]
    21ba:	4293      	cmp	r3, r2
    21bc:	d100      	bne.n	21c0 <_Z17DrawTrianglesLoopPhS_+0x448>
    21be:	e767      	b.n	2090 <_Z17DrawTrianglesLoopPhS_+0x318>

#define DRAWFG
#define DRAWBG

inline short CEIL(int _x) { return ((_x + 16) >> 4); }
inline short FLOOR(int _x) { return (_x >> 4); }
    21c0:	1112      	asrs	r2, r2, #4
        if (v0.y == v1.y)
           return false;     // Horizontal edge, no pixels here
               
        short Y = CEIL(v0.y);
        short YEnd = FLOOR(v1.y);
        if (Y > YEnd)
    21c2:	3310      	adds	r3, #16
    21c4:	b294      	uxth	r4, r2
    21c6:	111b      	asrs	r3, r3, #4
    21c8:	9419      	str	r4, [sp, #100]
    21ca:	429a      	cmp	r2, r3
    21cc:	da00      	bge.n	21d0 <_Z17DrawTrianglesLoopPhS_+0x458>
    21ce:	e75f      	b.n	2090 <_Z17DrawTrianglesLoopPhS_+0x318>
        _tail.Prev = &_head;
    }
    
    Edge* NewEdge()
    {
        if (_freeList == 0)
    21d0:	9b0a      	ldr	r3, [sp, #40]
    21d2:	4652      	mov	r2, sl
    21d4:	58d2      	ldr	r2, [r2, r3]
    21d6:	4693      	mov	fp, r2
    21d8:	2a00      	cmp	r2, #0
    21da:	d100      	bne.n	21de <_Z17DrawTrianglesLoopPhS_+0x466>
    21dc:	e758      	b.n	2090 <_Z17DrawTrianglesLoopPhS_+0x318>
            return 0;
        Edge* e = _freeList;
        _freeList = e->Next;
    21de:	6853      	ldr	r3, [r2, #4]
    21e0:	9a0a      	ldr	r2, [sp, #40]
    21e2:	4654      	mov	r4, sl
    21e4:	50a3      	str	r3, [r4, r2]
	    a->Next = this;
    }

    void Setup(Vec3& v1, Vec3& v2)    // from v0 at top to v1 at bottom
    {
        short dy = v2.y - v1.y;
    21e6:	8904      	ldrh	r4, [r0, #8]
        short dx = v2.x - v1.x;    
    21e8:	88c5      	ldrh	r5, [r0, #6]
        long gradient = dx;
        gradient = (gradient << 16) / dy;               // Nasty long division gradient is 16:16 (N.R. instead?)
    21ea:	88c8      	ldrh	r0, [r1, #6]
    21ec:	8909      	ldrh	r1, [r1, #8]
    21ee:	1b40      	subs	r0, r0, r5
    21f0:	1b09      	subs	r1, r1, r4
    21f2:	b209      	sxth	r1, r1
    21f4:	0400      	lsls	r0, r0, #16
    21f6:	f000 feed 	bl	2fd4 <__aeabi_idiv>
        char ey = ((v1.y + 16) & 0xFFF0) - v1.y;        //+-15
    21fa:	b2e4      	uxtb	r4, r4
        X = ((long)v1.x << 12) + ((ey * gradient) >> 4);
    21fc:	1c23      	adds	r3, r4, #0
    21fe:	3310      	adds	r3, #16
    2200:	210f      	movs	r1, #15
    2202:	438b      	bics	r3, r1
    2204:	1b1b      	subs	r3, r3, r4
    2206:	b2db      	uxtb	r3, r3
    2208:	4343      	muls	r3, r0
    220a:	b22d      	sxth	r5, r5
    220c:	111b      	asrs	r3, r3, #4
    220e:	032d      	lsls	r5, r5, #12
    2210:	465a      	mov	r2, fp
    2212:	195b      	adds	r3, r3, r5
    2214:	60d3      	str	r3, [r2, #12]
        if (!e)
            return false;     // out of edges.
        
        e->Setup(v0,v1);
        e->p0 = p0;
        e->p1 = p1;
    2216:	4643      	mov	r3, r8
        e = NewEdge();
        if (!e)
            return false;     // out of edges.
        
        e->Setup(v0,v1);
        e->p0 = p0;
    2218:	7517      	strb	r7, [r2, #20]
        e->p1 = p1;
    221a:	7553      	strb	r3, [r2, #21]
        e->YEnd = YEnd;
    221c:	ac19      	add	r4, sp, #100
    221e:	8827      	ldrh	r7, [r4, #0]
        short dx = v2.x - v1.x;    
        long gradient = dx;
        gradient = (gradient << 16) / dy;               // Nasty long division gradient is 16:16 (N.R. instead?)
        char ey = ((v1.y + 16) & 0xFFF0) - v1.y;        //+-15
        X = ((long)v1.x << 12) + ((ey * gradient) >> 4);
        XStep = gradient;
    2220:	6110      	str	r0, [r2, #16]
        
        e->Setup(v0,v1);
        e->p0 = p0;
        e->p1 = p1;
        e->YEnd = YEnd;
        if (left)
    2222:	9811      	ldr	r0, [sp, #68]
            return false;     // out of edges.
        
        e->Setup(v0,v1);
        e->p0 = p0;
        e->p1 = p1;
        e->YEnd = YEnd;
    2224:	465c      	mov	r4, fp
    2226:	8127      	strh	r7, [r4, #8]
        if (left)
    2228:	2800      	cmp	r0, #0
    222a:	d100      	bne.n	222e <_Z17DrawTrianglesLoopPhS_+0x4b6>
    222c:	e1a5      	b.n	257a <_Z17DrawTrianglesLoopPhS_+0x802>
        {
            e->rightTriangle = ti;
    222e:	a90f      	add	r1, sp, #60
    2230:	7809      	ldrb	r1, [r1, #0]
            e->leftTriangle = 0xFF;
    2232:	aa09      	add	r2, sp, #36
        e->p0 = p0;
        e->p1 = p1;
        e->YEnd = YEnd;
        if (left)
        {
            e->rightTriangle = ti;
    2234:	75e1      	strb	r1, [r4, #23]
            e->leftTriangle = 0xFF;
    2236:	7812      	ldrb	r2, [r2, #0]
    2238:	75a2      	strb	r2, [r4, #22]
            e->leftTriangle = ti;
            e->rightTriangle = 0xFF;
        }
        
        //  Insert in new Edge list
        e->Next = _newEdgeList;
    223a:	990b      	ldr	r1, [sp, #44]
    223c:	4650      	mov	r0, sl
    223e:	5843      	ldr	r3, [r0, r1]
    2240:	465a      	mov	r2, fp
    2242:	6053      	str	r3, [r2, #4]
        _newEdgeList = e;
    2244:	5042      	str	r2, [r0, r1]
    2246:	e723      	b.n	2090 <_Z17DrawTrianglesLoopPhS_+0x318>
        }
        
        //  New edge
        Vec3& v0 = _vertexes[p0];
        Vec3& v1 = _vertexes[p1];
        if (v0.y == v1.y)
    2248:	007b      	lsls	r3, r7, #1
    224a:	19db      	adds	r3, r3, r7
    224c:	005b      	lsls	r3, r3, #1
    224e:	21fc      	movs	r1, #252
    2250:	4453      	add	r3, sl
    2252:	0049      	lsls	r1, r1, #1
    2254:	4642      	mov	r2, r8
    2256:	1858      	adds	r0, r3, r1
    2258:	0053      	lsls	r3, r2, #1
    225a:	4443      	add	r3, r8
    225c:	005b      	lsls	r3, r3, #1
    225e:	4453      	add	r3, sl
    2260:	1859      	adds	r1, r3, r1
    2262:	2408      	movs	r4, #8
    2264:	5f0a      	ldrsh	r2, [r1, r4]
    2266:	2408      	movs	r4, #8
    2268:	5f03      	ldrsh	r3, [r0, r4]
    226a:	4293      	cmp	r3, r2
    226c:	d100      	bne.n	2270 <_Z17DrawTrianglesLoopPhS_+0x4f8>
    226e:	e6e5      	b.n	203c <_Z17DrawTrianglesLoopPhS_+0x2c4>

#define DRAWFG
#define DRAWBG

inline short CEIL(int _x) { return ((_x + 16) >> 4); }
inline short FLOOR(int _x) { return (_x >> 4); }
    2270:	1112      	asrs	r2, r2, #4
        if (v0.y == v1.y)
           return false;     // Horizontal edge, no pixels here
               
        short Y = CEIL(v0.y);
        short YEnd = FLOOR(v1.y);
        if (Y > YEnd)
    2272:	3310      	adds	r3, #16
    2274:	b294      	uxth	r4, r2
    2276:	111b      	asrs	r3, r3, #4
    2278:	9418      	str	r4, [sp, #96]
    227a:	429a      	cmp	r2, r3
    227c:	da00      	bge.n	2280 <_Z17DrawTrianglesLoopPhS_+0x508>
    227e:	e6dd      	b.n	203c <_Z17DrawTrianglesLoopPhS_+0x2c4>
        _tail.Prev = &_head;
    }
    
    Edge* NewEdge()
    {
        if (_freeList == 0)
    2280:	9b0a      	ldr	r3, [sp, #40]
    2282:	4652      	mov	r2, sl
    2284:	58d2      	ldr	r2, [r2, r3]
    2286:	4693      	mov	fp, r2
    2288:	2a00      	cmp	r2, #0
    228a:	d100      	bne.n	228e <_Z17DrawTrianglesLoopPhS_+0x516>
    228c:	e6d6      	b.n	203c <_Z17DrawTrianglesLoopPhS_+0x2c4>
            return 0;
        Edge* e = _freeList;
        _freeList = e->Next;
    228e:	6853      	ldr	r3, [r2, #4]
    2290:	9a0a      	ldr	r2, [sp, #40]
    2292:	4654      	mov	r4, sl
    2294:	50a3      	str	r3, [r4, r2]
	    a->Next = this;
    }

    void Setup(Vec3& v1, Vec3& v2)    // from v0 at top to v1 at bottom
    {
        short dy = v2.y - v1.y;
    2296:	8904      	ldrh	r4, [r0, #8]
        short dx = v2.x - v1.x;    
    2298:	88c5      	ldrh	r5, [r0, #6]
        long gradient = dx;
        gradient = (gradient << 16) / dy;               // Nasty long division gradient is 16:16 (N.R. instead?)
    229a:	88c8      	ldrh	r0, [r1, #6]
    229c:	8909      	ldrh	r1, [r1, #8]
    229e:	1b40      	subs	r0, r0, r5
    22a0:	1b09      	subs	r1, r1, r4
    22a2:	b209      	sxth	r1, r1
    22a4:	0400      	lsls	r0, r0, #16
    22a6:	f000 fe95 	bl	2fd4 <__aeabi_idiv>
        char ey = ((v1.y + 16) & 0xFFF0) - v1.y;        //+-15
    22aa:	b2e4      	uxtb	r4, r4
        X = ((long)v1.x << 12) + ((ey * gradient) >> 4);
    22ac:	1c23      	adds	r3, r4, #0
    22ae:	3310      	adds	r3, #16
    22b0:	210f      	movs	r1, #15
    22b2:	438b      	bics	r3, r1
    22b4:	1b1b      	subs	r3, r3, r4
    22b6:	b2db      	uxtb	r3, r3
    22b8:	4343      	muls	r3, r0
    22ba:	b22d      	sxth	r5, r5
    22bc:	111b      	asrs	r3, r3, #4
    22be:	032d      	lsls	r5, r5, #12
    22c0:	465a      	mov	r2, fp
    22c2:	195b      	adds	r3, r3, r5
    22c4:	60d3      	str	r3, [r2, #12]
        if (!e)
            return false;     // out of edges.
        
        e->Setup(v0,v1);
        e->p0 = p0;
        e->p1 = p1;
    22c6:	4643      	mov	r3, r8
        e = NewEdge();
        if (!e)
            return false;     // out of edges.
        
        e->Setup(v0,v1);
        e->p0 = p0;
    22c8:	7517      	strb	r7, [r2, #20]
        e->p1 = p1;
    22ca:	7553      	strb	r3, [r2, #21]
        e->YEnd = YEnd;
    22cc:	ac18      	add	r4, sp, #96
    22ce:	8827      	ldrh	r7, [r4, #0]
        short dx = v2.x - v1.x;    
        long gradient = dx;
        gradient = (gradient << 16) / dy;               // Nasty long division gradient is 16:16 (N.R. instead?)
        char ey = ((v1.y + 16) & 0xFFF0) - v1.y;        //+-15
        X = ((long)v1.x << 12) + ((ey * gradient) >> 4);
        XStep = gradient;
    22d0:	6110      	str	r0, [r2, #16]
        
        e->Setup(v0,v1);
        e->p0 = p0;
        e->p1 = p1;
        e->YEnd = YEnd;
        if (left)
    22d2:	9810      	ldr	r0, [sp, #64]
            return false;     // out of edges.
        
        e->Setup(v0,v1);
        e->p0 = p0;
        e->p1 = p1;
        e->YEnd = YEnd;
    22d4:	465c      	mov	r4, fp
    22d6:	8127      	strh	r7, [r4, #8]
        if (left)
    22d8:	2800      	cmp	r0, #0
    22da:	d100      	bne.n	22de <_Z17DrawTrianglesLoopPhS_+0x566>
    22dc:	e155      	b.n	258a <_Z17DrawTrianglesLoopPhS_+0x812>
        {
            e->rightTriangle = ti;
    22de:	a90e      	add	r1, sp, #56
    22e0:	7809      	ldrb	r1, [r1, #0]
            e->leftTriangle = 0xFF;
    22e2:	aa09      	add	r2, sp, #36
        e->p0 = p0;
        e->p1 = p1;
        e->YEnd = YEnd;
        if (left)
        {
            e->rightTriangle = ti;
    22e4:	75e1      	strb	r1, [r4, #23]
            e->leftTriangle = 0xFF;
    22e6:	7812      	ldrb	r2, [r2, #0]
    22e8:	75a2      	strb	r2, [r4, #22]
            e->leftTriangle = ti;
            e->rightTriangle = 0xFF;
        }
        
        //  Insert in new Edge list
        e->Next = _newEdgeList;
    22ea:	990b      	ldr	r1, [sp, #44]
    22ec:	4650      	mov	r0, sl
    22ee:	5843      	ldr	r3, [r0, r1]
    22f0:	465a      	mov	r2, fp
    22f2:	6053      	str	r3, [r2, #4]
        _newEdgeList = e;
    22f4:	5042      	str	r2, [r0, r1]
    22f6:	e6a1      	b.n	203c <_Z17DrawTrianglesLoopPhS_+0x2c4>
        }
        
        //  New edge
        Vec3& v0 = _vertexes[p0];
        Vec3& v1 = _vertexes[p1];
        if (v0.y == v1.y)
    22f8:	0073      	lsls	r3, r6, #1
    22fa:	199b      	adds	r3, r3, r6
    22fc:	005b      	lsls	r3, r3, #1
    22fe:	27fc      	movs	r7, #252
    2300:	007f      	lsls	r7, r7, #1
    2302:	4453      	add	r3, sl
    2304:	4642      	mov	r2, r8
    2306:	19d8      	adds	r0, r3, r7
    2308:	0053      	lsls	r3, r2, #1
    230a:	4443      	add	r3, r8
    230c:	005b      	lsls	r3, r3, #1
    230e:	4453      	add	r3, sl
    2310:	18fc      	adds	r4, r7, r3
    2312:	46a4      	mov	ip, r4
    2314:	2708      	movs	r7, #8
    2316:	5fc3      	ldrsh	r3, [r0, r7]
    2318:	2208      	movs	r2, #8
    231a:	5ea2      	ldrsh	r2, [r4, r2]
    231c:	4293      	cmp	r3, r2
    231e:	d100      	bne.n	2322 <_Z17DrawTrianglesLoopPhS_+0x5aa>
    2320:	e59a      	b.n	1e58 <_Z17DrawTrianglesLoopPhS_+0xe0>

#define DRAWFG
#define DRAWBG

inline short CEIL(int _x) { return ((_x + 16) >> 4); }
inline short FLOOR(int _x) { return (_x >> 4); }
    2322:	1112      	asrs	r2, r2, #4
        if (v0.y == v1.y)
           return false;     // Horizontal edge, no pixels here
               
        short Y = CEIL(v0.y);
        short YEnd = FLOOR(v1.y);
        if (Y > YEnd)
    2324:	3310      	adds	r3, #16
    2326:	b297      	uxth	r7, r2
    2328:	111b      	asrs	r3, r3, #4
    232a:	9716      	str	r7, [sp, #88]
    232c:	429a      	cmp	r2, r3
    232e:	da00      	bge.n	2332 <_Z17DrawTrianglesLoopPhS_+0x5ba>
    2330:	e592      	b.n	1e58 <_Z17DrawTrianglesLoopPhS_+0xe0>
        _tail.Prev = &_head;
    }
    
    Edge* NewEdge()
    {
        if (_freeList == 0)
    2332:	9b05      	ldr	r3, [sp, #20]
    2334:	4652      	mov	r2, sl
    2336:	58d7      	ldr	r7, [r2, r3]
    2338:	2f00      	cmp	r7, #0
    233a:	d100      	bne.n	233e <_Z17DrawTrianglesLoopPhS_+0x5c6>
    233c:	e58c      	b.n	1e58 <_Z17DrawTrianglesLoopPhS_+0xe0>
    233e:	1c1c      	adds	r4, r3, #0
            return 0;
        Edge* e = _freeList;
        _freeList = e->Next;
    2340:	687b      	ldr	r3, [r7, #4]
    void Setup(Vec3& v1, Vec3& v2)    // from v0 at top to v1 at bottom
    {
        short dy = v2.y - v1.y;
        short dx = v2.x - v1.x;    
        long gradient = dx;
        gradient = (gradient << 16) / dy;               // Nasty long division gradient is 16:16 (N.R. instead?)
    2342:	4661      	mov	r1, ip
    Edge* NewEdge()
    {
        if (_freeList == 0)
            return 0;
        Edge* e = _freeList;
        _freeList = e->Next;
    2344:	5113      	str	r3, [r2, r4]
	    a->Next = this;
    }

    void Setup(Vec3& v1, Vec3& v2)    // from v0 at top to v1 at bottom
    {
        short dy = v2.y - v1.y;
    2346:	8904      	ldrh	r4, [r0, #8]
        short dx = v2.x - v1.x;    
    2348:	88c5      	ldrh	r5, [r0, #6]
        long gradient = dx;
        gradient = (gradient << 16) / dy;               // Nasty long division gradient is 16:16 (N.R. instead?)
    234a:	88c8      	ldrh	r0, [r1, #6]
    234c:	8909      	ldrh	r1, [r1, #8]
    234e:	1b40      	subs	r0, r0, r5
    2350:	1b09      	subs	r1, r1, r4
    2352:	0400      	lsls	r0, r0, #16
    2354:	b209      	sxth	r1, r1
    2356:	f000 fe3d 	bl	2fd4 <__aeabi_idiv>
        char ey = ((v1.y + 16) & 0xFFF0) - v1.y;        //+-15
    235a:	b2e4      	uxtb	r4, r4
        X = ((long)v1.x << 12) + ((ey * gradient) >> 4);
    235c:	1c23      	adds	r3, r4, #0
    235e:	3310      	adds	r3, #16
    2360:	220f      	movs	r2, #15
    2362:	4393      	bics	r3, r2
    2364:	1b1b      	subs	r3, r3, r4
    2366:	b2db      	uxtb	r3, r3
    2368:	4343      	muls	r3, r0
    236a:	b22d      	sxth	r5, r5
    236c:	111b      	asrs	r3, r3, #4
    236e:	032d      	lsls	r5, r5, #12
    2370:	195b      	adds	r3, r3, r5
    2372:	60fb      	str	r3, [r7, #12]
        if (!e)
            return false;     // out of edges.
        
        e->Setup(v0,v1);
        e->p0 = p0;
        e->p1 = p1;
    2374:	4643      	mov	r3, r8
        e = NewEdge();
        if (!e)
            return false;     // out of edges.
        
        e->Setup(v0,v1);
        e->p0 = p0;
    2376:	753e      	strb	r6, [r7, #20]
        e->p1 = p1;
    2378:	757b      	strb	r3, [r7, #21]
        e->YEnd = YEnd;
    237a:	ac16      	add	r4, sp, #88
        short dx = v2.x - v1.x;    
        long gradient = dx;
        gradient = (gradient << 16) / dy;               // Nasty long division gradient is 16:16 (N.R. instead?)
        char ey = ((v1.y + 16) & 0xFFF0) - v1.y;        //+-15
        X = ((long)v1.x << 12) + ((ey * gradient) >> 4);
        XStep = gradient;
    237c:	6138      	str	r0, [r7, #16]
            return false;     // out of edges.
        
        e->Setup(v0,v1);
        e->p0 = p0;
        e->p1 = p1;
        e->YEnd = YEnd;
    237e:	8824      	ldrh	r4, [r4, #0]
        if (left)
    2380:	9812      	ldr	r0, [sp, #72]
            return false;     // out of edges.
        
        e->Setup(v0,v1);
        e->p0 = p0;
        e->p1 = p1;
        e->YEnd = YEnd;
    2382:	813c      	strh	r4, [r7, #8]
        if (left)
    2384:	2800      	cmp	r0, #0
    2386:	d100      	bne.n	238a <_Z17DrawTrianglesLoopPhS_+0x612>
    2388:	e0dc      	b.n	2544 <_Z17DrawTrianglesLoopPhS_+0x7cc>
        {
            e->rightTriangle = ti;
    238a:	a914      	add	r1, sp, #80
    238c:	7809      	ldrb	r1, [r1, #0]
            e->leftTriangle = 0xFF;
    238e:	466a      	mov	r2, sp
        e->p0 = p0;
        e->p1 = p1;
        e->YEnd = YEnd;
        if (left)
        {
            e->rightTriangle = ti;
    2390:	75f9      	strb	r1, [r7, #23]
            e->leftTriangle = 0xFF;
    2392:	2310      	movs	r3, #16
    2394:	5c9a      	ldrb	r2, [r3, r2]
    2396:	75ba      	strb	r2, [r7, #22]
            e->leftTriangle = ti;
            e->rightTriangle = 0xFF;
        }
        
        //  Insert in new Edge list
        e->Next = _newEdgeList;
    2398:	9906      	ldr	r1, [sp, #24]
    239a:	4650      	mov	r0, sl
    239c:	5843      	ldr	r3, [r0, r1]
                    break;
                    
                //  Activate first 2 triangle edges
                bool dem = t.fill & 0x80;
                Setup(t.p0,t.p2,ti,dem);
                if (!Setup(t.p0,t.p1,ti,!dem))	// if p0.y == p1.y edge won't be inserted so ...
    239e:	465a      	mov	r2, fp
            e->leftTriangle = ti;
            e->rightTriangle = 0xFF;
        }
        
        //  Insert in new Edge list
        e->Next = _newEdgeList;
    23a0:	607b      	str	r3, [r7, #4]
                    break;
                    
                //  Activate first 2 triangle edges
                bool dem = t.fill & 0x80;
                Setup(t.p0,t.p2,ti,dem);
                if (!Setup(t.p0,t.p1,ti,!dem))	// if p0.y == p1.y edge won't be inserted so ...
    23a2:	0093      	lsls	r3, r2, #2
            e->rightTriangle = 0xFF;
        }
        
        //  Insert in new Edge list
        e->Next = _newEdgeList;
        _newEdgeList = e;
    23a4:	5047      	str	r7, [r0, r1]
                    break;
                    
                //  Activate first 2 triangle edges
                bool dem = t.fill & 0x80;
                Setup(t.p0,t.p2,ti,dem);
                if (!Setup(t.p0,t.p1,ti,!dem))	// if p0.y == p1.y edge won't be inserted so ...
    23a6:	444b      	add	r3, r9
    23a8:	799e      	ldrb	r6, [r3, #6]
    23aa:	79db      	ldrb	r3, [r3, #7]
    23ac:	2401      	movs	r4, #1
    23ae:	4698      	mov	r8, r3
    23b0:	9b12      	ldr	r3, [sp, #72]
    23b2:	1c39      	adds	r1, r7, #0
    23b4:	4063      	eors	r3, r4
    23b6:	b2db      	uxtb	r3, r3
    23b8:	9313      	str	r3, [sp, #76]
    23ba:	e560      	b.n	1e7e <_Z17DrawTrianglesLoopPhS_+0x106>
    bool Setup(byte p0, byte p1, byte ti, bool left)
    {
        //  Does the edge already exist?
        //  Only need to search the new Edge list, can only match newly created edges
        Edge* e = _newEdgeList;
        while (e)
    23bc:	1c39      	adds	r1, r7, #0
        }
        
        //  New edge
        Vec3& v0 = _vertexes[p0];
        Vec3& v1 = _vertexes[p1];
        if (v0.y == v1.y)
    23be:	0073      	lsls	r3, r6, #1
    23c0:	199b      	adds	r3, r3, r6
    23c2:	4642      	mov	r2, r8
    23c4:	005b      	lsls	r3, r3, #1
    23c6:	27fc      	movs	r7, #252
    23c8:	007f      	lsls	r7, r7, #1
    23ca:	4453      	add	r3, sl
    23cc:	0055      	lsls	r5, r2, #1
    23ce:	19d8      	adds	r0, r3, r7
    23d0:	18ab      	adds	r3, r5, r2
    23d2:	005b      	lsls	r3, r3, #1
    23d4:	4453      	add	r3, sl
    23d6:	18fc      	adds	r4, r7, r3
    23d8:	46a4      	mov	ip, r4
    23da:	2708      	movs	r7, #8
    23dc:	5fc3      	ldrsh	r3, [r0, r7]
    23de:	2208      	movs	r2, #8
    23e0:	5ea4      	ldrsh	r4, [r4, r2]
    23e2:	42a3      	cmp	r3, r4
    23e4:	d03d      	beq.n	2462 <_Z17DrawTrianglesLoopPhS_+0x6ea>

#define DRAWFG
#define DRAWBG

inline short CEIL(int _x) { return ((_x + 16) >> 4); }
inline short FLOOR(int _x) { return (_x >> 4); }
    23e6:	1122      	asrs	r2, r4, #4
        if (v0.y == v1.y)
           return false;     // Horizontal edge, no pixels here
               
        short Y = CEIL(v0.y);
        short YEnd = FLOOR(v1.y);
        if (Y > YEnd)
    23e8:	3310      	adds	r3, #16
    23ea:	b297      	uxth	r7, r2
    23ec:	111b      	asrs	r3, r3, #4
    23ee:	9717      	str	r7, [sp, #92]
    23f0:	429a      	cmp	r2, r3
    23f2:	db36      	blt.n	2462 <_Z17DrawTrianglesLoopPhS_+0x6ea>
        _tail.Prev = &_head;
    }
    
    Edge* NewEdge()
    {
        if (_freeList == 0)
    23f4:	9b05      	ldr	r3, [sp, #20]
    23f6:	4652      	mov	r2, sl
    23f8:	58d7      	ldr	r7, [r2, r3]
    23fa:	2f00      	cmp	r7, #0
    23fc:	d031      	beq.n	2462 <_Z17DrawTrianglesLoopPhS_+0x6ea>
    23fe:	1c1c      	adds	r4, r3, #0
            return 0;
        Edge* e = _freeList;
        _freeList = e->Next;
    2400:	687b      	ldr	r3, [r7, #4]
    void Setup(Vec3& v1, Vec3& v2)    // from v0 at top to v1 at bottom
    {
        short dy = v2.y - v1.y;
        short dx = v2.x - v1.x;    
        long gradient = dx;
        gradient = (gradient << 16) / dy;               // Nasty long division gradient is 16:16 (N.R. instead?)
    2402:	4661      	mov	r1, ip
    Edge* NewEdge()
    {
        if (_freeList == 0)
            return 0;
        Edge* e = _freeList;
        _freeList = e->Next;
    2404:	5113      	str	r3, [r2, r4]
	    a->Next = this;
    }

    void Setup(Vec3& v1, Vec3& v2)    // from v0 at top to v1 at bottom
    {
        short dy = v2.y - v1.y;
    2406:	8904      	ldrh	r4, [r0, #8]
        short dx = v2.x - v1.x;    
    2408:	88c5      	ldrh	r5, [r0, #6]
        long gradient = dx;
        gradient = (gradient << 16) / dy;               // Nasty long division gradient is 16:16 (N.R. instead?)
    240a:	88c8      	ldrh	r0, [r1, #6]
    240c:	8909      	ldrh	r1, [r1, #8]
    240e:	1b40      	subs	r0, r0, r5
    2410:	1b09      	subs	r1, r1, r4
    2412:	0400      	lsls	r0, r0, #16
    2414:	b209      	sxth	r1, r1
    2416:	f000 fddd 	bl	2fd4 <__aeabi_idiv>
        char ey = ((v1.y + 16) & 0xFFF0) - v1.y;        //+-15
    241a:	b2e4      	uxtb	r4, r4
        X = ((long)v1.x << 12) + ((ey * gradient) >> 4);
    241c:	1c23      	adds	r3, r4, #0
    241e:	3310      	adds	r3, #16
    2420:	220f      	movs	r2, #15
    2422:	4393      	bics	r3, r2
    2424:	1b1b      	subs	r3, r3, r4
    2426:	b2db      	uxtb	r3, r3
    2428:	4343      	muls	r3, r0
    242a:	b22d      	sxth	r5, r5
    242c:	111b      	asrs	r3, r3, #4
    242e:	032d      	lsls	r5, r5, #12
    2430:	195b      	adds	r3, r3, r5
    2432:	60fb      	str	r3, [r7, #12]
        if (!e)
            return false;     // out of edges.
        
        e->Setup(v0,v1);
        e->p0 = p0;
        e->p1 = p1;
    2434:	4643      	mov	r3, r8
        e = NewEdge();
        if (!e)
            return false;     // out of edges.
        
        e->Setup(v0,v1);
        e->p0 = p0;
    2436:	753e      	strb	r6, [r7, #20]
        e->p1 = p1;
    2438:	757b      	strb	r3, [r7, #21]
        e->YEnd = YEnd;
    243a:	ac17      	add	r4, sp, #92
        short dx = v2.x - v1.x;    
        long gradient = dx;
        gradient = (gradient << 16) / dy;               // Nasty long division gradient is 16:16 (N.R. instead?)
        char ey = ((v1.y + 16) & 0xFFF0) - v1.y;        //+-15
        X = ((long)v1.x << 12) + ((ey * gradient) >> 4);
        XStep = gradient;
    243c:	6138      	str	r0, [r7, #16]
            return false;     // out of edges.
        
        e->Setup(v0,v1);
        e->p0 = p0;
        e->p1 = p1;
        e->YEnd = YEnd;
    243e:	8824      	ldrh	r4, [r4, #0]
        if (left)
    2440:	9813      	ldr	r0, [sp, #76]
            return false;     // out of edges.
        
        e->Setup(v0,v1);
        e->p0 = p0;
        e->p1 = p1;
        e->YEnd = YEnd;
    2442:	813c      	strh	r4, [r7, #8]
        if (left)
    2444:	2800      	cmp	r0, #0
    2446:	d075      	beq.n	2534 <_Z17DrawTrianglesLoopPhS_+0x7bc>
        {
            e->rightTriangle = ti;
    2448:	a914      	add	r1, sp, #80
    244a:	7809      	ldrb	r1, [r1, #0]
            e->leftTriangle = 0xFF;
    244c:	466a      	mov	r2, sp
        e->p0 = p0;
        e->p1 = p1;
        e->YEnd = YEnd;
        if (left)
        {
            e->rightTriangle = ti;
    244e:	75f9      	strb	r1, [r7, #23]
            e->leftTriangle = 0xFF;
    2450:	2310      	movs	r3, #16
    2452:	5c9a      	ldrb	r2, [r3, r2]
    2454:	75ba      	strb	r2, [r7, #22]
            e->leftTriangle = ti;
            e->rightTriangle = 0xFF;
        }
        
        //  Insert in new Edge list
        e->Next = _newEdgeList;
    2456:	9906      	ldr	r1, [sp, #24]
    2458:	4650      	mov	r0, sl
    245a:	5843      	ldr	r3, [r0, r1]
    245c:	607b      	str	r3, [r7, #4]
        _newEdgeList = e;
    245e:	5047      	str	r7, [r0, r1]
    2460:	e51a      	b.n	1e98 <_Z17DrawTrianglesLoopPhS_+0x120>
                    
                //  Activate first 2 triangle edges
                bool dem = t.fill & 0x80;
                Setup(t.p0,t.p2,ti,dem);
                if (!Setup(t.p0,t.p1,ti,!dem))	// if p0.y == p1.y edge won't be inserted so ...
                    Setup(t.p1,t.p2,ti,!dem);	//  ... setup thrid immediately
    2462:	465f      	mov	r7, fp
    2464:	00bb      	lsls	r3, r7, #2
    2466:	444b      	add	r3, r9
    2468:	7a1e      	ldrb	r6, [r3, #8]
    bool Setup(byte p0, byte p1, byte ti, bool left)
    {
        //  Does the edge already exist?
        //  Only need to search the new Edge list, can only match newly created edges
        Edge* e = _newEdgeList;
        while (e)
    246a:	2900      	cmp	r1, #0
    246c:	d103      	bne.n	2476 <_Z17DrawTrianglesLoopPhS_+0x6fe>
    246e:	e00c      	b.n	248a <_Z17DrawTrianglesLoopPhS_+0x712>
                    e->rightTriangle = ti;
                else
                    e->leftTriangle = ti;
                return true;
            }
            e = e->Next;
    2470:	6849      	ldr	r1, [r1, #4]
    bool Setup(byte p0, byte p1, byte ti, bool left)
    {
        //  Does the edge already exist?
        //  Only need to search the new Edge list, can only match newly created edges
        Edge* e = _newEdgeList;
        while (e)
    2472:	2900      	cmp	r1, #0
    2474:	d009      	beq.n	248a <_Z17DrawTrianglesLoopPhS_+0x712>
        {
            if (e->p0 == p0 && e->p1 == p1) // Share existing edge
    2476:	7d0b      	ldrb	r3, [r1, #20]
    2478:	4543      	cmp	r3, r8
    247a:	d1f9      	bne.n	2470 <_Z17DrawTrianglesLoopPhS_+0x6f8>
    247c:	7d4b      	ldrb	r3, [r1, #21]
    247e:	42b3      	cmp	r3, r6
    2480:	d100      	bne.n	2484 <_Z17DrawTrianglesLoopPhS_+0x70c>
    2482:	e502      	b.n	1e8a <_Z17DrawTrianglesLoopPhS_+0x112>
                    e->rightTriangle = ti;
                else
                    e->leftTriangle = ti;
                return true;
            }
            e = e->Next;
    2484:	6849      	ldr	r1, [r1, #4]
    bool Setup(byte p0, byte p1, byte ti, bool left)
    {
        //  Does the edge already exist?
        //  Only need to search the new Edge list, can only match newly created edges
        Edge* e = _newEdgeList;
        while (e)
    2486:	2900      	cmp	r1, #0
    2488:	d1f5      	bne.n	2476 <_Z17DrawTrianglesLoopPhS_+0x6fe>
        }
        
        //  New edge
        Vec3& v0 = _vertexes[p0];
        Vec3& v1 = _vertexes[p1];
        if (v0.y == v1.y)
    248a:	0073      	lsls	r3, r6, #1
    248c:	199b      	adds	r3, r3, r6
    248e:	005b      	lsls	r3, r3, #1
    2490:	27fc      	movs	r7, #252
    2492:	4453      	add	r3, sl
    2494:	007f      	lsls	r7, r7, #1
    2496:	19d9      	adds	r1, r3, r7
    2498:	2008      	movs	r0, #8
    249a:	5e0a      	ldrsh	r2, [r1, r0]
    249c:	4294      	cmp	r4, r2
    249e:	d100      	bne.n	24a2 <_Z17DrawTrianglesLoopPhS_+0x72a>
    24a0:	e4fa      	b.n	1e98 <_Z17DrawTrianglesLoopPhS_+0x120>
           return false;     // Horizontal edge, no pixels here
               
        short Y = CEIL(v0.y);
        short YEnd = FLOOR(v1.y);
        if (Y > YEnd)
    24a2:	1c23      	adds	r3, r4, #0

#define DRAWFG
#define DRAWBG

inline short CEIL(int _x) { return ((_x + 16) >> 4); }
inline short FLOOR(int _x) { return (_x >> 4); }
    24a4:	1112      	asrs	r2, r2, #4
        if (v0.y == v1.y)
           return false;     // Horizontal edge, no pixels here
               
        short Y = CEIL(v0.y);
        short YEnd = FLOOR(v1.y);
        if (Y > YEnd)
    24a6:	3310      	adds	r3, #16
    24a8:	b294      	uxth	r4, r2
    24aa:	111b      	asrs	r3, r3, #4
    24ac:	46a3      	mov	fp, r4
    24ae:	429a      	cmp	r2, r3
    24b0:	da00      	bge.n	24b4 <_Z17DrawTrianglesLoopPhS_+0x73c>
    24b2:	e4f1      	b.n	1e98 <_Z17DrawTrianglesLoopPhS_+0x120>
        _tail.Prev = &_head;
    }
    
    Edge* NewEdge()
    {
        if (_freeList == 0)
    24b4:	9a05      	ldr	r2, [sp, #20]
    24b6:	4650      	mov	r0, sl
    24b8:	5887      	ldr	r7, [r0, r2]
    24ba:	2f00      	cmp	r7, #0
    24bc:	d100      	bne.n	24c0 <_Z17DrawTrianglesLoopPhS_+0x748>
    24be:	e4eb      	b.n	1e98 <_Z17DrawTrianglesLoopPhS_+0x120>
            return 0;
        Edge* e = _freeList;
        _freeList = e->Next;
    24c0:	687b      	ldr	r3, [r7, #4]
	    a->Next = this;
    }

    void Setup(Vec3& v1, Vec3& v2)    // from v0 at top to v1 at bottom
    {
        short dy = v2.y - v1.y;
    24c2:	4644      	mov	r4, r8
    Edge* NewEdge()
    {
        if (_freeList == 0)
            return 0;
        Edge* e = _freeList;
        _freeList = e->Next;
    24c4:	5083      	str	r3, [r0, r2]
	    a->Next = this;
    }

    void Setup(Vec3& v1, Vec3& v2)    // from v0 at top to v1 at bottom
    {
        short dy = v2.y - v1.y;
    24c6:	192b      	adds	r3, r5, r4
    24c8:	005b      	lsls	r3, r3, #1
    24ca:	20fc      	movs	r0, #252
    24cc:	0040      	lsls	r0, r0, #1
    24ce:	4453      	add	r3, sl
    24d0:	181b      	adds	r3, r3, r0
    24d2:	891c      	ldrh	r4, [r3, #8]
        short dx = v2.x - v1.x;    
    24d4:	88dd      	ldrh	r5, [r3, #6]
        long gradient = dx;
        gradient = (gradient << 16) / dy;               // Nasty long division gradient is 16:16 (N.R. instead?)
    24d6:	88c8      	ldrh	r0, [r1, #6]
    24d8:	8909      	ldrh	r1, [r1, #8]
    24da:	1b40      	subs	r0, r0, r5
    24dc:	1b09      	subs	r1, r1, r4
    24de:	b209      	sxth	r1, r1
    24e0:	0400      	lsls	r0, r0, #16
    24e2:	f000 fd77 	bl	2fd4 <__aeabi_idiv>
        char ey = ((v1.y + 16) & 0xFFF0) - v1.y;        //+-15
    24e6:	b2e4      	uxtb	r4, r4
        X = ((long)v1.x << 12) + ((ey * gradient) >> 4);
    24e8:	1c23      	adds	r3, r4, #0
    24ea:	3310      	adds	r3, #16
    24ec:	210f      	movs	r1, #15
    24ee:	438b      	bics	r3, r1
    24f0:	1b1b      	subs	r3, r3, r4
    24f2:	b2db      	uxtb	r3, r3
    24f4:	4343      	muls	r3, r0
    24f6:	b22d      	sxth	r5, r5
        e = NewEdge();
        if (!e)
            return false;     // out of edges.
        
        e->Setup(v0,v1);
        e->p0 = p0;
    24f8:	4642      	mov	r2, r8
        short dy = v2.y - v1.y;
        short dx = v2.x - v1.x;    
        long gradient = dx;
        gradient = (gradient << 16) / dy;               // Nasty long division gradient is 16:16 (N.R. instead?)
        char ey = ((v1.y + 16) & 0xFFF0) - v1.y;        //+-15
        X = ((long)v1.x << 12) + ((ey * gradient) >> 4);
    24fa:	111b      	asrs	r3, r3, #4
    24fc:	032d      	lsls	r5, r5, #12
        e = NewEdge();
        if (!e)
            return false;     // out of edges.
        
        e->Setup(v0,v1);
        e->p0 = p0;
    24fe:	753a      	strb	r2, [r7, #20]
        e->p1 = p1;
    2500:	757e      	strb	r6, [r7, #21]
        short dy = v2.y - v1.y;
        short dx = v2.x - v1.x;    
        long gradient = dx;
        gradient = (gradient << 16) / dy;               // Nasty long division gradient is 16:16 (N.R. instead?)
        char ey = ((v1.y + 16) & 0xFFF0) - v1.y;        //+-15
        X = ((long)v1.x << 12) + ((ey * gradient) >> 4);
    2502:	195b      	adds	r3, r3, r5
        
        e->Setup(v0,v1);
        e->p0 = p0;
        e->p1 = p1;
        e->YEnd = YEnd;
        if (left)
    2504:	9c13      	ldr	r4, [sp, #76]
        short dy = v2.y - v1.y;
        short dx = v2.x - v1.x;    
        long gradient = dx;
        gradient = (gradient << 16) / dy;               // Nasty long division gradient is 16:16 (N.R. instead?)
        char ey = ((v1.y + 16) & 0xFFF0) - v1.y;        //+-15
        X = ((long)v1.x << 12) + ((ey * gradient) >> 4);
    2506:	60fb      	str	r3, [r7, #12]
            return false;     // out of edges.
        
        e->Setup(v0,v1);
        e->p0 = p0;
        e->p1 = p1;
        e->YEnd = YEnd;
    2508:	465b      	mov	r3, fp
        short dx = v2.x - v1.x;    
        long gradient = dx;
        gradient = (gradient << 16) / dy;               // Nasty long division gradient is 16:16 (N.R. instead?)
        char ey = ((v1.y + 16) & 0xFFF0) - v1.y;        //+-15
        X = ((long)v1.x << 12) + ((ey * gradient) >> 4);
        XStep = gradient;
    250a:	6138      	str	r0, [r7, #16]
            return false;     // out of edges.
        
        e->Setup(v0,v1);
        e->p0 = p0;
        e->p1 = p1;
        e->YEnd = YEnd;
    250c:	813b      	strh	r3, [r7, #8]
        if (left)
    250e:	2c00      	cmp	r4, #0
    2510:	d02b      	beq.n	256a <_Z17DrawTrianglesLoopPhS_+0x7f2>
        {
            e->rightTriangle = ti;
    2512:	a814      	add	r0, sp, #80
    2514:	7800      	ldrb	r0, [r0, #0]
            e->leftTriangle = 0xFF;
    2516:	4669      	mov	r1, sp
        e->p0 = p0;
        e->p1 = p1;
        e->YEnd = YEnd;
        if (left)
        {
            e->rightTriangle = ti;
    2518:	75f8      	strb	r0, [r7, #23]
            e->leftTriangle = 0xFF;
    251a:	2210      	movs	r2, #16
    251c:	5c51      	ldrb	r1, [r2, r1]
    251e:	75b9      	strb	r1, [r7, #22]
            e->leftTriangle = ti;
            e->rightTriangle = 0xFF;
        }
        
        //  Insert in new Edge list
        e->Next = _newEdgeList;
    2520:	9806      	ldr	r0, [sp, #24]
    2522:	4654      	mov	r4, sl
    2524:	5823      	ldr	r3, [r4, r0]
    2526:	607b      	str	r3, [r7, #4]
        _newEdgeList = e;
    2528:	5027      	str	r7, [r4, r0]
    252a:	e4b5      	b.n	1e98 <_Z17DrawTrianglesLoopPhS_+0x120>
            if (e->p0 == p0 && e->p1 == p1) // Share existing edge
            {
                if (left)
                    e->rightTriangle = ti;
                else
                    e->leftTriangle = ti;
    252c:	ac14      	add	r4, sp, #80
    252e:	7824      	ldrb	r4, [r4, #0]
    2530:	758c      	strb	r4, [r1, #22]
    2532:	e4b1      	b.n	1e98 <_Z17DrawTrianglesLoopPhS_+0x120>
            e->rightTriangle = ti;
            e->leftTriangle = 0xFF;
        }
        else
        {
            e->leftTriangle = ti;
    2534:	ab14      	add	r3, sp, #80
    2536:	781b      	ldrb	r3, [r3, #0]
            e->rightTriangle = 0xFF;
    2538:	466c      	mov	r4, sp
            e->rightTriangle = ti;
            e->leftTriangle = 0xFF;
        }
        else
        {
            e->leftTriangle = ti;
    253a:	75bb      	strb	r3, [r7, #22]
            e->rightTriangle = 0xFF;
    253c:	2010      	movs	r0, #16
    253e:	5d04      	ldrb	r4, [r0, r4]
    2540:	75fc      	strb	r4, [r7, #23]
    2542:	e788      	b.n	2456 <_Z17DrawTrianglesLoopPhS_+0x6de>
            e->rightTriangle = ti;
            e->leftTriangle = 0xFF;
        }
        else
        {
            e->leftTriangle = ti;
    2544:	ab14      	add	r3, sp, #80
    2546:	781b      	ldrb	r3, [r3, #0]
            e->rightTriangle = 0xFF;
    2548:	466c      	mov	r4, sp
            e->rightTriangle = ti;
            e->leftTriangle = 0xFF;
        }
        else
        {
            e->leftTriangle = ti;
    254a:	75bb      	strb	r3, [r7, #22]
            e->rightTriangle = 0xFF;
    254c:	2010      	movs	r0, #16
    254e:	5d04      	ldrb	r4, [r0, r4]
    2550:	75fc      	strb	r4, [r7, #23]
    2552:	e721      	b.n	2398 <_Z17DrawTrianglesLoopPhS_+0x620>
            if (e->p0 == p0 && e->p1 == p1) // Share existing edge
            {
                if (left)
                    e->rightTriangle = ti;
                else
                    e->leftTriangle = ti;
    2554:	a914      	add	r1, sp, #80
    2556:	7809      	ldrb	r1, [r1, #0]
    2558:	7591      	strb	r1, [r2, #22]
    255a:	465a      	mov	r2, fp
    255c:	0093      	lsls	r3, r2, #2
    255e:	444b      	add	r3, r9
    2560:	9c06      	ldr	r4, [sp, #24]
    2562:	799e      	ldrb	r6, [r3, #6]
    2564:	4653      	mov	r3, sl
    2566:	5919      	ldr	r1, [r3, r4]
    2568:	e476      	b.n	1e58 <_Z17DrawTrianglesLoopPhS_+0xe0>
            e->rightTriangle = ti;
            e->leftTriangle = 0xFF;
        }
        else
        {
            e->leftTriangle = ti;
    256a:	aa14      	add	r2, sp, #80
    256c:	7812      	ldrb	r2, [r2, #0]
            e->rightTriangle = 0xFF;
    256e:	466b      	mov	r3, sp
            e->rightTriangle = ti;
            e->leftTriangle = 0xFF;
        }
        else
        {
            e->leftTriangle = ti;
    2570:	75ba      	strb	r2, [r7, #22]
            e->rightTriangle = 0xFF;
    2572:	2410      	movs	r4, #16
    2574:	5ce3      	ldrb	r3, [r4, r3]
    2576:	75fb      	strb	r3, [r7, #23]
    2578:	e7d2      	b.n	2520 <_Z17DrawTrianglesLoopPhS_+0x7a8>
            e->rightTriangle = ti;
            e->leftTriangle = 0xFF;
        }
        else
        {
            e->leftTriangle = ti;
    257a:	ab0f      	add	r3, sp, #60
    257c:	781c      	ldrb	r4, [r3, #0]
    257e:	465b      	mov	r3, fp
    2580:	759c      	strb	r4, [r3, #22]
            e->rightTriangle = 0xFF;
    2582:	af09      	add	r7, sp, #36
    2584:	783f      	ldrb	r7, [r7, #0]
    2586:	75df      	strb	r7, [r3, #23]
    2588:	e657      	b.n	223a <_Z17DrawTrianglesLoopPhS_+0x4c2>
            e->rightTriangle = ti;
            e->leftTriangle = 0xFF;
        }
        else
        {
            e->leftTriangle = ti;
    258a:	ab0e      	add	r3, sp, #56
    258c:	781c      	ldrb	r4, [r3, #0]
    258e:	465b      	mov	r3, fp
    2590:	759c      	strb	r4, [r3, #22]
            e->rightTriangle = 0xFF;
    2592:	af09      	add	r7, sp, #36
    2594:	783f      	ldrb	r7, [r7, #0]
    2596:	75df      	strb	r7, [r3, #23]
    2598:	e6a7      	b.n	22ea <_Z17DrawTrianglesLoopPhS_+0x572>
            if (e->p0 == p0 && e->p1 == p1) // Share existing edge
            {
                if (left)
                    e->rightTriangle = ti;
                else
                    e->leftTriangle = ti;
    259a:	a80e      	add	r0, sp, #56
    259c:	7800      	ldrb	r0, [r0, #0]
    259e:	7590      	strb	r0, [r2, #22]
    25a0:	e54c      	b.n	203c <_Z17DrawTrianglesLoopPhS_+0x2c4>
    25a2:	a80f      	add	r0, sp, #60
    25a4:	7800      	ldrb	r0, [r0, #0]
    25a6:	7590      	strb	r0, [r2, #22]
    25a8:	e572      	b.n	2090 <_Z17DrawTrianglesLoopPhS_+0x318>
								{
									 byte color = _triangles[triangleIndex].fill & 0x0f;
									 *dst++ = run;
									 *dst++ = (color << 4) | _hackyColor;
									 if (_hacky == -1)
										 _hacky = y;
    25aa:	4643      	mov	r3, r8
    25ac:	60a3      	str	r3, [r4, #8]
    25ae:	e5e4      	b.n	217a <_Z17DrawTrianglesLoopPhS_+0x402>
		//_hacky = _y;
	}

	u8* DrawLoop(u8* runs)
	{
		if (_head.Next == &_tail && _newEdgeList == 0)
    25b0:	23f2      	movs	r3, #242
    25b2:	005b      	lsls	r3, r3, #1
    25b4:	58cb      	ldr	r3, [r1, r3]
    25b6:	2b00      	cmp	r3, #0
    25b8:	d001      	beq.n	25be <_Z17DrawTrianglesLoopPhS_+0x846>
    25ba:	f7ff fbee 	bl	1d9a <_Z17DrawTrianglesLoopPhS_+0x22>
        {
            if (_triangleIndex < _triangleCount)
    25be:	23b4      	movs	r3, #180
    25c0:	4a17      	ldr	r2, [pc, #92]	(2620 <_Z17DrawTrianglesLoopPhS_+0x8a8>)
    25c2:	009b      	lsls	r3, r3, #2
    25c4:	5c8a      	ldrb	r2, [r1, r2]
    25c6:	58cb      	ldr	r3, [r1, r3]
    25c8:	4293      	cmp	r3, r2
    25ca:	da24      	bge.n	2616 <_Z17DrawTrianglesLoopPhS_+0x89e>
            {
                _y = _nextY;
    25cc:	22b3      	movs	r2, #179
    25ce:	464c      	mov	r4, r9
    25d0:	0092      	lsls	r2, r2, #2
    25d2:	23b2      	movs	r3, #178
    25d4:	58a2      	ldr	r2, [r4, r2]
    25d6:	009b      	lsls	r3, r3, #2
    25d8:	50e2      	str	r2, [r4, r3]
    25da:	f7ff fbde 	bl	1d9a <_Z17DrawTrianglesLoopPhS_+0x22>
		        a = a->Next;
	        e->InsertAfter(a);  //  Insert into sorted active edgelist
        }
        
        _x = 0;
        if (_head.Next != &_tail)
    25de:	23b2      	movs	r3, #178
    25e0:	009b      	lsls	r3, r3, #2
    25e2:	58e3      	ldr	r3, [r4, r3]
    25e4:	931a      	str	r3, [sp, #104]
    25e6:	1c1a      	adds	r2, r3, #0
    25e8:	e58c      	b.n	2104 <_Z17DrawTrianglesLoopPhS_+0x38c>
                }
	        }
            curr = curr->Next;
	    }
		if (start == dst)
			start[0] = 0;
    25ea:	2300      	movs	r3, #0
    25ec:	700b      	strb	r3, [r1, #0]
    25ee:	e4e0      	b.n	1fb2 <_Z17DrawTrianglesLoopPhS_+0x23a>
							{
                                //DrawSpan(x0,x1,y,triangleIndex);
								if (start == dst)
								{
									dst++;			// count
									*dst++ = x0;	// left
    25f0:	466a      	mov	r2, sp
    25f2:	230c      	movs	r3, #12
    25f4:	5c9b      	ldrb	r3, [r3, r2]
    25f6:	9a08      	ldr	r2, [sp, #32]
    25f8:	7013      	strb	r3, [r2, #0]
    25fa:	9c07      	ldr	r4, [sp, #28]
									_x = x0;
    25fc:	466a      	mov	r2, sp
    25fe:	230c      	movs	r3, #12
							{
                                //DrawSpan(x0,x1,y,triangleIndex);
								if (start == dst)
								{
									dst++;			// count
									*dst++ = x0;	// left
    2600:	941b      	str	r4, [sp, #108]
									_x = x0;
    2602:	5a9c      	ldrh	r4, [r3, r2]
    2604:	23f4      	movs	r3, #244
    2606:	464a      	mov	r2, r9
    2608:	005b      	lsls	r3, r3, #1
    260a:	52d4      	strh	r4, [r2, r3]
    260c:	e59b      	b.n	2146 <_Z17DrawTrianglesLoopPhS_+0x3ce>
    
    //	Step and resort (good candidate for asm)
    void StepActive(int y)
    {
	    Edge* e,*e2,*next;
	    for (e = _head.Next; e != &_tail;)
    260e:	991b      	ldr	r1, [sp, #108]
    2610:	9a1a      	ldr	r2, [sp, #104]
    2612:	910d      	str	r1, [sp, #52]
    2614:	e576      	b.n	2104 <_Z17DrawTrianglesLoopPhS_+0x38c>

	u8* DrawLoop(u8* runs)
	{
		if (_head.Next == &_tail && _newEdgeList == 0)
        {
            if (_triangleIndex < _triangleCount)
    2616:	2200      	movs	r2, #0
    2618:	920d      	str	r2, [sp, #52]
    261a:	1c10      	adds	r0, r2, #0
    261c:	e578      	b.n	2110 <_Z17DrawTrianglesLoopPhS_+0x398>
    261e:	46c0      	nop			(mov r8, r8)
    2620:	0000022d 	.word	0x0000022d

00002624 <_Z7D3DLoopi>:
u8 _patternBlack[24] =
{
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};

int D3DLoop(int n)
    2624:	b5f0      	push	{r4, r5, r6, r7, lr}
    2626:	465f      	mov	r7, fp
    2628:	4656      	mov	r6, sl
    262a:	464d      	mov	r5, r9
    262c:	4644      	mov	r4, r8
    262e:	b4f0      	push	{r4, r5, r6, r7}
{
	_lasty = -1;
    2630:	4994      	ldr	r1, [pc, #592]	(2884 <_Z7D3DLoopi+0x260>)
    2632:	2301      	movs	r3, #1
    2634:	425b      	negs	r3, r3
    2636:	600b      	str	r3, [r1, #0]
	_read = _write = _lastWrite = 0;
	_counter++;
    2638:	690b      	ldr	r3, [r1, #16]
};

int D3DLoop(int n)
{
	_lasty = -1;
	_read = _write = _lastWrite = 0;
    263a:	2200      	movs	r2, #0
	_counter++;
    263c:	3301      	adds	r3, #1
    263e:	610b      	str	r3, [r1, #16]
	_vcounter += 6;
    2640:	694b      	ldr	r3, [r1, #20]
u8 _patternBlack[24] =
{
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};

int D3DLoop(int n)
    2642:	b08d      	sub	sp, #52
{
	_lasty = -1;
	_read = _write = _lastWrite = 0;
	_counter++;
	_vcounter += 6;
    2644:	3306      	adds	r3, #6
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};

int D3DLoop(int n)
{
	_lasty = -1;
    2646:	468b      	mov	fp, r1
	_read = _write = _lastWrite = 0;
    2648:	604a      	str	r2, [r1, #4]
    264a:	608a      	str	r2, [r1, #8]
    264c:	60ca      	str	r2, [r1, #12]
	_counter++;
	_vcounter += 6;
    264e:	614b      	str	r3, [r1, #20]
	if (_vcounter == 6*24)
    2650:	2b90      	cmp	r3, #144
    2652:	d100      	bne.n	2656 <_Z7D3DLoopi+0x32>
    2654:	e113      	b.n	287e <_Z7D3DLoopi+0x25a>
		_vcounter = 0;

	_hacky = -1;
    2656:	4e8c      	ldr	r6, [pc, #560]	(2888 <_Z7D3DLoopi+0x264>)
    2658:	2301      	movs	r3, #1
	DrawTriangles(0,_appBuffer,sizeof(_appBuffer));		// Start a new frame
    265a:	465c      	mov	r4, fp
	_counter++;
	_vcounter += 6;
	if (_vcounter == 6*24)
		_vcounter = 0;

	_hacky = -1;
    265c:	425b      	negs	r3, r3
	DrawTriangles(0,_appBuffer,sizeof(_appBuffer));		// Start a new frame
    265e:	3418      	adds	r4, #24
    2660:	22c8      	movs	r2, #200
    2662:	0092      	lsls	r2, r2, #2
	_counter++;
	_vcounter += 6;
	if (_vcounter == 6*24)
		_vcounter = 0;

	_hacky = -1;
    2664:	6033      	str	r3, [r6, #0]
	DrawTriangles(0,_appBuffer,sizeof(_appBuffer));		// Start a new frame
    2666:	2000      	movs	r0, #0
    2668:	1c21      	adds	r1, r4, #0
    266a:	f7fe fcd3 	bl	1014 <_Z13DrawTrianglesiPhi>
    266e:	4a87      	ldr	r2, [pc, #540]	(288c <_Z7D3DLoopi+0x268>)
    2670:	1c17      	adds	r7, r2, #0
    2672:	3738      	adds	r7, #56
    2674:	4691      	mov	r9, r2
    2676:	1c3d      	adds	r5, r7, #0
	u8* write = _runs;
	u8* w = write;

	while (VideoOutLine() >= 22)		// finishing last frame
    2678:	f7fd fd80 	bl	17c <VideoOutLine>
    267c:	2815      	cmp	r0, #21
    267e:	dd0b      	ble.n	2698 <_Z7D3DLoopi+0x74>
	{
		w = DrawTrianglesLoop(_appBuffer,write);	// Get ahead
    2680:	1c20      	adds	r0, r4, #0
    2682:	1c39      	adds	r1, r7, #0
    2684:	f7ff fb78 	bl	1d78 <_Z17DrawTrianglesLoopPhS_>
    2688:	1c05      	adds	r5, r0, #0
		if (w)
    268a:	2800      	cmp	r0, #0
    268c:	d0f4      	beq.n	2678 <_Z7D3DLoopi+0x54>
    268e:	1c07      	adds	r7, r0, #0
	_hacky = -1;
	DrawTriangles(0,_appBuffer,sizeof(_appBuffer));		// Start a new frame
	u8* write = _runs;
	u8* w = write;

	while (VideoOutLine() >= 22)		// finishing last frame
    2690:	f7fd fd74 	bl	17c <VideoOutLine>
    2694:	2815      	cmp	r0, #21
    2696:	dcf3      	bgt.n	2680 <_Z7D3DLoopi+0x5c>
	}

	//	Start a new frame
	//
	int line;
	int geoTop = _hacky;		// First y of geometric figure
    2698:	6836      	ldr	r6, [r6, #0]
					__WFI();
				y = geoTop;
				break;
			}
		}
		w = DrawTrianglesLoop(_appBuffer,write);	// Get ahead
    269a:	2318      	movs	r3, #24
    269c:	4698      	mov	r8, r3
	}

	//	Start a new frame
	//
	int line;
	int geoTop = _hacky;		// First y of geometric figure
    269e:	9603      	str	r6, [sp, #12]
					__WFI();
				y = geoTop;
				break;
			}
		}
		w = DrawTrianglesLoop(_appBuffer,write);	// Get ahead
    26a0:	44d8      	add	r8, fp
			if (line > (bgTop+22))			// Hit bg first
			{
				y = bgTop;
				break;
			}
			else if (line > (geoTop+22))	// Hit geometry first
    26a2:	3616      	adds	r6, #22
	int bgBottom = 240-bgTop;	// Last y of bg
	int y = 255;				// current y

	for (;;)
	{
		line = VideoOutLine();
    26a4:	f7fd fd6a 	bl	17c <VideoOutLine>
    26a8:	1c04      	adds	r4, r0, #0
		if (y == 255)
		{
			if (line > (bgTop+22))			// Hit bg first
    26aa:	284e      	cmp	r0, #78
    26ac:	dc0f      	bgt.n	26ce <_Z7D3DLoopi+0xaa>
			{
				y = bgTop;
				break;
			}
			else if (line > (geoTop+22))	// Hit geometry first
    26ae:	42b0      	cmp	r0, r6
    26b0:	dd00      	ble.n	26b4 <_Z7D3DLoopi+0x90>
    26b2:	e099      	b.n	27e8 <_Z7D3DLoopi+0x1c4>
					__WFI();
				y = geoTop;
				break;
			}
		}
		w = DrawTrianglesLoop(_appBuffer,write);	// Get ahead
    26b4:	4640      	mov	r0, r8
    26b6:	1c39      	adds	r1, r7, #0
    26b8:	f7ff fb5e 	bl	1d78 <_Z17DrawTrianglesLoopPhS_>
    26bc:	1c05      	adds	r5, r0, #0
		if (w)
    26be:	2800      	cmp	r0, #0
    26c0:	d0f0      	beq.n	26a4 <_Z7D3DLoopi+0x80>
    26c2:	1c07      	adds	r7, r0, #0
	int bgBottom = 240-bgTop;	// Last y of bg
	int y = 255;				// current y

	for (;;)
	{
		line = VideoOutLine();
    26c4:	f7fd fd5a 	bl	17c <VideoOutLine>
    26c8:	1c04      	adds	r4, r0, #0
		if (y == 255)
		{
			if (line > (bgTop+22))			// Hit bg first
    26ca:	284e      	cmp	r0, #78
    26cc:	ddef      	ble.n	26ae <_Z7D3DLoopi+0x8a>
				y = geoTop;
				break;
			}
		}
		w = DrawTrianglesLoop(_appBuffer,write);	// Get ahead
		if (w)
    26ce:	2638      	movs	r6, #56
			write = w;
	}

	u8* read = _runs;	// count,left,runs
	u32 v = _vcounter;
    26d0:	465c      	mov	r4, fp
    26d2:	2377      	movs	r3, #119
    26d4:	1b9b      	subs	r3, r3, r6
    26d6:	6964      	ldr	r4, [r4, #20]
    26d8:	2138      	movs	r1, #56
    26da:	4a6d      	ldr	r2, [pc, #436]	(2890 <_Z7D3DLoopi+0x26c>)
    26dc:	9305      	str	r3, [sp, #20]
    26de:	468a      	mov	sl, r1
					if (c > 255)
						c = 255;
				}
				c &= 0xF8;
				c |= cr;
				pattern = (u8*)p;
    26e0:	ab06      	add	r3, sp, #24
		if (w)
			write = w;
	}

	u8* read = _runs;	// count,left,runs
	u32 v = _vcounter;
    26e2:	9404      	str	r4, [sp, #16]
    26e4:	44ca      	add	sl, r9
    26e6:	9202      	str	r2, [sp, #8]
					if (c > 255)
						c = 255;
				}
				c &= 0xF8;
				c |= cr;
				pattern = (u8*)p;
    26e8:	4698      	mov	r8, r3
    26ea:	e027      	b.n	273c <_Z7D3DLoopi+0x118>
				c |= c<<16;
				p[0] = p[1] = p[2] = p[3]  = p[4] = p[5]= c;
			}
			_fillLine(dst,pattern,12);
		} else
			_fillLine(dst,_patternBlack,12);
    26ec:	9c02      	ldr	r4, [sp, #8]
    26ee:	4648      	mov	r0, r9
    26f0:	6ba3      	ldr	r3, [r4, #56]
    26f2:	4968      	ldr	r1, [pc, #416]	(2894 <_Z7D3DLoopi+0x270>)
    26f4:	220c      	movs	r2, #12
    26f6:	4798      	blx	r3

		if (y > geoTop)
    26f8:	9903      	ldr	r1, [sp, #12]
    26fa:	428e      	cmp	r6, r1
    26fc:	dd0b      	ble.n	2716 <_Z7D3DLoopi+0xf2>
		{
			if (read < write)
    26fe:	4557      	cmp	r7, sl
    2700:	d909      	bls.n	2716 <_Z7D3DLoopi+0xf2>
			{
				u8 left = read[1];
    2702:	4652      	mov	r2, sl
    2704:	7853      	ldrb	r3, [r2, #1]
				u8 count = read[0];
    2706:	7812      	ldrb	r2, [r2, #0]
				if (count)
    2708:	2a00      	cmp	r2, #0
    270a:	d000      	beq.n	270e <_Z7D3DLoopi+0xea>
    270c:	e0a6      	b.n	285c <_Z7D3DLoopi+0x238>
    270e:	2400      	movs	r4, #0
					_fillRuns(dst+left,read+2,count);
				read += 2 + (count<<1);
    2710:	0063      	lsls	r3, r4, #1
    2712:	3302      	adds	r3, #2
    2714:	449a      	add	sl, r3
			}
		}
		LineBufferEnqueue(dst);
    2716:	4648      	mov	r0, r9
    2718:	f000 f9b0 	bl	2a7c <_Z17LineBufferEnqueuePh>
		y++;
    271c:	3601      	adds	r6, #1

		if (w)
    271e:	2d00      	cmp	r5, #0
    2720:	d100      	bne.n	2724 <_Z7D3DLoopi+0x100>
    2722:	e082      	b.n	282a <_Z7D3DLoopi+0x206>
		{
			w = DrawTrianglesLoop(_appBuffer,write);	// read more
    2724:	4658      	mov	r0, fp
    2726:	3018      	adds	r0, #24
    2728:	1c39      	adds	r1, r7, #0
    272a:	f7ff fb25 	bl	1d78 <_Z17DrawTrianglesLoopPhS_>
    272e:	1c05      	adds	r5, r0, #0
			if (!w)
    2730:	2800      	cmp	r0, #0
    2732:	d07e      	beq.n	2832 <_Z7D3DLoopi+0x20e>
		if (w)
			write = w;
	}

	u8* read = _runs;	// count,left,runs
	u32 v = _vcounter;
    2734:	1c2f      	adds	r7, r5, #0
    2736:	9c05      	ldr	r4, [sp, #20]
    2738:	3c01      	subs	r4, #1
    273a:	9405      	str	r4, [sp, #20]
	for (;;)
	{
		u8* dst = LineBufferGet();
    273c:	f000 f8e6 	bl	290c <_Z13LineBufferGetv>
    2740:	4681      	mov	r9, r0
		bool bg = y >= bgTop && y < bgBottom;
		if (bg)
    2742:	2e37      	cmp	r6, #55
    2744:	ddd2      	ble.n	26ec <_Z7D3DLoopi+0xc8>
    2746:	2eb7      	cmp	r6, #183
    2748:	dcd0      	bgt.n	26ec <_Z7D3DLoopi+0xc8>
    274a:	1c32      	adds	r2, r6, #0
    274c:	3a38      	subs	r2, #56
		{
			int c;
			line = y-bgTop;
			u32 p[6];
			u8* pattern;
			if (line < 64)
    274e:	2a3f      	cmp	r2, #63
    2750:	dc50      	bgt.n	27f4 <_Z7D3DLoopi+0x1d0>
			{
				// sky
				u32 color = ((_counter + line) >> 7) & 0x7;
    2752:	4659      	mov	r1, fp
    2754:	690b      	ldr	r3, [r1, #16]
				color |= color << 8;
				color |= color << 16;
				u32 add = (63-line)<<1;
				add |= add << 8;
				add |= add << 16;
				u32* src = (u32*)voronoidark + v;
    2756:	9c04      	ldr	r4, [sp, #16]
			u32 p[6];
			u8* pattern;
			if (line < 64)
			{
				// sky
				u32 color = ((_counter + line) >> 7) & 0x7;
    2758:	18d3      	adds	r3, r2, r3
    275a:	059b      	lsls	r3, r3, #22
    275c:	0f5b      	lsrs	r3, r3, #29
				color |= color << 8;
    275e:	021a      	lsls	r2, r3, #8
    2760:	431a      	orrs	r2, r3
				color |= color << 16;
				u32 add = (63-line)<<1;
    2762:	9b05      	ldr	r3, [sp, #20]
			if (line < 64)
			{
				// sky
				u32 color = ((_counter + line) >> 7) & 0x7;
				color |= color << 8;
				color |= color << 16;
    2764:	0410      	lsls	r0, r2, #16
    2766:	4310      	orrs	r0, r2
				u32 add = (63-line)<<1;
    2768:	005a      	lsls	r2, r3, #1
				add |= add << 8;
    276a:	025b      	lsls	r3, r3, #9
    276c:	4313      	orrs	r3, r2
				add |= add << 16;
    276e:	041a      	lsls	r2, r3, #16
				u32* src = (u32*)voronoidark + v;
    2770:	4949      	ldr	r1, [pc, #292]	(2898 <_Z7D3DLoopi+0x274>)
				u32 color = ((_counter + line) >> 7) & 0x7;
				color |= color << 8;
				color |= color << 16;
				u32 add = (63-line)<<1;
				add |= add << 8;
				add |= add << 16;
    2772:	431a      	orrs	r2, r3
				u32* src = (u32*)voronoidark + v;
    2774:	00a3      	lsls	r3, r4, #2
    2776:	18c9      	adds	r1, r1, r3
				//src += v;
				u32 mask = 0xF8F8F8F8;
				p[0] = ((src[0] + add) & mask) | color;
    2778:	680b      	ldr	r3, [r1, #0]
    277a:	4c48      	ldr	r4, [pc, #288]	(289c <_Z7D3DLoopi+0x278>)
    277c:	18d3      	adds	r3, r2, r3
    277e:	4023      	ands	r3, r4
				u32 color = ((_counter + line) >> 7) & 0x7;
				color |= color << 8;
				color |= color << 16;
				u32 add = (63-line)<<1;
				add |= add << 8;
				add |= add << 16;
    2780:	9201      	str	r2, [sp, #4]
				u32* src = (u32*)voronoidark + v;
				//src += v;
				u32 mask = 0xF8F8F8F8;
				p[0] = ((src[0] + add) & mask) | color;
    2782:	4303      	orrs	r3, r0
    2784:	4642      	mov	r2, r8
    2786:	6013      	str	r3, [r2, #0]
				p[1] = ((src[1] + add) & mask) | color;
    2788:	684b      	ldr	r3, [r1, #4]
    278a:	9a01      	ldr	r2, [sp, #4]
    278c:	18d3      	adds	r3, r2, r3
    278e:	4023      	ands	r3, r4
    2790:	4303      	orrs	r3, r0
    2792:	4642      	mov	r2, r8
    2794:	6053      	str	r3, [r2, #4]
				p[2] = ((src[2] + add) & mask) | color;
    2796:	688b      	ldr	r3, [r1, #8]
    2798:	9a01      	ldr	r2, [sp, #4]
    279a:	18d3      	adds	r3, r2, r3
    279c:	4023      	ands	r3, r4
    279e:	4303      	orrs	r3, r0
    27a0:	4642      	mov	r2, r8
    27a2:	6093      	str	r3, [r2, #8]
				p[3] = ((src[3] + add) & mask) | color;
    27a4:	68cb      	ldr	r3, [r1, #12]
    27a6:	9a01      	ldr	r2, [sp, #4]
    27a8:	18d3      	adds	r3, r2, r3
    27aa:	4023      	ands	r3, r4
    27ac:	4303      	orrs	r3, r0
    27ae:	4642      	mov	r2, r8
    27b0:	60d3      	str	r3, [r2, #12]
				p[4] = ((src[4] + add) & mask) | color;
    27b2:	690b      	ldr	r3, [r1, #16]
    27b4:	9a01      	ldr	r2, [sp, #4]
    27b6:	18d3      	adds	r3, r2, r3
    27b8:	4023      	ands	r3, r4
    27ba:	4303      	orrs	r3, r0
    27bc:	4642      	mov	r2, r8
    27be:	6113      	str	r3, [r2, #16]
				p[5] = ((src[5] + add) & mask) | color;
    27c0:	694b      	ldr	r3, [r1, #20]
    27c2:	9901      	ldr	r1, [sp, #4]
    27c4:	18ca      	adds	r2, r1, r3
				pattern = (u8*)p;
				v += 6;
    27c6:	9b04      	ldr	r3, [sp, #16]
				p[0] = ((src[0] + add) & mask) | color;
				p[1] = ((src[1] + add) & mask) | color;
				p[2] = ((src[2] + add) & mask) | color;
				p[3] = ((src[3] + add) & mask) | color;
				p[4] = ((src[4] + add) & mask) | color;
				p[5] = ((src[5] + add) & mask) | color;
    27c8:	4022      	ands	r2, r4
    27ca:	4310      	orrs	r0, r2
				pattern = (u8*)p;
				v += 6;
    27cc:	3306      	adds	r3, #6
				p[0] = ((src[0] + add) & mask) | color;
				p[1] = ((src[1] + add) & mask) | color;
				p[2] = ((src[2] + add) & mask) | color;
				p[3] = ((src[3] + add) & mask) | color;
				p[4] = ((src[4] + add) & mask) | color;
				p[5] = ((src[5] + add) & mask) | color;
    27ce:	4642      	mov	r2, r8
    27d0:	6150      	str	r0, [r2, #20]
				pattern = (u8*)p;
    27d2:	4641      	mov	r1, r8
				v += 6;
    27d4:	9304      	str	r3, [sp, #16]
				if (v == 6*24)
    27d6:	2b90      	cmp	r3, #144
    27d8:	d033      	beq.n	2842 <_Z7D3DLoopi+0x21e>
				pattern = (u8*)p;
				c |= c<<8;
				c |= c<<16;
				p[0] = p[1] = p[2] = p[3]  = p[4] = p[5]= c;
			}
			_fillLine(dst,pattern,12);
    27da:	9a02      	ldr	r2, [sp, #8]
    27dc:	4648      	mov	r0, r9
    27de:	6b93      	ldr	r3, [r2, #56]
    27e0:	220c      	movs	r2, #12
    27e2:	4798      	blx	r3
    27e4:	e788      	b.n	26f8 <_Z7D3DLoopi+0xd4>

static __INLINE void __enable_fault_irq()         { __ASM volatile ("cpsie f"); }
static __INLINE void __disable_fault_irq()        { __ASM volatile ("cpsid f"); }

static __INLINE void __NOP()                      { __ASM volatile ("nop"); }
static __INLINE void __WFI()                      { __ASM volatile ("wfi"); }
    27e6:	bf30      	wfi
				y = bgTop;
				break;
			}
			else if (line > (geoTop+22))	// Hit geometry first
			{
				while (line == VideoOutLine())
    27e8:	f7fd fcc8 	bl	17c <VideoOutLine>
    27ec:	4284      	cmp	r4, r0
    27ee:	d0fa      	beq.n	27e6 <_Z7D3DLoopi+0x1c2>
    27f0:	9e03      	ldr	r6, [sp, #12]
    27f2:	e76d      	b.n	26d0 <_Z7D3DLoopi+0xac>
			}
			else
			{
				//	Ground animation
				line &= 0x3F;
				c = ramp[line];
    27f4:	492a      	ldr	r1, [pc, #168]	(28a0 <_Z7D3DLoopi+0x27c>)
					v = 0;
			}
			else
			{
				//	Ground animation
				line &= 0x3F;
    27f6:	203f      	movs	r0, #63
				c = ramp[line];
				int r = _counter - c;
    27f8:	465b      	mov	r3, fp
					v = 0;
			}
			else
			{
				//	Ground animation
				line &= 0x3F;
    27fa:	4010      	ands	r0, r2
				c = ramp[line];
    27fc:	5c0a      	ldrb	r2, [r1, r0]
				int r = _counter - c;
    27fe:	6919      	ldr	r1, [r3, #16]
				u8 cr = 0;
				if ((r & 0x30) == 0x30)
    2800:	2430      	movs	r4, #48
    2802:	1a8b      	subs	r3, r1, r2
    2804:	4023      	ands	r3, r4
    2806:	2b30      	cmp	r3, #48
    2808:	d01e      	beq.n	2848 <_Z7D3DLoopi+0x224>
    280a:	21f8      	movs	r1, #248
    280c:	400a      	ands	r2, r1
    280e:	2300      	movs	r3, #0
					c += c>>1;
					if (c > 255)
						c = 255;
				}
				c &= 0xF8;
				c |= cr;
    2810:	4313      	orrs	r3, r2
				pattern = (u8*)p;
				c |= c<<8;
    2812:	021a      	lsls	r2, r3, #8
    2814:	431a      	orrs	r2, r3
				c |= c<<16;
    2816:	0413      	lsls	r3, r2, #16
					if (c > 255)
						c = 255;
				}
				c &= 0xF8;
				c |= cr;
				pattern = (u8*)p;
    2818:	4641      	mov	r1, r8
				c |= c<<8;
				c |= c<<16;
				p[0] = p[1] = p[2] = p[3]  = p[4] = p[5]= c;
    281a:	4313      	orrs	r3, r2
    281c:	614b      	str	r3, [r1, #20]
    281e:	610b      	str	r3, [r1, #16]
    2820:	60cb      	str	r3, [r1, #12]
    2822:	608b      	str	r3, [r1, #8]
    2824:	604b      	str	r3, [r1, #4]
    2826:	600b      	str	r3, [r1, #0]
    2828:	e7d7      	b.n	27da <_Z7D3DLoopi+0x1b6>
			if (!w)
				break;
			write = w;
		}

		if (!w && y >= bgBottom && read == write)
    282a:	2eb7      	cmp	r6, #183
    282c:	dd83      	ble.n	2736 <_Z7D3DLoopi+0x112>
    282e:	4557      	cmp	r7, sl
    2830:	d181      	bne.n	2736 <_Z7D3DLoopi+0x112>
			break;
	}
	return 0;
}
    2832:	b00d      	add	sp, #52
    2834:	2000      	movs	r0, #0
    2836:	bc3c      	pop	{r2, r3, r4, r5}
    2838:	4690      	mov	r8, r2
    283a:	4699      	mov	r9, r3
    283c:	46a2      	mov	sl, r4
    283e:	46ab      	mov	fp, r5
    2840:	bdf0      	pop	{r4, r5, r6, r7, pc}
				p[3] = ((src[3] + add) & mask) | color;
				p[4] = ((src[4] + add) & mask) | color;
				p[5] = ((src[5] + add) & mask) | color;
				pattern = (u8*)p;
				v += 6;
				if (v == 6*24)
    2842:	2400      	movs	r4, #0
    2844:	9404      	str	r4, [sp, #16]
    2846:	e7c8      	b.n	27da <_Z7D3DLoopi+0x1b6>
				c = ramp[line];
				int r = _counter - c;
				u8 cr = 0;
				if ((r & 0x30) == 0x30)
				{
					if (line > 4)
    2848:	2804      	cmp	r0, #4
    284a:	dc15      	bgt.n	2878 <_Z7D3DLoopi+0x254>
    284c:	2100      	movs	r1, #0
						cr = (_counter >> 8) & 7;
					c += c>>1;
    284e:	1053      	asrs	r3, r2, #1
    2850:	189b      	adds	r3, r3, r2
					if (c > 255)
    2852:	2bff      	cmp	r3, #255
    2854:	dd0c      	ble.n	2870 <_Z7D3DLoopi+0x24c>
    2856:	1c0b      	adds	r3, r1, #0
    2858:	22f8      	movs	r2, #248
    285a:	e7d9      	b.n	2810 <_Z7D3DLoopi+0x1ec>
			if (read < write)
			{
				u8 left = read[1];
				u8 count = read[0];
				if (count)
					_fillRuns(dst+left,read+2,count);
    285c:	1c14      	adds	r4, r2, #0
    285e:	4649      	mov	r1, r9
    2860:	9a02      	ldr	r2, [sp, #8]
    2862:	18c8      	adds	r0, r1, r3
    2864:	4651      	mov	r1, sl
    2866:	6d53      	ldr	r3, [r2, #84]
    2868:	3102      	adds	r1, #2
    286a:	1c22      	adds	r2, r4, #0
    286c:	4798      	blx	r3
    286e:	e74f      	b.n	2710 <_Z7D3DLoopi+0xec>
				if ((r & 0x30) == 0x30)
				{
					if (line > 4)
						cr = (_counter >> 8) & 7;
					c += c>>1;
					if (c > 255)
    2870:	22f8      	movs	r2, #248
    2872:	401a      	ands	r2, r3
    2874:	1c0b      	adds	r3, r1, #0
    2876:	e7cb      	b.n	2810 <_Z7D3DLoopi+0x1ec>
				int r = _counter - c;
				u8 cr = 0;
				if ((r & 0x30) == 0x30)
				{
					if (line > 4)
						cr = (_counter >> 8) & 7;
    2878:	054b      	lsls	r3, r1, #21
    287a:	0f59      	lsrs	r1, r3, #29
    287c:	e7e7      	b.n	284e <_Z7D3DLoopi+0x22a>
	_lasty = -1;
	_read = _write = _lastWrite = 0;
	_counter++;
	_vcounter += 6;
	if (_vcounter == 6*24)
		_vcounter = 0;
    287e:	614a      	str	r2, [r1, #20]
    2880:	e6e9      	b.n	2656 <_Z7D3DLoopi+0x32>
    2882:	46c0      	nop			(mov r8, r8)
    2884:	10000488 	.word	0x10000488
    2888:	10000484 	.word	0x10000484
    288c:	10000788 	.word	0x10000788
    2890:	10000f88 	.word	0x10000f88
    2894:	10000fc4 	.word	0x10000fc4
    2898:	100001ec 	.word	0x100001ec
    289c:	f8f8f8f8 	.word	0xf8f8f8f8
    28a0:	1000042c 	.word	0x1000042c

000028a4 <_Z7D3DInitv>:
	0xB8,0xBB,0xBD,0xC0,0xC2,0xC4,0xC6,0xC8,0xC9,0xCB,0xCC,0xCD,0xCE,0xD0,0xD1,0xD2,
	0xD2,0xD3,0xD4,0xD5,0xD6,0xD6,0xD7,0xD8,0xD8,0xD9,0xD9,0xDA,0xDA,0xDB,0xDB,0xDC,
	0xDC,0xDC,0xDD,0xDD,0xDD,0xDE,0xDE,0xDE,0xDF,0xDF,0xDF,0xDF,0xE0,0xE0,0xE0,0xE0,
};

void D3DInit()
    28a4:	b510      	push	{r4, lr}
{
	//Set();
	VideoOutInit(40*8);	//
    28a6:	20a0      	movs	r0, #160
    28a8:	0040      	lsls	r0, r0, #1
    28aa:	f7fd fdb7 	bl	41c <VideoOutInit>
	LineBufferInit();
    28ae:	f000 f823 	bl	28f8 <_Z14LineBufferInitv>
	_fillRuns = (FillRunsProc)CopyProcToRam((void*)FillRuns,_fillRunsBuffer,sizeof(_fillRunsBuffer));
    28b2:	4c0c      	ldr	r4, [pc, #48]	(28e4 <_Z7D3DInitv+0x40>)
    28b4:	2280      	movs	r2, #128
    28b6:	1c21      	adds	r1, r4, #0
    28b8:	3158      	adds	r1, #88
    28ba:	0052      	lsls	r2, r2, #1
    28bc:	480a      	ldr	r0, [pc, #40]	(28e8 <_Z7D3DInitv+0x44>)
    28be:	f000 f8d1 	bl	2a64 <_Z13CopyProcToRamPvPhi>
	_fillLine = (FillLineProc)CopyProcToRam((void*)FillLine24,_fillLineBuffer,sizeof(_fillLineBuffer));
    28c2:	490a      	ldr	r1, [pc, #40]	(28ec <_Z7D3DInitv+0x48>)
void D3DInit()
{
	//Set();
	VideoOutInit(40*8);	//
	LineBufferInit();
	_fillRuns = (FillRunsProc)CopyProcToRam((void*)FillRuns,_fillRunsBuffer,sizeof(_fillRunsBuffer));
    28c4:	6560      	str	r0, [r4, #84]
	_fillLine = (FillLineProc)CopyProcToRam((void*)FillLine24,_fillLineBuffer,sizeof(_fillLineBuffer));
    28c6:	3158      	adds	r1, #88
    28c8:	2250      	movs	r2, #80
    28ca:	4809      	ldr	r0, [pc, #36]	(28f0 <_Z7D3DInitv+0x4c>)
    28cc:	f000 f8ca 	bl	2a64 <_Z13CopyProcToRamPvPhi>
	DrawTriangles(0x80,_appBuffer,sizeof(_appBuffer));
    28d0:	4908      	ldr	r1, [pc, #32]	(28f4 <_Z7D3DInitv+0x50>)
    28d2:	22c8      	movs	r2, #200
{
	//Set();
	VideoOutInit(40*8);	//
	LineBufferInit();
	_fillRuns = (FillRunsProc)CopyProcToRam((void*)FillRuns,_fillRunsBuffer,sizeof(_fillRunsBuffer));
	_fillLine = (FillLineProc)CopyProcToRam((void*)FillLine24,_fillLineBuffer,sizeof(_fillLineBuffer));
    28d4:	63a0      	str	r0, [r4, #56]
	DrawTriangles(0x80,_appBuffer,sizeof(_appBuffer));
    28d6:	3118      	adds	r1, #24
    28d8:	0092      	lsls	r2, r2, #2
    28da:	2080      	movs	r0, #128
    28dc:	f7fe fb9a 	bl	1014 <_Z13DrawTrianglesiPhi>
}
    28e0:	bd10      	pop	{r4, pc}
    28e2:	46c0      	nop			(mov r8, r8)
    28e4:	10000f88 	.word	0x10000f88
    28e8:	0000297d 	.word	0x0000297d
    28ec:	10001088 	.word	0x10001088
    28f0:	00002949 	.word	0x00002949
    28f4:	10000488 	.word	0x10000488

000028f8 <_Z14LineBufferInitv>:

LineBuffer gLineBuffer;

void LineBufferInit()
{
	gLineBuffer.LineIndex = 0;
    28f8:	4a03      	ldr	r2, [pc, #12]	(2908 <_Z14LineBufferInitv+0x10>)
    28fa:	2300      	movs	r3, #0
	for (int i = 0; i < LINE_BUFFER_COUNT; i++)
		gLineBuffer.Lines[i] = 0;
    28fc:	6053      	str	r3, [r2, #4]

LineBuffer gLineBuffer;

void LineBufferInit()
{
	gLineBuffer.LineIndex = 0;
    28fe:	6013      	str	r3, [r2, #0]
	for (int i = 0; i < LINE_BUFFER_COUNT; i++)
		gLineBuffer.Lines[i] = 0;
    2900:	6093      	str	r3, [r2, #8]
    2902:	60d3      	str	r3, [r2, #12]
    2904:	6113      	str	r3, [r2, #16]
}
    2906:	4770      	bx	lr
    2908:	10001138 	.word	0x10001138

0000290c <_Z13LineBufferGetv>:
bool LineBufferBusy()
{
	return gLineBuffer.Lines[gLineBuffer.LineIndex & (LINE_BUFFER_COUNT-1)] != 0;
}

u8*	LineBufferGet()
    290c:	b530      	push	{r4, r5, lr}
{
	int i = gLineBuffer.LineIndex & (LINE_BUFFER_COUNT-1);
    290e:	4c0b      	ldr	r4, [pc, #44]	(293c <_Z13LineBufferGetv+0x30>)
    2910:	2303      	movs	r3, #3
    2912:	1c22      	adds	r2, r4, #0
    2914:	ca02      	ldmia	r2!, {r1}
    2916:	1c0d      	adds	r5, r1, #0
    2918:	401d      	ands	r5, r3
	volatile u8* volatile* line = gLineBuffer.Lines + i;
    291a:	00a9      	lsls	r1, r5, #2
    291c:	1852      	adds	r2, r2, r1
	while (*line)
    291e:	6813      	ldr	r3, [r2, #0]
    2920:	2b00      	cmp	r3, #0
    2922:	d003      	beq.n	292c <_Z13LineBufferGetv+0x20>
    2924:	bf30      	wfi
    2926:	6813      	ldr	r3, [r2, #0]
    2928:	2b00      	cmp	r3, #0
    292a:	d1fb      	bne.n	2924 <_Z13LineBufferGetv+0x18>
		__WFI();
	u8* dst = gLineBuffer.Buffer + i*LINE_BUFFER_WIDTH;
    292c:	194b      	adds	r3, r1, r5
    292e:	1c20      	adds	r0, r4, #0
    2930:	019b      	lsls	r3, r3, #6
    2932:	3014      	adds	r0, #20
    2934:	18c0      	adds	r0, r0, r3
	gLineBuffer.Lines[i] = dst;
    2936:	1863      	adds	r3, r4, r1
    2938:	6058      	str	r0, [r3, #4]
	return dst;
}
    293a:	bd30      	pop	{r4, r5, pc}
    293c:	10001138 	.word	0x10001138

00002940 <__aeabi_unwind_cpp_pr0>:

#ifndef _WIN32

extern "C"
{
void __aeabi_unwind_cpp_pr0(){};
    2940:	4770      	bx	lr
    2942:	46c0      	nop			(mov r8, r8)

00002944 <__aeabi_unwind_cpp_pr1>:
void __aeabi_unwind_cpp_pr1(){};
    2944:	4770      	bx	lr
    2946:	46c0      	nop			(mov r8, r8)

00002948 <FillLine24>:
		);
}


extern "C"
void FillLine24(u8* dst, u8* pattern, int count)
    2948:	b570      	push	{r4, r5, r6, lr}
    294a:	4646      	mov	r6, r8
    294c:	b440      	push	{r6}
    294e:	4680      	mov	r8, r0
    2950:	468c      	mov	ip, r1
		"	pop		{r7}\n"
			".syntax divided\n"
			:
			: [dst] "r" (dst),[pattern] "r" (pattern)
			: "r0","r1","r2","r3","r4","r5","r6"
		);
    2952:	4640      	mov	r0, r8
    2954:	4661      	mov	r1, ip
    2956:	b480      	push	{r7}
    2958:	c9fc      	ldmia	r1!, {r2, r3, r4, r5, r6, r7}
    295a:	c0fc      	stmia	r0!, {r2, r3, r4, r5, r6, r7}
    295c:	c0fc      	stmia	r0!, {r2, r3, r4, r5, r6, r7}
    295e:	c0fc      	stmia	r0!, {r2, r3, r4, r5, r6, r7}
    2960:	c0fc      	stmia	r0!, {r2, r3, r4, r5, r6, r7}
    2962:	c0fc      	stmia	r0!, {r2, r3, r4, r5, r6, r7}
    2964:	c0fc      	stmia	r0!, {r2, r3, r4, r5, r6, r7}
    2966:	c0fc      	stmia	r0!, {r2, r3, r4, r5, r6, r7}
    2968:	c0fc      	stmia	r0!, {r2, r3, r4, r5, r6, r7}
    296a:	c0fc      	stmia	r0!, {r2, r3, r4, r5, r6, r7}
    296c:	c0fc      	stmia	r0!, {r2, r3, r4, r5, r6, r7}
    296e:	c0fc      	stmia	r0!, {r2, r3, r4, r5, r6, r7}
    2970:	c0fc      	stmia	r0!, {r2, r3, r4, r5, r6, r7}
    2972:	bc80      	pop	{r7}
}
    2974:	bc04      	pop	{r2}
    2976:	4690      	mov	r8, r2
    2978:	bd70      	pop	{r4, r5, r6, pc}
    297a:	46c0      	nop			(mov r8, r8)

0000297c <FillRuns>:

extern "C"
void FillRuns(u8* dst, u8* runs, int count)
    297c:	b570      	push	{r4, r5, r6, lr}
    297e:	1c06      	adds	r6, r0, #0
    2980:	1c0d      	adds	r5, r1, #0
    2982:	1c14      	adds	r4, r2, #0
			"	mov	r8,r3\n"
		".syntax divided\n"
		:
		: [dst] "r" (dst),[runs] "r" (runs),[count] "r" (count)
		: "r0","r1","r2","r3"
	);
    2984:	4643      	mov	r3, r8
    2986:	b4f8      	push	{r3, r4, r5, r6, r7}
    2988:	4630      	mov	r0, r6
    298a:	462f      	mov	r7, r5
    298c:	46a0      	mov	r8, r4
    298e:	44c0      	add	r8, r8
    2990:	44b8      	add	r8, r7
    2992:	7879      	ldrb	r1, [r7, #1]
    2994:	783b      	ldrb	r3, [r7, #0]
    2996:	18c2      	adds	r2, r0, r3
    2998:	2b04      	cmp	r3, #4
    299a:	db3b      	blt.n	2a14 <FillRuns+0x98>
    299c:	2303      	movs	r3, #3
    299e:	4003      	ands	r3, r0
    29a0:	d009      	beq.n	29b6 <FillRuns+0x3a>
    29a2:	1c05      	adds	r5, r0, #0
    29a4:	3004      	adds	r0, #4
    29a6:	1ac0      	subs	r0, r0, r3
    29a8:	005b      	lsls	r3, r3, #1
    29aa:	449f      	add	pc, r3
    29ac:	46c0      	nop			(mov r8, r8)
    29ae:	46c0      	nop			(mov r8, r8)
    29b0:	70a9      	strb	r1, [r5, #2]
    29b2:	7069      	strb	r1, [r5, #1]
    29b4:	7029      	strb	r1, [r5, #0]
    29b6:	020c      	lsls	r4, r1, #8
    29b8:	1861      	adds	r1, r4, r1
    29ba:	040c      	lsls	r4, r1, #16
    29bc:	1909      	adds	r1, r1, r4
    29be:	1a14      	subs	r4, r2, r0
    29c0:	0924      	lsrs	r4, r4, #4
    29c2:	d01b      	beq.n	29fc <FillRuns+0x80>
    29c4:	2314      	movs	r3, #20
    29c6:	1b1b      	subs	r3, r3, r4
    29c8:	1c0c      	adds	r4, r1, #0
    29ca:	1c0d      	adds	r5, r1, #0
    29cc:	1c0e      	adds	r6, r1, #0
    29ce:	005b      	lsls	r3, r3, #1
    29d0:	449f      	add	pc, r3
    29d2:	46c0      	nop			(mov r8, r8)
    29d4:	c072      	stmia	r0!, {r1, r4, r5, r6}
    29d6:	c072      	stmia	r0!, {r1, r4, r5, r6}
    29d8:	c072      	stmia	r0!, {r1, r4, r5, r6}
    29da:	c072      	stmia	r0!, {r1, r4, r5, r6}
    29dc:	c072      	stmia	r0!, {r1, r4, r5, r6}
    29de:	c072      	stmia	r0!, {r1, r4, r5, r6}
    29e0:	c072      	stmia	r0!, {r1, r4, r5, r6}
    29e2:	c072      	stmia	r0!, {r1, r4, r5, r6}
    29e4:	c072      	stmia	r0!, {r1, r4, r5, r6}
    29e6:	c072      	stmia	r0!, {r1, r4, r5, r6}
    29e8:	c072      	stmia	r0!, {r1, r4, r5, r6}
    29ea:	c072      	stmia	r0!, {r1, r4, r5, r6}
    29ec:	c072      	stmia	r0!, {r1, r4, r5, r6}
    29ee:	c072      	stmia	r0!, {r1, r4, r5, r6}
    29f0:	c072      	stmia	r0!, {r1, r4, r5, r6}
    29f2:	c072      	stmia	r0!, {r1, r4, r5, r6}
    29f4:	c072      	stmia	r0!, {r1, r4, r5, r6}
    29f6:	c072      	stmia	r0!, {r1, r4, r5, r6}
    29f8:	c072      	stmia	r0!, {r1, r4, r5, r6}
    29fa:	c072      	stmia	r0!, {r1, r4, r5, r6}
    29fc:	1a13      	subs	r3, r2, r0
    29fe:	089b      	lsrs	r3, r3, #2
    2a00:	d008      	beq.n	2a14 <FillRuns+0x98>
    2a02:	2404      	movs	r4, #4
    2a04:	1ae4      	subs	r4, r4, r3
    2a06:	0064      	lsls	r4, r4, #1
    2a08:	44a7      	add	pc, r4
    2a0a:	46c0      	nop			(mov r8, r8)
    2a0c:	c002      	stmia	r0!, {r1}
    2a0e:	c002      	stmia	r0!, {r1}
    2a10:	c002      	stmia	r0!, {r1}
    2a12:	c002      	stmia	r0!, {r1}
    2a14:	1a13      	subs	r3, r2, r0
    2a16:	2410      	movs	r4, #16
    2a18:	1ae4      	subs	r4, r4, r3
    2a1a:	0064      	lsls	r4, r4, #1
    2a1c:	44a7      	add	pc, r4
    2a1e:	46c0      	nop			(mov r8, r8)
    2a20:	73c1      	strb	r1, [r0, #15]
    2a22:	7381      	strb	r1, [r0, #14]
    2a24:	7341      	strb	r1, [r0, #13]
    2a26:	7301      	strb	r1, [r0, #12]
    2a28:	72c1      	strb	r1, [r0, #11]
    2a2a:	7281      	strb	r1, [r0, #10]
    2a2c:	7241      	strb	r1, [r0, #9]
    2a2e:	7201      	strb	r1, [r0, #8]
    2a30:	71c1      	strb	r1, [r0, #7]
    2a32:	7181      	strb	r1, [r0, #6]
    2a34:	7141      	strb	r1, [r0, #5]
    2a36:	7101      	strb	r1, [r0, #4]
    2a38:	70c1      	strb	r1, [r0, #3]
    2a3a:	7081      	strb	r1, [r0, #2]
    2a3c:	7041      	strb	r1, [r0, #1]
    2a3e:	7001      	strb	r1, [r0, #0]
    2a40:	1c10      	adds	r0, r2, #0
    2a42:	3702      	adds	r7, #2
    2a44:	4547      	cmp	r7, r8
    2a46:	d1a4      	bne.n	2992 <FillRuns+0x16>
    2a48:	bcf8      	pop	{r3, r4, r5, r6, r7}
    2a4a:	4698      	mov	r8, r3
}
    2a4c:	bd70      	pop	{r4, r5, r6, pc}
    2a4e:	46c0      	nop			(mov r8, r8)

00002a50 <CPPShell>:

extern "C"
void CheckSleep();

extern "C"
void CPPShell()
    2a50:	b510      	push	{r4, lr}
{
	AppInit();
    2a52:	f7ff ff27 	bl	28a4 <_Z7D3DInitv>
	for (;;)
	{
		CheckSleep();
    2a56:	f7fd fc33 	bl	2c0 <CheckSleep>
		AppLoop(0);
    2a5a:	2000      	movs	r0, #0
    2a5c:	f7ff fde2 	bl	2624 <_Z7D3DLoopi>
    2a60:	e7f9      	b.n	2a56 <CPPShell+0x6>
    2a62:	46c0      	nop			(mov r8, r8)

00002a64 <_Z13CopyProcToRamPvPhi>:
}


extern "C"
void memcpy(void* dst, void* src, int len);
void* CopyProcToRam(void* proc, u8* buffer, int len)
    2a64:	b570      	push	{r4, r5, r6, lr}
{
	int addr = (int)proc & 0xFFFFFFFE;
	memcpy(buffer,(void*)addr,len);
    2a66:	2301      	movs	r3, #1
}


extern "C"
void memcpy(void* dst, void* src, int len);
void* CopyProcToRam(void* proc, u8* buffer, int len)
    2a68:	1c04      	adds	r4, r0, #0
{
	int addr = (int)proc & 0xFFFFFFFE;
	memcpy(buffer,(void*)addr,len);
    2a6a:	439c      	bics	r4, r3
}


extern "C"
void memcpy(void* dst, void* src, int len);
void* CopyProcToRam(void* proc, u8* buffer, int len)
    2a6c:	1c0d      	adds	r5, r1, #0
{
	int addr = (int)proc & 0xFFFFFFFE;
	memcpy(buffer,(void*)addr,len);
    2a6e:	1c08      	adds	r0, r1, #0
    2a70:	3501      	adds	r5, #1
    2a72:	1c21      	adds	r1, r4, #0
    2a74:	f000 fa20 	bl	2eb8 <memcpy>
	return (void*)(((int)buffer) + 1);
}
    2a78:	1c28      	adds	r0, r5, #0
    2a7a:	bd70      	pop	{r4, r5, r6, pc}

00002a7c <_Z17LineBufferEnqueuePh>:
	u8* dst = gLineBuffer.Buffer + i*LINE_BUFFER_WIDTH;
	gLineBuffer.Lines[i] = dst;
	return dst;
}

void LineBufferEnqueue(u8* dst)
    2a7c:	b510      	push	{r4, lr}
{
	int i = gLineBuffer.LineIndex & (LINE_BUFFER_COUNT-1);
    2a7e:	4c07      	ldr	r4, [pc, #28]	(2a9c <_Z17LineBufferEnqueuePh+0x20>)
    2a80:	2203      	movs	r2, #3
    2a82:	6823      	ldr	r3, [r4, #0]
	u8* dst = gLineBuffer.Buffer + i*LINE_BUFFER_WIDTH;
	gLineBuffer.Lines[i] = dst;
	return dst;
}

void LineBufferEnqueue(u8* dst)
    2a84:	1c01      	adds	r1, r0, #0
{
	int i = gLineBuffer.LineIndex & (LINE_BUFFER_COUNT-1);
    2a86:	4013      	ands	r3, r2
	gLineBuffer.Lines[i] = dst;
    2a88:	009b      	lsls	r3, r3, #2
    2a8a:	18e3      	adds	r3, r4, r3
    2a8c:	1d18      	adds	r0, r3, #4
    2a8e:	6059      	str	r1, [r3, #4]
	VideoOutEnqueueLine((u8**)&gLineBuffer.Lines[i]);
    2a90:	f7fd fb7a 	bl	188 <VideoOutEnqueueLine>
	gLineBuffer.LineIndex++;
    2a94:	6823      	ldr	r3, [r4, #0]
    2a96:	3301      	adds	r3, #1
    2a98:	6023      	str	r3, [r4, #0]
}
    2a9a:	bd10      	pop	{r4, pc}
    2a9c:	10001138 	.word	0x10001138

00002aa0 <Reset_Handler>:
// resetting the bits in that register) are left solely in the hands of the
// application.
//
//*****************************************************************************
void Reset_Handler(void)
{
    2aa0:	b580      	push	{r7, lr}
    2aa2:	b082      	sub	sp, #8
    2aa4:	af00      	add	r7, sp, #0
    unsigned char *pulSrc, *pulDest;

    //
    // Copy the data segment initializers from flash to SRAM.
    //
    pulSrc = &_etext;
    2aa6:	4b15      	ldr	r3, [pc, #84]	(2afc <Reset_Handler+0x5c>)
    2aa8:	603b      	str	r3, [r7, #0]
    for(pulDest = &_data; pulDest < &_edata; )
    2aaa:	4b15      	ldr	r3, [pc, #84]	(2b00 <Reset_Handler+0x60>)
    2aac:	607b      	str	r3, [r7, #4]
    2aae:	e009      	b.n	2ac4 <Reset_Handler+0x24>
    {
        *pulDest++ = *pulSrc++;
    2ab0:	683b      	ldr	r3, [r7, #0]
    2ab2:	781b      	ldrb	r3, [r3, #0]
    2ab4:	687a      	ldr	r2, [r7, #4]
    2ab6:	7013      	strb	r3, [r2, #0]
    2ab8:	687b      	ldr	r3, [r7, #4]
    2aba:	3301      	adds	r3, #1
    2abc:	607b      	str	r3, [r7, #4]
    2abe:	683b      	ldr	r3, [r7, #0]
    2ac0:	3301      	adds	r3, #1
    2ac2:	603b      	str	r3, [r7, #0]

    //
    // Copy the data segment initializers from flash to SRAM.
    //
    pulSrc = &_etext;
    for(pulDest = &_data; pulDest < &_edata; )
    2ac4:	687a      	ldr	r2, [r7, #4]
    2ac6:	4b0f      	ldr	r3, [pc, #60]	(2b04 <Reset_Handler+0x64>)
    2ac8:	429a      	cmp	r2, r3
    2aca:	d3f1      	bcc.n	2ab0 <Reset_Handler+0x10>
    }

    //
    // Zero fill the bss segment.
    //
	for(pulDest = &_bss; pulDest < &_ebss; pulDest++)
    2acc:	4b0e      	ldr	r3, [pc, #56]	(2b08 <Reset_Handler+0x68>)
    2ace:	607b      	str	r3, [r7, #4]
    2ad0:	e005      	b.n	2ade <Reset_Handler+0x3e>
	  *pulDest = 0;
    2ad2:	687a      	ldr	r2, [r7, #4]
    2ad4:	2300      	movs	r3, #0
    2ad6:	7013      	strb	r3, [r2, #0]
    }

    //
    // Zero fill the bss segment.
    //
	for(pulDest = &_bss; pulDest < &_ebss; pulDest++)
    2ad8:	687b      	ldr	r3, [r7, #4]
    2ada:	3301      	adds	r3, #1
    2adc:	607b      	str	r3, [r7, #4]
    2ade:	687a      	ldr	r2, [r7, #4]
    2ae0:	4b0a      	ldr	r3, [pc, #40]	(2b0c <Reset_Handler+0x6c>)
    2ae2:	429a      	cmp	r2, r3
    2ae4:	d3f5      	bcc.n	2ad2 <Reset_Handler+0x32>
	  *pulDest = 0;

#ifdef __USE_CMSIS
	SystemInit();
    2ae6:	f000 f971 	bl	2dcc <SystemInit>
	//
	// Call the application's entry point.
	// __main() is the entry point for redlib based applications (which calls main())
	// main() is the entry point for newlib based applications
	//
	if (__main)
    2aea:	4b09      	ldr	r3, [pc, #36]	(2b10 <Reset_Handler+0x70>)
    2aec:	2b00      	cmp	r3, #0
    2aee:	d002      	beq.n	2af6 <Reset_Handler+0x56>
		__main() ;
    2af0:	e000      	b.n	2af4 <Reset_Handler+0x54>
    2af2:	bf00      	nop
    2af4:	e001      	b.n	2afa <Reset_Handler+0x5a>
	else
		main() ;
    2af6:	f000 f963 	bl	2dc0 <main>
    2afa:	e7fe      	b.n	2afa <Reset_Handler+0x5a>
    2afc:	000032a8 	.word	0x000032a8
    2b00:	10000000 	.word	0x10000000
    2b04:	10000470 	.word	0x10000470
    2b08:	10000470 	.word	0x10000470
    2b0c:	100018a0 	.word	0x100018a0
    2b10:	00000000 	.word	0x00000000

00002b14 <NMI_Handler>:
// simply enters an infinite loop, preserving the system state for examination
// by a debugger.
//
//*****************************************************************************
void NMI_Handler(void)
{
    2b14:	b580      	push	{r7, lr}
    2b16:	af00      	add	r7, sp, #0
    2b18:	e7fe      	b.n	2b18 <NMI_Handler+0x4>
    2b1a:	46c0      	nop			(mov r8, r8)

00002b1c <HardFault_Handler>:
// interrupt.  This simply enters an infinite loop, preserving the system state
// for examination by a debugger.
//
//*****************************************************************************
void HardFault_Handler(void)
{
    2b1c:	b580      	push	{r7, lr}
    2b1e:	af00      	add	r7, sp, #0
    2b20:	e7fe      	b.n	2b20 <HardFault_Handler+0x4>
    2b22:	46c0      	nop			(mov r8, r8)

00002b24 <SVCall_Handler>:
    {
    }
}

void SVCall_Handler(void)
{
    2b24:	b580      	push	{r7, lr}
    2b26:	af00      	add	r7, sp, #0
    2b28:	e7fe      	b.n	2b28 <SVCall_Handler+0x4>
    2b2a:	46c0      	nop			(mov r8, r8)

00002b2c <PendSV_Handler>:
    {
    }
}

void PendSV_Handler(void)
{
    2b2c:	b580      	push	{r7, lr}
    2b2e:	af00      	add	r7, sp, #0
    2b30:	e7fe      	b.n	2b30 <PendSV_Handler+0x4>
    2b32:	46c0      	nop			(mov r8, r8)

00002b34 <IntDefaultHandler>:
// interrupt.  This simply enters an infinite loop, preserving the system state
// for examination by a debugger.
//
//*****************************************************************************
void IntDefaultHandler(void)
{
    2b34:	b580      	push	{r7, lr}
    2b36:	af00      	add	r7, sp, #0
    2b38:	e7fe      	b.n	2b38 <IntDefaultHandler+0x4>
    2b3a:	46c0      	nop			(mov r8, r8)

00002b3c <_Z3COSh>:
    if (angle & 0x80)
        return -i;
    return i;
}

short COS(byte angle)
    2b3c:	b500      	push	{lr}
{
    return SIN(angle + 64);
    2b3e:	3040      	adds	r0, #64
    2b40:	b2c0      	uxtb	r0, r0
    250,251,252,253,254,254,255,255
};

short SIN(byte angle)
{
    if ((angle & 0x7F) == 0)
    2b42:	0643      	lsls	r3, r0, #25
    2b44:	d010      	beq.n	2b68 <_Z3COSh+0x2c>
        return 0;
    byte b = angle & 0x3F;
    2b46:	233f      	movs	r3, #63
    2b48:	1c02      	adds	r2, r0, #0
    2b4a:	401a      	ands	r2, r3
    if (angle & 0x40)
    2b4c:	0643      	lsls	r3, r0, #25
    2b4e:	d502      	bpl.n	2b56 <_Z3COSh+0x1a>
        b = 0x3F - b;
    2b50:	233f      	movs	r3, #63
    2b52:	1a9b      	subs	r3, r3, r2
    2b54:	b2da      	uxtb	r2, r3
    int i = *(_trig+b) + 1;
    2b56:	4b07      	ldr	r3, [pc, #28]	(2b74 <_Z3COSh+0x38>)
    2b58:	5c9b      	ldrb	r3, [r3, r2]
    2b5a:	1c5a      	adds	r2, r3, #1
    if (angle & 0x80)
    2b5c:	b243      	sxtb	r3, r0
    2b5e:	2b00      	cmp	r3, #0
    2b60:	db04      	blt.n	2b6c <_Z3COSh+0x30>
        return -i;
    return i;
    2b62:	b290      	uxth	r0, r2
    2b64:	b200      	sxth	r0, r0
}

short COS(byte angle)
{
    return SIN(angle + 64);
}
    2b66:	bd00      	pop	{pc}
    250,251,252,253,254,254,255,255
};

short SIN(byte angle)
{
    if ((angle & 0x7F) == 0)
    2b68:	2000      	movs	r0, #0
    2b6a:	e7fb      	b.n	2b64 <_Z3COSh+0x28>
    byte b = angle & 0x3F;
    if (angle & 0x40)
        b = 0x3F - b;
    int i = *(_trig+b) + 1;
    if (angle & 0x80)
        return -i;
    2b6c:	4253      	negs	r3, r2
    2b6e:	b298      	uxth	r0, r3
    2b70:	e7f8      	b.n	2b64 <_Z3COSh+0x28>
    2b72:	46c0      	nop			(mov r8, r8)
    2b74:	000031f4 	.word	0x000031f4

00002b78 <_ZN6Matrix9TranslateElll>:
    return SIN(angle + 64);
}

//  someone clever should rewrite this

void Matrix::Translate(long x, long y, long z)
    2b78:	b510      	push	{r4, lr}
{
    _m[3] += x;
    2b7a:	68c4      	ldr	r4, [r0, #12]
    2b7c:	1864      	adds	r4, r4, r1
    _m[7] += y;
    2b7e:	69c1      	ldr	r1, [r0, #28]

//  someone clever should rewrite this

void Matrix::Translate(long x, long y, long z)
{
    _m[3] += x;
    2b80:	60c4      	str	r4, [r0, #12]
    _m[7] += y;
    2b82:	1889      	adds	r1, r1, r2
    _m[11] += z;
    2b84:	6ac2      	ldr	r2, [r0, #44]
//  someone clever should rewrite this

void Matrix::Translate(long x, long y, long z)
{
    _m[3] += x;
    _m[7] += y;
    2b86:	61c1      	str	r1, [r0, #28]
    _m[11] += z;
    2b88:	18d2      	adds	r2, r2, r3
    2b8a:	62c2      	str	r2, [r0, #44]
}
    2b8c:	bd10      	pop	{r4, pc}
    2b8e:	46c0      	nop			(mov r8, r8)

00002b90 <_Z2SCiRlS_>:

void SC(int a, long& s, long& c)
    2b90:	b570      	push	{r4, r5, r6, lr}
{
    s = SIN(a);  // -256 : 0 : 256
    2b92:	b2c0      	uxtb	r0, r0
    _m[3] += x;
    _m[7] += y;
    _m[11] += z;
}

void SC(int a, long& s, long& c)
    2b94:	1c0c      	adds	r4, r1, #0
    2b96:	1c15      	adds	r5, r2, #0
    250,251,252,253,254,254,255,255
};

short SIN(byte angle)
{
    if ((angle & 0x7F) == 0)
    2b98:	0643      	lsls	r3, r0, #25
    2b9a:	d018      	beq.n	2bce <_Z2SCiRlS_+0x3e>
        return 0;
    byte b = angle & 0x3F;
    2b9c:	233f      	movs	r3, #63
    2b9e:	1c02      	adds	r2, r0, #0
    2ba0:	401a      	ands	r2, r3
    if (angle & 0x40)
    2ba2:	0643      	lsls	r3, r0, #25
    2ba4:	d502      	bpl.n	2bac <_Z2SCiRlS_+0x1c>
        b = 0x3F - b;
    2ba6:	233f      	movs	r3, #63
    2ba8:	1a9b      	subs	r3, r3, r2
    2baa:	b2da      	uxtb	r2, r3
    int i = *(_trig+b) + 1;
    2bac:	4b0a      	ldr	r3, [pc, #40]	(2bd8 <_Z2SCiRlS_+0x48>)
    2bae:	5c9b      	ldrb	r3, [r3, r2]
    2bb0:	1c5a      	adds	r2, r3, #1
    if (angle & 0x80)
    2bb2:	b243      	sxtb	r3, r0
    2bb4:	2b00      	cmp	r3, #0
    2bb6:	db0c      	blt.n	2bd2 <_Z2SCiRlS_+0x42>
    2bb8:	b213      	sxth	r3, r2
    _m[11] += z;
}

void SC(int a, long& s, long& c)
{
    s = SIN(a);  // -256 : 0 : 256
    2bba:	6023      	str	r3, [r4, #0]
    c = COS(a);
    2bbc:	f7ff ffbe 	bl	2b3c <_Z3COSh>
    c <<= 8;
    2bc0:	b200      	sxth	r0, r0
    2bc2:	0200      	lsls	r0, r0, #8
    2bc4:	6028      	str	r0, [r5, #0]
    s <<= 8;
    2bc6:	6823      	ldr	r3, [r4, #0]
    2bc8:	021b      	lsls	r3, r3, #8
    2bca:	6023      	str	r3, [r4, #0]
}
    2bcc:	bd70      	pop	{r4, r5, r6, pc}
    250,251,252,253,254,254,255,255
};

short SIN(byte angle)
{
    if ((angle & 0x7F) == 0)
    2bce:	2300      	movs	r3, #0
    2bd0:	e7f3      	b.n	2bba <_Z2SCiRlS_+0x2a>
        return 0;
    byte b = angle & 0x3F;
    if (angle & 0x40)
        b = 0x3F - b;
    int i = *(_trig+b) + 1;
    if (angle & 0x80)
    2bd2:	4253      	negs	r3, r2
    2bd4:	b21b      	sxth	r3, r3
    2bd6:	e7f0      	b.n	2bba <_Z2SCiRlS_+0x2a>
    2bd8:	000031f4 	.word	0x000031f4

00002bdc <_ZN6Matrix9TransformER4Vec3>:
	_m[4] = -s;
	_m[5] = c;
}

//  Integer coordinates to 12:4, shifting sucks on avr
void Matrix::Transform( Vec3& v )
    2bdc:	b570      	push	{r4, r5, r6, lr}
{	
	long ox = v.x, oy = v.y, oz = v.z;
    2bde:	2302      	movs	r3, #2
    2be0:	5ecd      	ldrsh	r5, [r1, r3]
    2be2:	2304      	movs	r3, #4
    2be4:	5ece      	ldrsh	r6, [r1, r3]
    2be6:	2300      	movs	r3, #0
    2be8:	5ecc      	ldrsh	r4, [r1, r3]
	v.x = (ox*_m[0] + oy*_m[1] + oz*_m[2] + _m[3]) >> 12;
    2bea:	6802      	ldr	r2, [r0, #0]
    2bec:	6843      	ldr	r3, [r0, #4]
    2bee:	4362      	muls	r2, r4
    2bf0:	436b      	muls	r3, r5
    2bf2:	18d2      	adds	r2, r2, r3
    2bf4:	68c3      	ldr	r3, [r0, #12]
    2bf6:	18d2      	adds	r2, r2, r3
    2bf8:	6883      	ldr	r3, [r0, #8]
    2bfa:	4373      	muls	r3, r6
    2bfc:	18d2      	adds	r2, r2, r3
    2bfe:	1312      	asrs	r2, r2, #12
    2c00:	800a      	strh	r2, [r1, #0]
	v.y = (ox*_m[4] + oy*_m[5] + oz*_m[6] + _m[7]) >> 12;
    2c02:	6943      	ldr	r3, [r0, #20]
    2c04:	6902      	ldr	r2, [r0, #16]
    2c06:	436b      	muls	r3, r5
    2c08:	4362      	muls	r2, r4
    2c0a:	18d2      	adds	r2, r2, r3
    2c0c:	69c3      	ldr	r3, [r0, #28]
    2c0e:	18d2      	adds	r2, r2, r3
    2c10:	6983      	ldr	r3, [r0, #24]
    2c12:	4373      	muls	r3, r6
    2c14:	18d2      	adds	r2, r2, r3
    2c16:	1312      	asrs	r2, r2, #12
    2c18:	804a      	strh	r2, [r1, #2]
	v.z = (ox*_m[8] + oy*_m[9] + oz*_m[10] + _m[11]) >> 12;
    2c1a:	6a43      	ldr	r3, [r0, #36]
    2c1c:	6a02      	ldr	r2, [r0, #32]
    2c1e:	436b      	muls	r3, r5
    2c20:	4362      	muls	r2, r4
    2c22:	18d2      	adds	r2, r2, r3
    2c24:	6ac3      	ldr	r3, [r0, #44]
    2c26:	18d2      	adds	r2, r2, r3
    2c28:	6a83      	ldr	r3, [r0, #40]
    2c2a:	4373      	muls	r3, r6
    2c2c:	18d2      	adds	r2, r2, r3
    2c2e:	1312      	asrs	r2, r2, #12
    2c30:	808a      	strh	r2, [r1, #4]
}
    2c32:	bd70      	pop	{r4, r5, r6, pc}

00002c34 <_ZN6Matrix8IdentityEv>:

void Matrix::Identity()
    2c34:	b510      	push	{r4, lr}
{	
    memset(_m,0,sizeof(_m));
    2c36:	2100      	movs	r1, #0
    2c38:	2240      	movs	r2, #64
	v.x = (ox*_m[0] + oy*_m[1] + oz*_m[2] + _m[3]) >> 12;
	v.y = (ox*_m[4] + oy*_m[5] + oz*_m[6] + _m[7]) >> 12;
	v.z = (ox*_m[8] + oy*_m[9] + oz*_m[10] + _m[11]) >> 12;
}

void Matrix::Identity()
    2c3a:	1c04      	adds	r4, r0, #0
{	
    memset(_m,0,sizeof(_m));
    2c3c:	f000 f95c 	bl	2ef8 <memset>
	_m[0] = _m[5] = _m[10] = _m[15] = FPONE;
    2c40:	2380      	movs	r3, #128
    2c42:	025b      	lsls	r3, r3, #9
    2c44:	63e3      	str	r3, [r4, #60]
    2c46:	62a3      	str	r3, [r4, #40]
    2c48:	6163      	str	r3, [r4, #20]
    2c4a:	6023      	str	r3, [r4, #0]
}
    2c4c:	bd10      	pop	{r4, pc}
    2c4e:	46c0      	nop			(mov r8, r8)

00002c50 <_ZN6Matrix11ConcatenateERS_>:
            n += a*b >> sc;
    }
    return n;
}

void Matrix::Concatenate( Matrix& m2 )
    2c50:	b5f0      	push	{r4, r5, r6, r7, lr}
    2c52:	465f      	mov	r7, fp
    2c54:	4656      	mov	r6, sl
    2c56:	464d      	mov	r5, r9
    2c58:	4644      	mov	r4, r8
    2c5a:	b4f0      	push	{r4, r5, r6, r7}
    2c5c:	b093      	sub	sp, #76
    2c5e:	468a      	mov	sl, r1
    2c60:	4683      	mov	fp, r0
    2c62:	a802      	add	r0, sp, #8
    2c64:	f7ff ffe6 	bl	2c34 <_ZN6Matrix8IdentityEv>
	Matrix res;
	for (i = 0; i < 3*4; i += 4)
	{
		for( j = 0; j < 3; j++ )
			res._m[i + j] = MLine(_m+i,m2._m + j,2,2);
	    res._m[i + 3] = MLine(_m+i,m2._m + 3,2,6);
    2c68:	4652      	mov	r2, sl
    2c6a:	320c      	adds	r2, #12
    2c6c:	9201      	str	r2, [sp, #4]
    2c6e:	ab05      	add	r3, sp, #20
    2c70:	2200      	movs	r2, #0
    2c72:	4699      	mov	r9, r3
    2c74:	4690      	mov	r8, r2
	byte i,j;
	Matrix res;
	for (i = 0; i < 3*4; i += 4)
	{
		for( j = 0; j < 3; j++ )
			res._m[i + j] = MLine(_m+i,m2._m + j,2,2);
    2c76:	4642      	mov	r2, r8
    2c78:	0093      	lsls	r3, r2, #2
    2c7a:	465a      	mov	r2, fp
    2c7c:	18d6      	adds	r6, r2, r3
    2c7e:	aa02      	add	r2, sp, #8
    2c80:	18d2      	adds	r2, r2, r3
    2c82:	1c37      	adds	r7, r6, #0
    2c84:	4694      	mov	ip, r2
    2c86:	2500      	movs	r5, #0
    2c88:	3710      	adds	r7, #16
	    res._m[i + 3] = MLine(_m+i,m2._m + 3,2,6);
    2c8a:	00ab      	lsls	r3, r5, #2
    2c8c:	4652      	mov	r2, sl
    2c8e:	18d1      	adds	r1, r2, r3
    2c90:	1c30      	adds	r0, r6, #0
    2c92:	2400      	movs	r4, #0
    long n = 0;
    byte sc = 16-(sa+sb);
    for (byte jj = 0; jj < 16; jj += 4)
    {
        long a,b;   // Don't multiply by zero
        if ((a = (*m++ >> sa)) && (b = (m2m[jj] >> sb)))
    2c94:	c808      	ldmia	r0!, {r3}
    2c96:	109a      	asrs	r2, r3, #2
    2c98:	2a00      	cmp	r2, #0
    2c9a:	d006      	beq.n	2caa <_ZN6Matrix11ConcatenateERS_+0x5a>
    2c9c:	680b      	ldr	r3, [r1, #0]
    2c9e:	109b      	asrs	r3, r3, #2
    2ca0:	2b00      	cmp	r3, #0
    2ca2:	d002      	beq.n	2caa <_ZN6Matrix11ConcatenateERS_+0x5a>
            n += a*b >> sc;
    2ca4:	4353      	muls	r3, r2
    2ca6:	131b      	asrs	r3, r3, #12
    2ca8:	18e4      	adds	r4, r4, r3
    2caa:	3110      	adds	r1, #16
//  Preserve more fidelity on the translation components of the matix
static long MLine(long* m, long* m2m, byte sa, byte sb)
{
    long n = 0;
    byte sc = 16-(sa+sb);
    for (byte jj = 0; jj < 16; jj += 4)
    2cac:	42b8      	cmp	r0, r7
    2cae:	d1f1      	bne.n	2c94 <_ZN6Matrix11ConcatenateERS_+0x44>
	byte i,j;
	Matrix res;
	for (i = 0; i < 3*4; i += 4)
	{
		for( j = 0; j < 3; j++ )
			res._m[i + j] = MLine(_m+i,m2._m + j,2,2);
    2cb0:	4663      	mov	r3, ip
    2cb2:	3304      	adds	r3, #4
    2cb4:	469c      	mov	ip, r3
    2cb6:	3501      	adds	r5, #1
    2cb8:	3b04      	subs	r3, #4
    2cba:	c310      	stmia	r3!, {r4}
{	
	byte i,j;
	Matrix res;
	for (i = 0; i < 3*4; i += 4)
	{
		for( j = 0; j < 3; j++ )
    2cbc:	2d03      	cmp	r5, #3
    2cbe:	d1e4      	bne.n	2c8a <_ZN6Matrix11ConcatenateERS_+0x3a>
    2cc0:	9a01      	ldr	r2, [sp, #4]
    2cc2:	2400      	movs	r4, #0
    long n = 0;
    byte sc = 16-(sa+sb);
    for (byte jj = 0; jj < 16; jj += 4)
    {
        long a,b;   // Don't multiply by zero
        if ((a = (*m++ >> sa)) && (b = (m2m[jj] >> sb)))
    2cc4:	ce08      	ldmia	r6!, {r3}
    2cc6:	1099      	asrs	r1, r3, #2
    2cc8:	2900      	cmp	r1, #0
    2cca:	d006      	beq.n	2cda <_ZN6Matrix11ConcatenateERS_+0x8a>
    2ccc:	6813      	ldr	r3, [r2, #0]
    2cce:	119b      	asrs	r3, r3, #6
    2cd0:	2b00      	cmp	r3, #0
    2cd2:	d002      	beq.n	2cda <_ZN6Matrix11ConcatenateERS_+0x8a>
            n += a*b >> sc;
    2cd4:	434b      	muls	r3, r1
    2cd6:	121b      	asrs	r3, r3, #8
    2cd8:	18e4      	adds	r4, r4, r3
    2cda:	3210      	adds	r2, #16
//  Preserve more fidelity on the translation components of the matix
static long MLine(long* m, long* m2m, byte sa, byte sb)
{
    long n = 0;
    byte sc = 16-(sa+sb);
    for (byte jj = 0; jj < 16; jj += 4)
    2cdc:	4286      	cmp	r6, r0
    2cde:	d1f1      	bne.n	2cc4 <_ZN6Matrix11ConcatenateERS_+0x74>
	Matrix res;
	for (i = 0; i < 3*4; i += 4)
	{
		for( j = 0; j < 3; j++ )
			res._m[i + j] = MLine(_m+i,m2._m + j,2,2);
	    res._m[i + 3] = MLine(_m+i,m2._m + 3,2,6);
    2ce0:	2304      	movs	r3, #4
    2ce2:	464a      	mov	r2, r9
    2ce4:	4498      	add	r8, r3
    2ce6:	6014      	str	r4, [r2, #0]

void Matrix::Concatenate( Matrix& m2 )
{	
	byte i,j;
	Matrix res;
	for (i = 0; i < 3*4; i += 4)
    2ce8:	4643      	mov	r3, r8
	{
		for( j = 0; j < 3; j++ )
			res._m[i + j] = MLine(_m+i,m2._m + j,2,2);
	    res._m[i + 3] = MLine(_m+i,m2._m + 3,2,6);
    2cea:	2210      	movs	r2, #16
    2cec:	4491      	add	r9, r2

void Matrix::Concatenate( Matrix& m2 )
{	
	byte i,j;
	Matrix res;
	for (i = 0; i < 3*4; i += 4)
    2cee:	2b0c      	cmp	r3, #12
    2cf0:	d1c1      	bne.n	2c76 <_ZN6Matrix11ConcatenateERS_+0x26>
		for( j = 0; j < 3; j++ )
			res._m[i + j] = MLine(_m+i,m2._m + j,2,2);
	    res._m[i + 3] = MLine(_m+i,m2._m + 3,2,6);
	}
	for( j = 0; j < 4; j++ )
		res._m[12 + j] = MLine(_m+12,m2._m + j,6,6);
    2cf2:	2330      	movs	r3, #48
    2cf4:	469c      	mov	ip, r3
    2cf6:	465e      	mov	r6, fp
    2cf8:	44dc      	add	ip, fp
    2cfa:	af0e      	add	r7, sp, #56
    2cfc:	2500      	movs	r5, #0
    2cfe:	3640      	adds	r6, #64
    2d00:	4652      	mov	r2, sl
    2d02:	00ab      	lsls	r3, r5, #2
    2d04:	18d0      	adds	r0, r2, r3
    2d06:	2400      	movs	r4, #0
    2d08:	4662      	mov	r2, ip
    long n = 0;
    byte sc = 16-(sa+sb);
    for (byte jj = 0; jj < 16; jj += 4)
    {
        long a,b;   // Don't multiply by zero
        if ((a = (*m++ >> sa)) && (b = (m2m[jj] >> sb)))
    2d0a:	ca08      	ldmia	r2!, {r3}
    2d0c:	1199      	asrs	r1, r3, #6
    2d0e:	2900      	cmp	r1, #0
    2d10:	d006      	beq.n	2d20 <_ZN6Matrix11ConcatenateERS_+0xd0>
    2d12:	6803      	ldr	r3, [r0, #0]
    2d14:	119b      	asrs	r3, r3, #6
    2d16:	2b00      	cmp	r3, #0
    2d18:	d002      	beq.n	2d20 <_ZN6Matrix11ConcatenateERS_+0xd0>
            n += a*b >> sc;
    2d1a:	434b      	muls	r3, r1
    2d1c:	111b      	asrs	r3, r3, #4
    2d1e:	18e4      	adds	r4, r4, r3
    2d20:	3010      	adds	r0, #16
//  Preserve more fidelity on the translation components of the matix
static long MLine(long* m, long* m2m, byte sa, byte sb)
{
    long n = 0;
    byte sc = 16-(sa+sb);
    for (byte jj = 0; jj < 16; jj += 4)
    2d22:	42b2      	cmp	r2, r6
    2d24:	d1f1      	bne.n	2d0a <_ZN6Matrix11ConcatenateERS_+0xba>
		for( j = 0; j < 3; j++ )
			res._m[i + j] = MLine(_m+i,m2._m + j,2,2);
	    res._m[i + 3] = MLine(_m+i,m2._m + 3,2,6);
	}
	for( j = 0; j < 4; j++ )
		res._m[12 + j] = MLine(_m+12,m2._m + j,6,6);
    2d26:	3501      	adds	r5, #1
    2d28:	c710      	stmia	r7!, {r4}
	{
		for( j = 0; j < 3; j++ )
			res._m[i + j] = MLine(_m+i,m2._m + j,2,2);
	    res._m[i + 3] = MLine(_m+i,m2._m + 3,2,6);
	}
	for( j = 0; j < 4; j++ )
    2d2a:	2d04      	cmp	r5, #4
    2d2c:	d1e8      	bne.n	2d00 <_ZN6Matrix11ConcatenateERS_+0xb0>
		res._m[12 + j] = MLine(_m+12,m2._m + j,6,6);
	memcpy(_m,res._m,sizeof(_m));
    2d2e:	4658      	mov	r0, fp
    2d30:	a902      	add	r1, sp, #8
    2d32:	2240      	movs	r2, #64
    2d34:	f000 f8c0 	bl	2eb8 <memcpy>
}
    2d38:	b013      	add	sp, #76
    2d3a:	bc3c      	pop	{r2, r3, r4, r5}
    2d3c:	4690      	mov	r8, r2
    2d3e:	4699      	mov	r9, r3
    2d40:	46a2      	mov	sl, r4
    2d42:	46ab      	mov	fp, r5
    2d44:	bdf0      	pop	{r4, r5, r6, r7, pc}
    2d46:	46c0      	nop			(mov r8, r8)

00002d48 <_ZN6Matrix7RotateZEi>:
	_m[2] = -s;
	_m[8] = s;
	_m[10] = c;
}

void Matrix::RotateZ( int a  )
    2d48:	b510      	push	{r4, lr}
    2d4a:	b082      	sub	sp, #8
    2d4c:	1c04      	adds	r4, r0, #0
{	
	long s,c;	
	SC(a,s,c);
    2d4e:	466a      	mov	r2, sp
    2d50:	1c08      	adds	r0, r1, #0
    2d52:	a901      	add	r1, sp, #4
    2d54:	f7ff ff1c 	bl	2b90 <_Z2SCiRlS_>
	Identity();
    2d58:	1c20      	adds	r0, r4, #0
    2d5a:	f7ff ff6b 	bl	2c34 <_ZN6Matrix8IdentityEv>
	_m[0] = c;
	_m[1] = s;
    2d5e:	9b01      	ldr	r3, [sp, #4]
void Matrix::RotateZ( int a  )
{	
	long s,c;	
	SC(a,s,c);
	Identity();
	_m[0] = c;
    2d60:	9a00      	ldr	r2, [sp, #0]
	_m[1] = s;
    2d62:	6063      	str	r3, [r4, #4]
	_m[4] = -s;
	_m[5] = c;
}
    2d64:	b002      	add	sp, #8
	long s,c;	
	SC(a,s,c);
	Identity();
	_m[0] = c;
	_m[1] = s;
	_m[4] = -s;
    2d66:	425b      	negs	r3, r3
void Matrix::RotateZ( int a  )
{	
	long s,c;	
	SC(a,s,c);
	Identity();
	_m[0] = c;
    2d68:	6022      	str	r2, [r4, #0]
	_m[1] = s;
	_m[4] = -s;
    2d6a:	6123      	str	r3, [r4, #16]
	_m[5] = c;
    2d6c:	6162      	str	r2, [r4, #20]
}
    2d6e:	bd10      	pop	{r4, pc}

00002d70 <_ZN6Matrix7RotateYEi>:
	_m[6] = s;
	_m[9] = -s;
	_m[10] = c;
}

void Matrix::RotateY( int a  )
    2d70:	b510      	push	{r4, lr}
    2d72:	b082      	sub	sp, #8
    2d74:	1c04      	adds	r4, r0, #0
{	
	long s,c;	
	SC(a,s,c);
    2d76:	466a      	mov	r2, sp
    2d78:	1c08      	adds	r0, r1, #0
    2d7a:	a901      	add	r1, sp, #4
    2d7c:	f7ff ff08 	bl	2b90 <_Z2SCiRlS_>
	Identity();
    2d80:	1c20      	adds	r0, r4, #0
    2d82:	f7ff ff57 	bl	2c34 <_ZN6Matrix8IdentityEv>
	_m[0] = c;
	_m[2] = -s;
    2d86:	9a01      	ldr	r2, [sp, #4]
void Matrix::RotateY( int a  )
{	
	long s,c;	
	SC(a,s,c);
	Identity();
	_m[0] = c;
    2d88:	9900      	ldr	r1, [sp, #0]
	_m[2] = -s;
    2d8a:	4253      	negs	r3, r2
	_m[8] = s;
	_m[10] = c;
}
    2d8c:	b002      	add	sp, #8
void Matrix::RotateY( int a  )
{	
	long s,c;	
	SC(a,s,c);
	Identity();
	_m[0] = c;
    2d8e:	6021      	str	r1, [r4, #0]
	_m[2] = -s;
    2d90:	60a3      	str	r3, [r4, #8]
	_m[8] = s;
    2d92:	6222      	str	r2, [r4, #32]
	_m[10] = c;
    2d94:	62a1      	str	r1, [r4, #40]
}
    2d96:	bd10      	pop	{r4, pc}

00002d98 <_ZN6Matrix7RotateXEi>:
    c = COS(a);
    c <<= 8;
    s <<= 8;
}

void Matrix::RotateX( int a )
    2d98:	b510      	push	{r4, lr}
    2d9a:	b082      	sub	sp, #8
    2d9c:	1c04      	adds	r4, r0, #0
{	
	long s,c;	
	SC(a,s,c);
    2d9e:	466a      	mov	r2, sp
    2da0:	1c08      	adds	r0, r1, #0
    2da2:	a901      	add	r1, sp, #4
    2da4:	f7ff fef4 	bl	2b90 <_Z2SCiRlS_>
	Identity();
    2da8:	1c20      	adds	r0, r4, #0
    2daa:	f7ff ff43 	bl	2c34 <_ZN6Matrix8IdentityEv>
	_m[5] = c;
	_m[6] = s;
    2dae:	9b01      	ldr	r3, [sp, #4]
void Matrix::RotateX( int a )
{	
	long s,c;	
	SC(a,s,c);
	Identity();
	_m[5] = c;
    2db0:	9a00      	ldr	r2, [sp, #0]
	_m[6] = s;
    2db2:	61a3      	str	r3, [r4, #24]
	_m[9] = -s;
	_m[10] = c;
}
    2db4:	b002      	add	sp, #8
	long s,c;	
	SC(a,s,c);
	Identity();
	_m[5] = c;
	_m[6] = s;
	_m[9] = -s;
    2db6:	425b      	negs	r3, r3
void Matrix::RotateX( int a )
{	
	long s,c;	
	SC(a,s,c);
	Identity();
	_m[5] = c;
    2db8:	6162      	str	r2, [r4, #20]
	_m[6] = s;
	_m[9] = -s;
    2dba:	6263      	str	r3, [r4, #36]
	_m[10] = c;
    2dbc:	62a2      	str	r2, [r4, #40]
}
    2dbe:	bd10      	pop	{r4, pc}

00002dc0 <main>:
#include "LPC11xx.h"                        /* LPC11xx definitions */

void CPPShell();

int main (void)
{
    2dc0:	b510      	push	{r4, lr}
	CPPShell();
    2dc2:	f7ff fe45 	bl	2a50 <CPPShell>
	return 0;
}
    2dc6:	2000      	movs	r0, #0
    2dc8:	bd10      	pop	{r4, pc}
    2dca:	46c0      	nop			(mov r8, r8)

00002dcc <SystemInit>:
 *
 * @brief  Setup the microcontroller system.
 *         Initialize the System.
 */
void SystemInit (void)
{
    2dcc:	b580      	push	{r7, lr}
    2dce:	b082      	sub	sp, #8
    2dd0:	af00      	add	r7, sp, #0
#if (CLOCK_SETUP)                                 /* Clock Setup              */
#if (SYSCLK_SETUP)                                /* System Clock Setup       */
#if (SYSOSC_SETUP)                                /* System Oscillator Setup  */
  uint32_t i;

  LPC_SYSCON->PDRUNCFG     &= ~(1 << 5);          /* Power-up System Osc      */
    2dd2:	4934      	ldr	r1, [pc, #208]	(2ea4 <SystemInit+0xd8>)
    2dd4:	4a33      	ldr	r2, [pc, #204]	(2ea4 <SystemInit+0xd8>)
    2dd6:	238e      	movs	r3, #142
    2dd8:	009b      	lsls	r3, r3, #2
    2dda:	58d2      	ldr	r2, [r2, r3]
    2ddc:	2320      	movs	r3, #32
    2dde:	439a      	bics	r2, r3
    2de0:	238e      	movs	r3, #142
    2de2:	009b      	lsls	r3, r3, #2
    2de4:	50ca      	str	r2, [r1, r3]
  LPC_SYSCON->SYSOSCCTRL    = SYSOSCCTRL_Val;
    2de6:	4a2f      	ldr	r2, [pc, #188]	(2ea4 <SystemInit+0xd8>)
    2de8:	2300      	movs	r3, #0
    2dea:	6213      	str	r3, [r2, #32]
  for (i = 0; i < 200; i++) __NOP();
    2dec:	2300      	movs	r3, #0
    2dee:	607b      	str	r3, [r7, #4]
    2df0:	e004      	b.n	2dfc <SystemInit+0x30>
    2df2:	f000 f85b 	bl	2eac <__NOP>
    2df6:	687b      	ldr	r3, [r7, #4]
    2df8:	3301      	adds	r3, #1
    2dfa:	607b      	str	r3, [r7, #4]
    2dfc:	687b      	ldr	r3, [r7, #4]
    2dfe:	2bc7      	cmp	r3, #199
    2e00:	d9f7      	bls.n	2df2 <SystemInit+0x26>
  LPC_SYSCON->SYSPLLCLKSEL  = SYSPLLCLKSEL_Val;   /* Select PLL Input         */
    2e02:	4a28      	ldr	r2, [pc, #160]	(2ea4 <SystemInit+0xd8>)
    2e04:	2301      	movs	r3, #1
    2e06:	6413      	str	r3, [r2, #64]
  LPC_SYSCON->SYSPLLCLKUEN  = 0x01;               /* Update Clock Source      */
    2e08:	4a26      	ldr	r2, [pc, #152]	(2ea4 <SystemInit+0xd8>)
    2e0a:	2301      	movs	r3, #1
    2e0c:	6453      	str	r3, [r2, #68]
  LPC_SYSCON->SYSPLLCLKUEN  = 0x00;               /* Toggle Update Register   */
    2e0e:	4a25      	ldr	r2, [pc, #148]	(2ea4 <SystemInit+0xd8>)
    2e10:	2300      	movs	r3, #0
    2e12:	6453      	str	r3, [r2, #68]
  LPC_SYSCON->SYSPLLCLKUEN  = 0x01;
    2e14:	4a23      	ldr	r2, [pc, #140]	(2ea4 <SystemInit+0xd8>)
    2e16:	2301      	movs	r3, #1
    2e18:	6453      	str	r3, [r2, #68]
  while (!(LPC_SYSCON->SYSPLLCLKUEN & 0x01));     /* Wait Until Updated       */
    2e1a:	4b22      	ldr	r3, [pc, #136]	(2ea4 <SystemInit+0xd8>)
    2e1c:	6c5b      	ldr	r3, [r3, #68]
    2e1e:	1c1a      	adds	r2, r3, #0
    2e20:	2301      	movs	r3, #1
    2e22:	4013      	ands	r3, r2
    2e24:	2b00      	cmp	r3, #0
    2e26:	d0f8      	beq.n	2e1a <SystemInit+0x4e>
#if (SYSPLL_SETUP)                                /* System PLL Setup         */
  LPC_SYSCON->SYSPLLCTRL    = SYSPLLCTRL_Val;
    2e28:	4a1e      	ldr	r2, [pc, #120]	(2ea4 <SystemInit+0xd8>)
    2e2a:	2323      	movs	r3, #35
    2e2c:	6093      	str	r3, [r2, #8]
  LPC_SYSCON->PDRUNCFG     &= ~(1 << 7);          /* Power-up SYSPLL          */
    2e2e:	491d      	ldr	r1, [pc, #116]	(2ea4 <SystemInit+0xd8>)
    2e30:	4a1c      	ldr	r2, [pc, #112]	(2ea4 <SystemInit+0xd8>)
    2e32:	238e      	movs	r3, #142
    2e34:	009b      	lsls	r3, r3, #2
    2e36:	58d2      	ldr	r2, [r2, r3]
    2e38:	2380      	movs	r3, #128
    2e3a:	439a      	bics	r2, r3
    2e3c:	238e      	movs	r3, #142
    2e3e:	009b      	lsls	r3, r3, #2
    2e40:	50ca      	str	r2, [r1, r3]
  while (!(LPC_SYSCON->SYSPLLSTAT & 0x01));	      /* Wait Until PLL Locked    */
    2e42:	4b18      	ldr	r3, [pc, #96]	(2ea4 <SystemInit+0xd8>)
    2e44:	68db      	ldr	r3, [r3, #12]
    2e46:	1c1a      	adds	r2, r3, #0
    2e48:	2301      	movs	r3, #1
    2e4a:	4013      	ands	r3, r2
    2e4c:	2b00      	cmp	r3, #0
    2e4e:	d0f8      	beq.n	2e42 <SystemInit+0x76>
#endif
#if (WDTOSC_SETUP)                                /* Watchdog Oscillator Setup*/
  LPC_SYSCON->WDTOSCCTRL    = WDTOSCCTRL_Val;
  LPC_SYSCON->PDRUNCFG     &= ~(1 << 6);          /* Power-up WDT Clock       */
#endif
  LPC_SYSCON->MAINCLKSEL    = MAINCLKSEL_Val;     /* Select PLL Clock Output  */
    2e50:	4a14      	ldr	r2, [pc, #80]	(2ea4 <SystemInit+0xd8>)
    2e52:	2303      	movs	r3, #3
    2e54:	6713      	str	r3, [r2, #112]
  LPC_SYSCON->MAINCLKUEN    = 0x01;               /* Update MCLK Clock Source */
    2e56:	4a13      	ldr	r2, [pc, #76]	(2ea4 <SystemInit+0xd8>)
    2e58:	2301      	movs	r3, #1
    2e5a:	6753      	str	r3, [r2, #116]
  LPC_SYSCON->MAINCLKUEN    = 0x00;               /* Toggle Update Register   */
    2e5c:	4a11      	ldr	r2, [pc, #68]	(2ea4 <SystemInit+0xd8>)
    2e5e:	2300      	movs	r3, #0
    2e60:	6753      	str	r3, [r2, #116]
  LPC_SYSCON->MAINCLKUEN    = 0x01;
    2e62:	4a10      	ldr	r2, [pc, #64]	(2ea4 <SystemInit+0xd8>)
    2e64:	2301      	movs	r3, #1
    2e66:	6753      	str	r3, [r2, #116]
  while (!(LPC_SYSCON->MAINCLKUEN & 0x01));       /* Wait Until Updated       */
    2e68:	4b0e      	ldr	r3, [pc, #56]	(2ea4 <SystemInit+0xd8>)
    2e6a:	6f5b      	ldr	r3, [r3, #116]
    2e6c:	1c1a      	adds	r2, r3, #0
    2e6e:	2301      	movs	r3, #1
    2e70:	4013      	ands	r3, r2
    2e72:	2b00      	cmp	r3, #0
    2e74:	d0f8      	beq.n	2e68 <SystemInit+0x9c>
#endif

  LPC_SYSCON->SYSAHBCLKDIV  = SYSAHBCLKDIV_Val;
    2e76:	4a0b      	ldr	r2, [pc, #44]	(2ea4 <SystemInit+0xd8>)
    2e78:	2301      	movs	r3, #1
    2e7a:	6793      	str	r3, [r2, #120]
  LPC_SYSCON->SYSAHBCLKCTRL = AHBCLKCTRL_Val;
    2e7c:	4909      	ldr	r1, [pc, #36]	(2ea4 <SystemInit+0xd8>)
    2e7e:	2280      	movs	r2, #128
    2e80:	4b09      	ldr	r3, [pc, #36]	(2ea8 <SystemInit+0xdc>)
    2e82:	508b      	str	r3, [r1, r2]
  LPC_SYSCON->SSP0CLKDIV    = SSP0CLKDIV_Val;
    2e84:	4907      	ldr	r1, [pc, #28]	(2ea4 <SystemInit+0xd8>)
    2e86:	2294      	movs	r2, #148
    2e88:	2301      	movs	r3, #1
    2e8a:	508b      	str	r3, [r1, r2]
  LPC_SYSCON->UARTCLKDIV    = UARTCLKDIV_Val;
    2e8c:	4905      	ldr	r1, [pc, #20]	(2ea4 <SystemInit+0xd8>)
    2e8e:	2298      	movs	r2, #152
    2e90:	2301      	movs	r3, #1
    2e92:	508b      	str	r3, [r1, r2]
  LPC_SYSCON->SSP1CLKDIV    = SSP1CLKDIV_Val;
    2e94:	4903      	ldr	r1, [pc, #12]	(2ea4 <SystemInit+0xd8>)
    2e96:	229c      	movs	r2, #156
    2e98:	2301      	movs	r3, #1
    2e9a:	508b      	str	r3, [r1, r2]


#if (MEMMAP_SETUP || MEMMAP_INIT)       /* Memory Mapping Setup               */
  LPC_SYSCON->SYSMEMREMAP = SYSMEMREMAP_Val;
#endif
}
    2e9c:	46bd      	mov	sp, r7
    2e9e:	b002      	add	sp, #8
    2ea0:	bd80      	pop	{r7, pc}
    2ea2:	46c0      	nop			(mov r8, r8)
    2ea4:	40048000 	.word	0x40048000
    2ea8:	5f          	.byte	0x5f
    2ea9:	00          	.byte	0x00
    2eaa:	0001      	.short	0x0001

00002eac <__NOP>:
static __INLINE void __disable_irq()              { __ASM volatile ("cpsid i"); }

static __INLINE void __enable_fault_irq()         { __ASM volatile ("cpsie f"); }
static __INLINE void __disable_fault_irq()        { __ASM volatile ("cpsid f"); }

static __INLINE void __NOP()                      { __ASM volatile ("nop"); }
    2eac:	b580      	push	{r7, lr}
    2eae:	af00      	add	r7, sp, #0
    2eb0:	46c0      	nop			(mov r8, r8)
    2eb2:	46bd      	mov	sp, r7
    2eb4:	bd80      	pop	{r7, pc}
    2eb6:	46c0      	nop			(mov r8, r8)

00002eb8 <memcpy>:
    2eb8:	b510      	push	{r4, lr}
    2eba:	1c04      	adds	r4, r0, #0
    2ebc:	1c08      	adds	r0, r1, #0
    2ebe:	1c03      	adds	r3, r0, #0
    2ec0:	4323      	orrs	r3, r4
    2ec2:	4313      	orrs	r3, r2
    2ec4:	1c11      	adds	r1, r2, #0
    2ec6:	079a      	lsls	r2, r3, #30
    2ec8:	d10d      	bne.n	2ee6 <memcpy+0x2e>
    2eca:	0889      	lsrs	r1, r1, #2
    2ecc:	2900      	cmp	r1, #0
    2ece:	d006      	beq.n	2ede <memcpy+0x26>
    2ed0:	2200      	movs	r2, #0
    2ed2:	5883      	ldr	r3, [r0, r2]
    2ed4:	3901      	subs	r1, #1
    2ed6:	50a3      	str	r3, [r4, r2]
    2ed8:	3204      	adds	r2, #4
    2eda:	2900      	cmp	r1, #0
    2edc:	d1f9      	bne.n	2ed2 <memcpy+0x1a>
    2ede:	1c20      	adds	r0, r4, #0
    2ee0:	bc10      	pop	{r4}
    2ee2:	bc02      	pop	{r1}
    2ee4:	4708      	bx	r1
    2ee6:	2900      	cmp	r1, #0
    2ee8:	d0f9      	beq.n	2ede <memcpy+0x26>
    2eea:	2200      	movs	r2, #0
    2eec:	5c83      	ldrb	r3, [r0, r2]
    2eee:	54a3      	strb	r3, [r4, r2]
    2ef0:	3201      	adds	r2, #1
    2ef2:	4291      	cmp	r1, r2
    2ef4:	d1fa      	bne.n	2eec <memcpy+0x34>
    2ef6:	e7f2      	b.n	2ede <memcpy+0x26>

00002ef8 <memset>:
    2ef8:	b5f0      	push	{r4, r5, r6, r7, lr}
    2efa:	1c0b      	adds	r3, r1, #0
    2efc:	1c07      	adds	r7, r0, #0
    2efe:	1c11      	adds	r1, r2, #0
    2f00:	2a00      	cmp	r2, #0
    2f02:	d019      	beq.n	2f38 <memset+0x40>
    2f04:	061b      	lsls	r3, r3, #24
    2f06:	0e1d      	lsrs	r5, r3, #24
    2f08:	022b      	lsls	r3, r5, #8
    2f0a:	195b      	adds	r3, r3, r5
    2f0c:	041a      	lsls	r2, r3, #16
    2f0e:	189c      	adds	r4, r3, r2
    2f10:	2603      	movs	r6, #3
    2f12:	2903      	cmp	r1, #3
    2f14:	d914      	bls.n	2f40 <memset+0x48>
    2f16:	4230      	tst	r0, r6
    2f18:	d112      	bne.n	2f40 <memset+0x48>
    2f1a:	2200      	movs	r2, #0
    2f1c:	5084      	str	r4, [r0, r2]
    2f1e:	3204      	adds	r2, #4
    2f20:	1a8b      	subs	r3, r1, r2
    2f22:	2b03      	cmp	r3, #3
    2f24:	d8fa      	bhi.n	2f1c <memset+0x24>
    2f26:	1f0b      	subs	r3, r1, #4
    2f28:	1c19      	adds	r1, r3, #0
    2f2a:	089b      	lsrs	r3, r3, #2
    2f2c:	3301      	adds	r3, #1
    2f2e:	009b      	lsls	r3, r3, #2
    2f30:	4031      	ands	r1, r6
    2f32:	18c0      	adds	r0, r0, r3
    2f34:	2900      	cmp	r1, #0
    2f36:	d1ec      	bne.n	2f12 <memset+0x1a>
    2f38:	1c38      	adds	r0, r7, #0
    2f3a:	bcf0      	pop	{r4, r5, r6, r7}
    2f3c:	bc02      	pop	{r1}
    2f3e:	4708      	bx	r1
    2f40:	7005      	strb	r5, [r0, #0]
    2f42:	3901      	subs	r1, #1
    2f44:	3001      	adds	r0, #1
    2f46:	e7f5      	b.n	2f34 <memset+0x3c>

00002f48 <__aeabi_idiv0>:
    2f48:	4770      	bx	lr
    2f4a:	46c0      	nop			(mov r8, r8)

00002f4c <__bhs_uidivmod>:
    2f4c:	b5f0      	push	{r4, r5, r6, r7, lr}
    2f4e:	4647      	mov	r7, r8
    2f50:	b480      	push	{r7}
    2f52:	1c05      	adds	r5, r0, #0
    2f54:	1c14      	adds	r4, r2, #0
    2f56:	2a00      	cmp	r2, #0
    2f58:	d034      	beq.n	2fc4 <__bhs_uidivmod+0x78>
    2f5a:	090b      	lsrs	r3, r1, #4
    2f5c:	429a      	cmp	r2, r3
    2f5e:	d837      	bhi.n	2fd0 <__bhs_uidivmod+0x84>
    2f60:	2001      	movs	r0, #1
    2f62:	0124      	lsls	r4, r4, #4
    2f64:	3001      	adds	r0, #1
    2f66:	429c      	cmp	r4, r3
    2f68:	d9fb      	bls.n	2f62 <__bhs_uidivmod+0x16>
    2f6a:	2308      	movs	r3, #8
    2f6c:	4698      	mov	r8, r3
    2f6e:	2304      	movs	r3, #4
    2f70:	2200      	movs	r2, #0
    2f72:	469c      	mov	ip, r3
    2f74:	2702      	movs	r7, #2
    2f76:	2601      	movs	r6, #1
    2f78:	e000      	b.n	2f7c <__bhs_uidivmod+0x30>
    2f7a:	0924      	lsrs	r4, r4, #4
    2f7c:	08cb      	lsrs	r3, r1, #3
    2f7e:	0112      	lsls	r2, r2, #4
    2f80:	429c      	cmp	r4, r3
    2f82:	d803      	bhi.n	2f8c <__bhs_uidivmod+0x40>
    2f84:	00e3      	lsls	r3, r4, #3
    2f86:	1ac9      	subs	r1, r1, r3
    2f88:	4643      	mov	r3, r8
    2f8a:	431a      	orrs	r2, r3
    2f8c:	088b      	lsrs	r3, r1, #2
    2f8e:	429c      	cmp	r4, r3
    2f90:	d803      	bhi.n	2f9a <__bhs_uidivmod+0x4e>
    2f92:	00a3      	lsls	r3, r4, #2
    2f94:	1ac9      	subs	r1, r1, r3
    2f96:	4663      	mov	r3, ip
    2f98:	431a      	orrs	r2, r3
    2f9a:	084b      	lsrs	r3, r1, #1
    2f9c:	429c      	cmp	r4, r3
    2f9e:	d802      	bhi.n	2fa6 <__bhs_uidivmod+0x5a>
    2fa0:	0063      	lsls	r3, r4, #1
    2fa2:	1ac9      	subs	r1, r1, r3
    2fa4:	433a      	orrs	r2, r7
    2fa6:	42a1      	cmp	r1, r4
    2fa8:	d301      	bcc.n	2fae <__bhs_uidivmod+0x62>
    2faa:	1b09      	subs	r1, r1, r4
    2fac:	4332      	orrs	r2, r6
    2fae:	3801      	subs	r0, #1
    2fb0:	2800      	cmp	r0, #0
    2fb2:	d1e2      	bne.n	2f7a <__bhs_uidivmod+0x2e>
    2fb4:	6069      	str	r1, [r5, #4]
    2fb6:	602a      	str	r2, [r5, #0]
    2fb8:	1c28      	adds	r0, r5, #0
    2fba:	bc04      	pop	{r2}
    2fbc:	4690      	mov	r8, r2
    2fbe:	bcf0      	pop	{r4, r5, r6, r7}
    2fc0:	bc02      	pop	{r1}
    2fc2:	4708      	bx	r1
    2fc4:	2000      	movs	r0, #0
    2fc6:	f7ff ffbf 	bl	2f48 <__aeabi_idiv0>
    2fca:	606c      	str	r4, [r5, #4]
    2fcc:	6028      	str	r0, [r5, #0]
    2fce:	e7f3      	b.n	2fb8 <__bhs_uidivmod+0x6c>
    2fd0:	2001      	movs	r0, #1
    2fd2:	e7ca      	b.n	2f6a <__bhs_uidivmod+0x1e>

00002fd4 <__aeabi_idiv>:
    2fd4:	b530      	push	{r4, r5, lr}
    2fd6:	17c3      	asrs	r3, r0, #31
    2fd8:	1c0c      	adds	r4, r1, #0
    2fda:	18c1      	adds	r1, r0, r3
    2fdc:	4059      	eors	r1, r3
    2fde:	17e3      	asrs	r3, r4, #31
    2fe0:	b083      	sub	sp, #12
    2fe2:	18e2      	adds	r2, r4, r3
    2fe4:	1c05      	adds	r5, r0, #0
    2fe6:	405a      	eors	r2, r3
    2fe8:	4668      	mov	r0, sp
    2fea:	406c      	eors	r4, r5
    2fec:	f7ff ffae 	bl	2f4c <__bhs_uidivmod>
    2ff0:	9800      	ldr	r0, [sp, #0]
    2ff2:	2c00      	cmp	r4, #0
    2ff4:	db03      	blt.n	2ffe <__aeabi_idiv+0x2a>
    2ff6:	b003      	add	sp, #12
    2ff8:	bc30      	pop	{r4, r5}
    2ffa:	bc02      	pop	{r1}
    2ffc:	4708      	bx	r1
    2ffe:	4240      	negs	r0, r0
    3000:	e7f9      	b.n	2ff6 <__aeabi_idiv+0x22>
    3002:	46c0      	nop			(mov r8, r8)

00003004 <__aeabi_uidiv>:
    3004:	b500      	push	{lr}
    3006:	b083      	sub	sp, #12
    3008:	1c03      	adds	r3, r0, #0
    300a:	1c0a      	adds	r2, r1, #0
    300c:	4668      	mov	r0, sp
    300e:	1c19      	adds	r1, r3, #0
    3010:	f7ff ff9c 	bl	2f4c <__bhs_uidivmod>
    3014:	9800      	ldr	r0, [sp, #0]
    3016:	b003      	add	sp, #12
    3018:	bc02      	pop	{r1}
    301a:	4708      	bx	r1

0000301c <_pulses>:
    301c:	0ac4 0100 0ac4 0000 0080 0b38 0080 0000     ..........8.....

0000302c <_waveSampleRates>:
    302c:	0000 0444 0485 04c9 0512 055f 05b1 0608     ..D......._.....
    303c:	0664 06c5 072c 0799 080d 0888 090a 0993     d...,...........
    304c:	0a25 0abf 0b63 0c10 0cc8 0d8b 0e59 0f33     %...c.......Y.3.
    305c:	101b 1110 1214 1327 144a 157f 16c7 1821     ......'.J.....!.
    306c:	1991 1b16 1cb2 1e67 2036 2220 2428 264e     ......g.6  "($N&
    307c:	2895 2aff 2d8e 3043 3322 362c 3965 3ccf     .(.*.-C0"3,6e9.<
    308c:	406c 4441 4850 4c9d 512b 55ff 5b1c 6086     l@ADPH.L+Q.U.[.`
    309c:	6645 6c59 72ca 799e 80d9 0000               EfYl.r.y....

000030a8 <_wave>:
    30a8:	8380 8986 8f8c 9592 9c98 a29f a8a5 aeab     ................
    30b8:	b3b0 b9b6 bfbc c4c1 c9c7 cecc d3d1 d8d5     ................
    30c8:	dcda e0de e4e2 e8e6 ecea efed f2f0 f5f3     ................
    30d8:	f7f6 f9f8 fbfa fcfc fefd fffe ffff ffff     ................
    30e8:	ffff ffff ffff fefe fcfd fbfc f9fa f7f8     ................
    30f8:	f5f6 f2f3 eff0 eced e8ea e4e6 e0e2 dcde     ................
    3108:	d8da d3d5 ced1 c9cc c4c7 bfc1 b9bc b3b6     ................
    3118:	aeb0 a8ab a2a5 9c9f 9598 8f92 898c 8386     ................
    3128:	7c80 7679 7073 6a6d 6367 5d60 575a 5154     .|yvspmjgc`]ZWTQ
    3138:	4c4f 4649 4043 3b3e 3638 3133 2c2e 272a     OLIFC@>;8631.,*'
    3148:	2325 1f21 1b1d 1719 1315 1012 0d0f 0a0c     %#!.............
    3158:	0809 0607 0405 0303 0102 0001 0000 0000     ................
    3168:	0000 0000 0000 0101 0302 0403 0605 0807     ................
    3178:	0a09 0d0c 100f 1312 1715 1b19 1f1d 2321     ..............!#
    3188:	2725 2c2a 312e 3633 3b38 403e 4643 4c49     %'*,.1368;>@CFIL
    3198:	514f 5754 5d5a 6360 6a67 706d 7673 7c79     OQTWZ]`cgjmpsvy|

000031a8 <C.15.1621>:
    31a8:	c100 70e0 1c38 070e                         ...p8...

000031b0 <_clocks>:
    31b0:	5c8c 5457 575c 5c54 5a57 5257 575a 5a52     .\WT\WT\WZWRZWRZ
    31c0:	5a57 5257 575a 5a52 5957 5255 5559 5952     WZWRZWRZWYURYURY
    31d0:	5c55 5457 575c 5c54 5a57 5257 575a 5a52     U\WT\WT\WZWRZWRZ
    31e0:	5a57 5257 575a 5a52 5957 5255 5559 5952     WZWRZWRZWYURYURY
    31f0:	0055 0000                                   U...

000031f4 <_trig>:
    31f4:	0600 130d 1f19 2c25 3832 443e 504a 5c56     ......%,28>DJPV\
    3204:	6762 736d 7e78 8883 938e 9d98 a7a2 b0ab     bgmsx~..........
    3214:	b9b4 c1bd c9c5 d0cd d7d4 dedb e4e1 e9e7     ................
    3224:	eeec f2f0 f6f4 f9f7 fbfa fdfc fefe ffff     ................
